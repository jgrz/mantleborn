<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Forge | Mantleborn Dev Tools</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           MANTLEBORN LEVEL-FORGE - CSS
           ============================================ */

        :root {
            /* Backgrounds */
            --bg-deep: #0d0d14;
            --bg-mid: #1a1a2e;
            --bg-surface: #252542;

            /* Accents - ember warmth */
            --accent-ember: #e07020;
            --accent-ember-glow: #ff9040;
            --accent-magma: #c04020;

            /* Stone/neutral tones */
            --stone-dark: #3a3a5c;
            --stone-mid: #6a6a8e;
            --stone-light: #9a9abe;
            --stone-bright: #d0d0e8;

            /* Purple undertones */
            --mystic-deep: #2a1a3e;
            --mystic-glow: #8060c0;

            /* Tile states */
            --tile-undefined: transparent;
            --tile-undefined-hover: rgba(255, 255, 255, 0.05);
            --tile-open: #2a5a30;
            --tile-open-bright: #3a7a40;
            --tile-obstruction: #6a2a2a;
            --tile-obstruction-bright: #8a3a3a;
            --tile-spawn: #2a4a6a;
            --tile-spawn-bright: #3a6a9a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--stone-light);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .brand-icon {
            font-size: 20px;
            animation: flicker 2s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            70% { opacity: 1; }
            75% { opacity: 0.7; }
            80% { opacity: 1; }
        }

        .brand-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .brand-text span {
            color: var(--accent-ember);
            text-shadow: 0 0 10px rgba(224, 112, 32, 0.5);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Buttons */
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--stone-dark);
            border-color: var(--stone-mid);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--mystic-glow);
        }

        .btn-primary {
            background: var(--accent-ember);
            border-color: var(--accent-ember);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--accent-ember-glow);
            border-color: var(--accent-ember-glow);
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
        }

        .btn-danger {
            background: var(--accent-magma);
            border-color: var(--accent-magma);
            color: white;
        }

        .btn-danger:hover {
            background: #d04030;
            border-color: #d04030;
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 320px;
            height: calc(100vh - 53px);
        }

        /* Left Panel - Grid Editor */
        .editor-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 16px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-label {
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-right: 8px;
        }

        .tool-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            padding: 0;
            border-radius: 4px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.15s;
        }

        .tool-btn:hover {
            border-color: var(--stone-mid);
            background: var(--stone-dark);
        }

        .tool-btn.active {
            border-color: var(--accent-ember);
            background: var(--mystic-deep);
            color: var(--accent-ember);
        }

        .state-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            padding: 0;
            border-radius: 4px;
            border: 2px solid var(--stone-dark);
            cursor: pointer;
            transition: all 0.15s;
        }

        .state-btn.active {
            border-color: var(--accent-ember);
            box-shadow: 0 0 8px rgba(224, 112, 32, 0.5);
        }

        .state-btn[data-state="undefined"] {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 8px 8px;
        }

        .state-btn[data-state="open"] {
            background: var(--tile-open);
        }

        .state-btn[data-state="obstruction"] {
            background: var(--tile-obstruction);
        }

        .state-btn[data-state="spawn"] {
            background: var(--tile-spawn);
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--stone-dark);
        }

        /* Grid Container */
        .grid-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
            background: var(--bg-deep);
        }

        .grid-wrapper {
            position: relative;
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            padding: 2px;
        }

        .grid {
            display: grid;
            gap: 1px;
            background: var(--stone-dark);
        }

        .tile {
            width: 24px;
            height: 24px;
            background: var(--bg-mid);
            cursor: pointer;
            transition: background 0.1s;
            position: relative;
        }

        .tile:hover {
            background: var(--tile-undefined-hover);
        }

        .tile[data-state="open"] {
            background: var(--tile-open);
        }

        .tile[data-state="open"]:hover {
            background: var(--tile-open-bright);
        }

        .tile[data-state="obstruction"] {
            background: var(--tile-obstruction);
        }

        .tile[data-state="obstruction"]:hover {
            background: var(--tile-obstruction-bright);
        }

        .tile[data-state="spawn"] {
            background: var(--tile-spawn);
        }

        .tile[data-state="spawn"]:hover {
            background: var(--tile-spawn-bright);
        }

        .tile.selected {
            outline: 2px solid var(--accent-ember);
            outline-offset: -2px;
            z-index: 1;
        }

        .tile.preview {
            opacity: 0.7;
        }

        /* Selection box */
        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent-ember);
            background: rgba(224, 112, 32, 0.1);
            pointer-events: none;
            display: none;
        }

        /* Right Panel - Settings & Output */
        .right-panel {
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border-left: 1px solid var(--stone-dark);
            overflow: hidden;
            min-height: 0;
        }

        .section {
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .section-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--mystic-glow);
        }

        .form-row {
            display: flex;
            gap: 12px;
        }

        .form-row .form-group {
            flex: 1;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            padding: 8px;
            background: var(--bg-surface);
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--stone-bright);
        }

        .stat-label {
            font-size: 8px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-top: 4px;
        }

        .stat-item.open .stat-value {
            color: var(--tile-open-bright);
        }

        .stat-item.obstruction .stat-value {
            color: var(--tile-obstruction-bright);
        }

        /* Export Section */
        .export-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            min-height: 0;
            overflow: hidden;
        }

        .export-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .export-actions .btn {
            flex: 1;
        }

        .json-preview {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .json-preview-header {
            padding: 8px 12px;
            background: var(--bg-surface);
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .json-preview-content {
            flex: 1;
            overflow: auto;
            padding: 8px 12px;
            background: var(--bg-deep);
            font-size: 10px;
            line-height: 1.5;
            white-space: pre;
            min-height: 0;
        }

        .json-preview-content::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .json-preview-content::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 3px;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 16px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border-radius: 4px;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            border: 1px solid var(--stone-dark);
        }

        .legend-color.undefined {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 6px 6px;
        }

        .legend-color.open {
            background: var(--tile-open);
        }

        .legend-color.obstruction {
            background: var(--tile-obstruction);
        }

        .legend-color.spawn {
            background: var(--tile-spawn);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 20px;
            background: var(--bg-surface);
            border: 1px solid var(--accent-ember);
            border-radius: 4px;
            font-size: 12px;
            color: var(--stone-bright);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Keyboard hints */
        .keyboard-hints {
            font-size: 9px;
            color: var(--stone-dark);
            margin-top: 8px;
        }

        .keyboard-hints kbd {
            padding: 2px 5px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 3px;
            font-family: inherit;
        }

        /* Demo Mode */
        .demo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-deep);
            display: none;
            z-index: 100;
        }

        .demo-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .demo-canvas {
            image-rendering: pixelated;
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
        }

        .demo-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(13, 13, 20, 0.9);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 10px;
            color: var(--stone-light);
            z-index: 101;
        }

        .demo-hud-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--accent-ember);
            margin-bottom: 6px;
        }

        .demo-hud-controls {
            line-height: 1.6;
        }

        .demo-hud-controls kbd {
            padding: 1px 4px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 2px;
            font-family: inherit;
            font-size: 9px;
        }

        .demo-exit-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 101;
        }

        .btn-play {
            background: var(--tile-open);
            border-color: var(--tile-open);
            color: white;
        }

        .btn-play:hover {
            background: var(--tile-open-bright);
            border-color: var(--tile-open-bright);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="brand">
            <span class="brand-icon">&#128293;</span>
            <span class="brand-text">MANTLEBORN / <span>LEVEL-FORGE</span></span>
        </div>
        <div class="header-actions">
            <button class="btn btn-play" id="playDemoBtn">&#9658; Play Demo</button>
            <button class="btn" id="newLevelBtn">New Level</button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Editor Panel -->
        <div class="editor-panel">
            <!-- Toolbar -->
            <div class="toolbar">
                <div class="toolbar-group">
                    <span class="toolbar-label">Tool</span>
                    <button class="tool-btn active" data-tool="paint" title="Paint (P)">&#9998;</button>
                    <button class="tool-btn" data-tool="fill" title="Fill (F)">&#9699;</button>
                    <button class="tool-btn" data-tool="select" title="Select (S)">&#9634;</button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <span class="toolbar-label">State</span>
                    <button class="state-btn" data-state="undefined" title="Undefined (1)">?</button>
                    <button class="state-btn active" data-state="open" title="Open (2)">&#10003;</button>
                    <button class="state-btn" data-state="obstruction" title="Obstruction (3)">&#10005;</button>
                    <button class="state-btn" data-state="spawn" title="Spawn Point (4)">&#9679;</button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <button class="btn btn-small btn-danger" id="clearGridBtn">Clear All</button>
                </div>
            </div>

            <!-- Grid -->
            <div class="grid-container">
                <div class="grid-wrapper">
                    <div class="grid" id="grid"></div>
                    <div class="selection-box" id="selectionBox"></div>
                </div>

                <!-- Demo Mode Overlay -->
                <div class="demo-overlay" id="demoOverlay">
                    <canvas class="demo-canvas" id="demoCanvas"></canvas>
                    <div class="demo-hud" id="demoHud">
                        <div class="demo-hud-title">DEMO MODE</div>
                        <div class="demo-hud-controls" id="demoControls"></div>
                    </div>
                    <button class="btn btn-danger demo-exit-btn" id="exitDemoBtn">Exit Demo</button>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Grid Settings -->
            <div class="section">
                <div class="section-header">Grid Settings</div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Width (tiles)</label>
                        <input type="number" class="form-input" id="gridWidth" value="32" min="4" max="100">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Height (tiles)</label>
                        <input type="number" class="form-input" id="gridHeight" value="18" min="4" max="100">
                    </div>
                </div>
                <button class="btn btn-small" id="resizeGridBtn" style="width: 100%;">Resize Grid</button>
            </div>

            <!-- Level Info -->
            <div class="section">
                <div class="section-header">Level Info</div>
                <div class="form-group">
                    <label class="form-label">Level Name</label>
                    <input type="text" class="form-input" id="levelName" placeholder="level_01">
                </div>

                <div class="form-group">
                    <label class="form-label">Level Type</label>
                    <select class="form-input" id="levelType">
                        <option value="platformer">Platformer (side-scroll, gravity)</option>
                        <option value="topdown">Top-Down (free movement, no gravity)</option>
                    </select>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color undefined"></div>
                        <span>Undefined</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color open"></div>
                        <span>Open</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color obstruction"></div>
                        <span>Obstruction</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color spawn"></div>
                        <span>Spawn</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalTiles">576</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="undefinedTiles">576</div>
                        <div class="stat-label">Undefined</div>
                    </div>
                    <div class="stat-item open">
                        <div class="stat-value" id="openTiles">0</div>
                        <div class="stat-label">Open</div>
                    </div>
                    <div class="stat-item obstruction">
                        <div class="stat-value" id="obstructionTiles">0</div>
                        <div class="stat-label">Obstruction</div>
                    </div>
                </div>

                <div class="keyboard-hints">
                    <kbd>P</kbd> Paint &nbsp;
                    <kbd>F</kbd> Fill &nbsp;
                    <kbd>S</kbd> Select<br>
                    <kbd>1</kbd> Undefined &nbsp;
                    <kbd>2</kbd> Open &nbsp;
                    <kbd>3</kbd> Obstruction &nbsp;
                    <kbd>4</kbd> Spawn
                </div>
            </div>

            <!-- Export -->
            <div class="export-section">
                <div class="export-actions">
                    <button class="btn btn-primary" id="copyJsonBtn">Copy JSON</button>
                    <button class="btn" id="loadJsonBtn">Load JSON</button>
                </div>
                <div class="json-preview">
                    <div class="json-preview-header">JSON Output</div>
                    <div class="json-preview-content" id="jsonOutput">{}</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        /* ============================================
           MANTLEBORN LEVEL-FORGE - JavaScript
           ============================================ */

        // ==========================================
        // State
        // ==========================================
        const state = {
            gridWidth: 32,
            gridHeight: 18,
            levelType: 'platformer',  // 'platformer' | 'topdown'
            tiles: [],  // 2D array of tile states: 'undefined' | 'open' | 'obstruction'
            currentTool: 'paint',
            currentState: 'open',
            isMouseDown: false,
            selectionStart: null,
            selectionEnd: null,
            selectedTiles: new Set()
        };

        const TILE_STATES = ['undefined', 'open', 'obstruction', 'spawn'];

        // ==========================================
        // DOM Elements
        // ==========================================
        const elements = {
            grid: document.getElementById('grid'),
            selectionBox: document.getElementById('selectionBox'),
            gridWidth: document.getElementById('gridWidth'),
            gridHeight: document.getElementById('gridHeight'),
            resizeGridBtn: document.getElementById('resizeGridBtn'),
            levelName: document.getElementById('levelName'),
            levelType: document.getElementById('levelType'),
            totalTiles: document.getElementById('totalTiles'),
            undefinedTiles: document.getElementById('undefinedTiles'),
            openTiles: document.getElementById('openTiles'),
            obstructionTiles: document.getElementById('obstructionTiles'),
            copyJsonBtn: document.getElementById('copyJsonBtn'),
            loadJsonBtn: document.getElementById('loadJsonBtn'),
            clearGridBtn: document.getElementById('clearGridBtn'),
            newLevelBtn: document.getElementById('newLevelBtn'),
            jsonOutput: document.getElementById('jsonOutput'),
            toast: document.getElementById('toast'),
            // Demo mode
            playDemoBtn: document.getElementById('playDemoBtn'),
            demoOverlay: document.getElementById('demoOverlay'),
            demoCanvas: document.getElementById('demoCanvas'),
            demoControls: document.getElementById('demoControls'),
            exitDemoBtn: document.getElementById('exitDemoBtn')
        };

        // ==========================================
        // Utilities
        // ==========================================
        function showToast(message) {
            elements.toast.textContent = message;
            elements.toast.classList.add('show');
            setTimeout(() => elements.toast.classList.remove('show'), 2500);
        }

        // ==========================================
        // Grid Management
        // ==========================================
        function initGrid() {
            state.tiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    row.push('undefined');
                }
                state.tiles.push(row);
            }
            renderGrid();
            updateStats();
            updateJsonOutput();
        }

        function renderGrid() {
            elements.grid.innerHTML = '';
            elements.grid.style.gridTemplateColumns = `repeat(${state.gridWidth}, 24px)`;
            elements.grid.style.gridTemplateRows = `repeat(${state.gridHeight}, 24px)`;

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.x = x;
                    tile.dataset.y = y;

                    const tileState = state.tiles[y][x];
                    if (tileState !== 'undefined') {
                        tile.dataset.state = tileState;
                    }

                    // Mouse events
                    tile.addEventListener('mousedown', handleTileMouseDown);
                    tile.addEventListener('mouseenter', handleTileMouseEnter);
                    tile.addEventListener('mouseup', handleTileMouseUp);

                    elements.grid.appendChild(tile);
                }
            }
        }

        function resizeGrid() {
            const newWidth = parseInt(elements.gridWidth.value) || 32;
            const newHeight = parseInt(elements.gridHeight.value) || 18;

            // Clamp values
            state.gridWidth = Math.max(4, Math.min(100, newWidth));
            state.gridHeight = Math.max(4, Math.min(100, newHeight));

            elements.gridWidth.value = state.gridWidth;
            elements.gridHeight.value = state.gridHeight;

            // Resize tiles array, preserving existing data where possible
            const newTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.tiles[y] && state.tiles[y][x]) {
                        row.push(state.tiles[y][x]);
                    } else {
                        row.push('undefined');
                    }
                }
                newTiles.push(row);
            }
            state.tiles = newTiles;

            renderGrid();
            updateStats();
            updateJsonOutput();
            showToast(`Grid resized to ${state.gridWidth}x${state.gridHeight}`);
        }

        function clearGrid() {
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    state.tiles[y][x] = 'undefined';
                }
            }
            renderGrid();
            updateStats();
            updateJsonOutput();
            showToast('Grid cleared');
        }

        // ==========================================
        // Tile Operations
        // ==========================================
        function setTileState(x, y, newState) {
            if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;

            // Spawn point limit: only one allowed
            if (newState === 'spawn') {
                // Find and remove existing spawn point
                for (let sy = 0; sy < state.gridHeight; sy++) {
                    for (let sx = 0; sx < state.gridWidth; sx++) {
                        if (state.tiles[sy][sx] === 'spawn' && (sx !== x || sy !== y)) {
                            state.tiles[sy][sx] = 'open';  // Convert old spawn to open
                            const oldTile = getTileElement(sx, sy);
                            if (oldTile) oldTile.dataset.state = 'open';
                        }
                    }
                }
            }

            state.tiles[y][x] = newState;

            // Update DOM
            const tile = getTileElement(x, y);
            if (tile) {
                if (newState === 'undefined') {
                    delete tile.dataset.state;
                } else {
                    tile.dataset.state = newState;
                }
            }
        }

        function getTileElement(x, y) {
            return elements.grid.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        }

        function cycleTileState(x, y) {
            const currentState = state.tiles[y][x];
            const currentIndex = TILE_STATES.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % TILE_STATES.length;
            setTileState(x, y, TILE_STATES[nextIndex]);
        }

        // Flood fill algorithm
        function floodFill(startX, startY, fillState) {
            const originalState = state.tiles[startY][startX];
            if (originalState === fillState) return; // Already the target state

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) continue;
                if (state.tiles[y][x] !== originalState) continue;

                visited.add(key);
                setTileState(x, y, fillState);

                // Add adjacent tiles (4-directional)
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
        }

        // ==========================================
        // Mouse Handlers
        // ==========================================
        function handleTileMouseDown(e) {
            e.preventDefault();
            state.isMouseDown = true;

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);

            if (state.currentTool === 'paint') {
                // Cycle through states on click
                cycleTileState(x, y);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'fill') {
                floodFill(x, y, state.currentState);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'select') {
                state.selectionStart = { x, y };
                state.selectionEnd = { x, y };
                state.selectedTiles.clear();
                updateSelectionBox();
            }
        }

        function handleTileMouseEnter(e) {
            if (!state.isMouseDown) return;

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);

            if (state.currentTool === 'paint') {
                // Paint with current state while dragging
                setTileState(x, y, state.currentState);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'select') {
                state.selectionEnd = { x, y };
                updateSelectionBox();
            }
        }

        function handleTileMouseUp(e) {
            if (state.currentTool === 'select' && state.selectionStart && state.selectionEnd) {
                applySelectionFill();
            }
            state.isMouseDown = false;
        }

        // Global mouse up handler
        document.addEventListener('mouseup', () => {
            if (state.currentTool === 'select' && state.isMouseDown && state.selectionStart && state.selectionEnd) {
                applySelectionFill();
            }
            state.isMouseDown = false;
            elements.selectionBox.style.display = 'none';
        });

        // ==========================================
        // Selection
        // ==========================================
        function updateSelectionBox() {
            if (!state.selectionStart || !state.selectionEnd) {
                elements.selectionBox.style.display = 'none';
                return;
            }

            const minX = Math.min(state.selectionStart.x, state.selectionEnd.x);
            const maxX = Math.max(state.selectionStart.x, state.selectionEnd.x);
            const minY = Math.min(state.selectionStart.y, state.selectionEnd.y);
            const maxY = Math.max(state.selectionStart.y, state.selectionEnd.y);

            const tileSize = 25; // 24px + 1px gap

            elements.selectionBox.style.display = 'block';
            elements.selectionBox.style.left = (minX * tileSize + 2) + 'px';
            elements.selectionBox.style.top = (minY * tileSize + 2) + 'px';
            elements.selectionBox.style.width = ((maxX - minX + 1) * tileSize - 1) + 'px';
            elements.selectionBox.style.height = ((maxY - minY + 1) * tileSize - 1) + 'px';

            // Highlight selected tiles
            clearTileHighlights();
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const tile = getTileElement(x, y);
                    if (tile) tile.classList.add('selected');
                }
            }
        }

        function applySelectionFill() {
            if (!state.selectionStart || !state.selectionEnd) return;

            const minX = Math.min(state.selectionStart.x, state.selectionEnd.x);
            const maxX = Math.max(state.selectionStart.x, state.selectionEnd.x);
            const minY = Math.min(state.selectionStart.y, state.selectionEnd.y);
            const maxY = Math.max(state.selectionStart.y, state.selectionEnd.y);

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    setTileState(x, y, state.currentState);
                }
            }

            clearTileHighlights();
            state.selectionStart = null;
            state.selectionEnd = null;
            elements.selectionBox.style.display = 'none';

            updateStats();
            updateJsonOutput();
        }

        function clearTileHighlights() {
            document.querySelectorAll('.tile.selected').forEach(tile => {
                tile.classList.remove('selected');
            });
        }

        // ==========================================
        // Tool & State Selection
        // ==========================================
        function setTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            clearTileHighlights();
            elements.selectionBox.style.display = 'none';
        }

        function setState(newState) {
            state.currentState = newState;
            document.querySelectorAll('.state-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.state === newState);
            });
        }

        // Tool button click handlers
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => setTool(btn.dataset.tool));
        });

        // State button click handlers
        document.querySelectorAll('.state-btn').forEach(btn => {
            btn.addEventListener('click', () => setState(btn.dataset.state));
        });

        // ==========================================
        // Stats
        // ==========================================
        function updateStats() {
            let undefinedCount = 0;
            let openCount = 0;
            let obstructionCount = 0;
            let spawnCount = 0;

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'undefined') undefinedCount++;
                    else if (tileState === 'open') openCount++;
                    else if (tileState === 'obstruction') obstructionCount++;
                    else if (tileState === 'spawn') spawnCount++;
                }
            }

            const total = state.gridWidth * state.gridHeight;

            elements.totalTiles.textContent = total;
            elements.undefinedTiles.textContent = undefinedCount;
            // Include spawn in the "open" count since it's walkable
            elements.openTiles.textContent = openCount + spawnCount;
            elements.obstructionTiles.textContent = obstructionCount;
        }

        // ==========================================
        // JSON Export/Import
        // ==========================================
        function generateLevelData() {
            const levelName = elements.levelName.value || 'untitled';
            const levelType = state.levelType;

            // Encode tiles - we'll use a compact format
            // 0 = undefined, 1 = open, 2 = obstruction, 3 = spawn
            const tileData = [];
            let spawnPoint = null;

            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'undefined') row.push(0);
                    else if (tileState === 'open') row.push(1);
                    else if (tileState === 'obstruction') row.push(2);
                    else if (tileState === 'spawn') {
                        row.push(3);
                        spawnPoint = { x, y };
                    }
                }
                tileData.push(row);
            }

            // Also generate a list of walkable coordinates for easier game use
            const walkable = [];
            const obstructions = [];

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'open' || tileState === 'spawn') {
                        walkable.push({ x, y });
                    } else if (tileState === 'obstruction') {
                        obstructions.push({ x, y });
                    }
                }
            }

            // Physics settings based on level type
            const physics = levelType === 'platformer'
                ? {
                    gravity: true,
                    gravityStrength: 1800,
                    collisionMode: 'solid',  // obstructions are solid from all sides
                    playerCanLand: true       // player lands on top of obstructions
                }
                : {
                    gravity: false,
                    gravityStrength: 0,
                    collisionMode: 'blocking', // obstructions block movement
                    playerCanLand: false
                };

            return {
                name: levelName,
                type: levelType,
                width: state.gridWidth,
                height: state.gridHeight,
                tileSize: 24,  // Can be adjusted for game
                physics: physics,
                spawn: spawnPoint,
                grid: tileData,
                walkable: walkable,
                obstructions: obstructions,
                meta: {
                    totalTiles: state.gridWidth * state.gridHeight,
                    walkableCount: walkable.length,
                    obstructionCount: obstructions.length
                }
            };
        }

        function updateJsonOutput() {
            const levelData = generateLevelData();
            elements.jsonOutput.textContent = JSON.stringify(levelData, null, 2);
        }

        function copyJson() {
            navigator.clipboard.writeText(elements.jsonOutput.textContent)
                .then(() => showToast('Level JSON copied!'))
                .catch(() => showToast('Failed to copy'));
        }

        function loadJson() {
            const jsonStr = prompt('Paste level JSON:');
            if (!jsonStr) return;

            try {
                const levelData = JSON.parse(jsonStr);

                if (levelData.width && levelData.height && levelData.grid) {
                    state.gridWidth = levelData.width;
                    state.gridHeight = levelData.height;
                    elements.gridWidth.value = state.gridWidth;
                    elements.gridHeight.value = state.gridHeight;

                    state.tiles = [];
                    for (let y = 0; y < state.gridHeight; y++) {
                        const row = [];
                        for (let x = 0; x < state.gridWidth; x++) {
                            const value = levelData.grid[y]?.[x] ?? 0;
                            if (value === 1) row.push('open');
                            else if (value === 2) row.push('obstruction');
                            else if (value === 3) row.push('spawn');
                            else row.push('undefined');
                        }
                        state.tiles.push(row);
                    }

                    if (levelData.name) {
                        elements.levelName.value = levelData.name;
                    }

                    if (levelData.type) {
                        state.levelType = levelData.type;
                        elements.levelType.value = levelData.type;
                    }

                    renderGrid();
                    updateStats();
                    updateJsonOutput();
                    showToast('Level loaded!');
                } else {
                    showToast('Invalid level data');
                }
            } catch (e) {
                showToast('Invalid JSON');
            }
        }

        // ==========================================
        // Event Listeners
        // ==========================================
        elements.resizeGridBtn.addEventListener('click', resizeGrid);
        elements.clearGridBtn.addEventListener('click', clearGrid);
        elements.newLevelBtn.addEventListener('click', () => {
            if (confirm('Create new level? Current progress will be lost.')) {
                elements.levelName.value = '';
                clearGrid();
            }
        });
        elements.copyJsonBtn.addEventListener('click', copyJson);
        elements.loadJsonBtn.addEventListener('click', loadJson);
        elements.levelName.addEventListener('input', updateJsonOutput);
        elements.levelType.addEventListener('change', (e) => {
            state.levelType = e.target.value;
            updateJsonOutput();
        });

        // Keyboard shortcuts (editor mode only)
        window.addEventListener('keydown', (e) => {
            if (demo.active) return;  // Don't handle editor shortcuts in demo mode
            if (document.activeElement.tagName === 'INPUT') return;
            if (document.activeElement.tagName === 'SELECT') return;

            switch (e.key.toLowerCase()) {
                case 'p':
                    setTool('paint');
                    break;
                case 'f':
                    setTool('fill');
                    break;
                case 's':
                    setTool('select');
                    break;
                case '1':
                    setState('undefined');
                    break;
                case '2':
                    setState('open');
                    break;
                case '3':
                    setState('obstruction');
                    break;
                case '4':
                    setState('spawn');
                    break;
                case 'escape':
                    clearTileHighlights();
                    elements.selectionBox.style.display = 'none';
                    state.selectionStart = null;
                    state.selectionEnd = null;
                    break;
            }
        });

        // ==========================================
        // Demo Mode
        // ==========================================
        const demo = {
            active: false,
            ctx: null,
            player: {
                x: 100,
                y: 100,
                width: 20,
                height: 32,
                vx: 0,
                vy: 0,
                onGround: false
            },
            keys: {},
            animationFrame: null,
            lastTime: 0
        };

        const DEMO_SCALE = 2;
        const PLAYER_SPEED = 200;
        const JUMP_FORCE = 500;
        const GRAVITY = 1200;
        const TOPDOWN_SPEED = 150;

        function startDemo() {
            demo.active = true;
            demo.ctx = elements.demoCanvas.getContext('2d');
            demo.ctx.imageSmoothingEnabled = false;

            // Set canvas size
            const canvasWidth = state.gridWidth * 24;
            const canvasHeight = state.gridHeight * 24;
            elements.demoCanvas.width = canvasWidth;
            elements.demoCanvas.height = canvasHeight;
            elements.demoCanvas.style.width = (canvasWidth * DEMO_SCALE) + 'px';
            elements.demoCanvas.style.height = (canvasHeight * DEMO_SCALE) + 'px';

            // Find spawn point (first open tile from bottom-left for platformer, center for topdown)
            resetPlayerPosition();

            // Update HUD controls text
            if (state.levelType === 'platformer') {
                elements.demoControls.innerHTML = `
                    <kbd>&#8592;</kbd><kbd>&#8594;</kbd> Move<br>
                    <kbd>Space</kbd> Jump<br>
                    <kbd>Esc</kbd> Exit
                `;
            } else {
                elements.demoControls.innerHTML = `
                    <kbd>&#8592;</kbd><kbd>&#8594;</kbd><kbd>&#8593;</kbd><kbd>&#8595;</kbd> Move<br>
                    <kbd>Esc</kbd> Exit
                `;
            }

            // Show overlay
            elements.demoOverlay.classList.add('active');

            // Start game loop
            demo.lastTime = performance.now();
            demo.animationFrame = requestAnimationFrame(demoLoop);
        }

        function stopDemo() {
            demo.active = false;
            elements.demoOverlay.classList.remove('active');
            if (demo.animationFrame) {
                cancelAnimationFrame(demo.animationFrame);
                demo.animationFrame = null;
            }
            demo.keys = {};
        }

        function resetPlayerPosition() {
            const tileSize = 24;

            // First, look for spawn point
            let spawnX = -1, spawnY = -1;
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.tiles[y][x] === 'spawn') {
                        spawnX = x;
                        spawnY = y;
                        break;
                    }
                }
                if (spawnX !== -1) break;
            }

            // If spawn point found, use it
            if (spawnX !== -1) {
                demo.player.x = spawnX * tileSize + (tileSize - demo.player.width) / 2;
                demo.player.y = spawnY * tileSize + (tileSize - demo.player.height);
                demo.player.vx = 0;
                demo.player.vy = 0;
                demo.player.onGround = false;
                return;
            }

            if (state.levelType === 'platformer') {
                // Find first open tile from bottom, scanning left to right (not on obstruction)
                for (let y = state.gridHeight - 1; y >= 0; y--) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        if (state.tiles[y][x] === 'open') {
                            // Check if there's ground below or at bottom
                            const hasGround = y === state.gridHeight - 1 ||
                                             state.tiles[y + 1]?.[x] === 'obstruction';
                            if (hasGround) {
                                demo.player.x = x * tileSize + (tileSize - demo.player.width) / 2;
                                demo.player.y = y * tileSize + (tileSize - demo.player.height);
                                demo.player.vx = 0;
                                demo.player.vy = 0;
                                return;
                            }
                        }
                    }
                }
                // Fallback: top-left
                demo.player.x = tileSize;
                demo.player.y = tileSize;
            } else {
                // Top-down: find first open tile or center of level
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        if (state.tiles[y][x] === 'open') {
                            demo.player.x = x * tileSize + (tileSize - demo.player.width) / 2;
                            demo.player.y = y * tileSize + (tileSize - demo.player.height) / 2;
                            demo.player.vx = 0;
                            demo.player.vy = 0;
                            return;
                        }
                    }
                }
                // Fallback: center of level
                demo.player.x = (state.gridWidth * tileSize) / 2 - demo.player.width / 2;
                demo.player.y = (state.gridHeight * tileSize) / 2 - demo.player.height / 2;
            }
            demo.player.vx = 0;
            demo.player.vy = 0;
        }

        function demoLoop(currentTime) {
            if (!demo.active) return;

            const dt = Math.min((currentTime - demo.lastTime) / 1000, 0.05);
            demo.lastTime = currentTime;

            updatePlayer(dt);
            renderDemo();

            demo.animationFrame = requestAnimationFrame(demoLoop);
        }

        function updatePlayer(dt) {
            const p = demo.player;
            const tileSize = 24;

            if (state.levelType === 'platformer') {
                // Horizontal movement
                p.vx = 0;
                if (demo.keys['ArrowLeft'] || demo.keys['KeyA']) p.vx = -PLAYER_SPEED;
                if (demo.keys['ArrowRight'] || demo.keys['KeyD']) p.vx = PLAYER_SPEED;

                // Gravity
                p.vy += GRAVITY * dt;

                // Jump
                if ((demo.keys['Space'] || demo.keys['ArrowUp'] || demo.keys['KeyW']) && p.onGround) {
                    p.vy = -JUMP_FORCE;
                    p.onGround = false;
                }

                // Apply velocity
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Collision detection
                p.onGround = false;

                // Check tile collisions
                const left = Math.floor(p.x / tileSize);
                const right = Math.floor((p.x + p.width - 1) / tileSize);
                const top = Math.floor(p.y / tileSize);
                const bottom = Math.floor((p.y + p.height - 1) / tileSize);

                // Vertical collision (landing on platforms)
                for (let tx = left; tx <= right; tx++) {
                    // Check below
                    const tileBelow = state.tiles[bottom]?.[tx];
                    if (tileBelow === 'obstruction') {
                        if (p.vy > 0) {
                            p.y = bottom * tileSize - p.height;
                            p.vy = 0;
                            p.onGround = true;
                        }
                    }
                    // Check above
                    const tileAbove = state.tiles[top]?.[tx];
                    if (tileAbove === 'obstruction') {
                        if (p.vy < 0) {
                            p.y = (top + 1) * tileSize;
                            p.vy = 0;
                        }
                    }
                }

                // Recalculate after vertical adjustment
                const newTop = Math.floor(p.y / tileSize);
                const newBottom = Math.floor((p.y + p.height - 1) / tileSize);

                // Horizontal collision
                for (let ty = newTop; ty <= newBottom; ty++) {
                    // Check left
                    const newLeft = Math.floor(p.x / tileSize);
                    if (state.tiles[ty]?.[newLeft] === 'obstruction') {
                        p.x = (newLeft + 1) * tileSize;
                    }
                    // Check right
                    const newRight = Math.floor((p.x + p.width - 1) / tileSize);
                    if (state.tiles[ty]?.[newRight] === 'obstruction') {
                        p.x = newRight * tileSize - p.width;
                    }
                }

                // Bounds
                p.x = Math.max(0, Math.min(p.x, state.gridWidth * tileSize - p.width));
                p.y = Math.max(0, Math.min(p.y, state.gridHeight * tileSize - p.height));

                // Ground at bottom of level
                if (p.y >= state.gridHeight * tileSize - p.height) {
                    p.y = state.gridHeight * tileSize - p.height;
                    p.vy = 0;
                    p.onGround = true;
                }

            } else {
                // Top-down movement
                p.vx = 0;
                p.vy = 0;
                if (demo.keys['ArrowLeft'] || demo.keys['KeyA']) p.vx = -TOPDOWN_SPEED;
                if (demo.keys['ArrowRight'] || demo.keys['KeyD']) p.vx = TOPDOWN_SPEED;
                if (demo.keys['ArrowUp'] || demo.keys['KeyW']) p.vy = -TOPDOWN_SPEED;
                if (demo.keys['ArrowDown'] || demo.keys['KeyS']) p.vy = TOPDOWN_SPEED;

                // Normalize diagonal movement
                if (p.vx !== 0 && p.vy !== 0) {
                    p.vx *= 0.707;
                    p.vy *= 0.707;
                }

                // Try X movement
                const newX = p.x + p.vx * dt;
                if (!checkCollisionTopDown(newX, p.y, p.width, p.height)) {
                    p.x = newX;
                }

                // Try Y movement
                const newY = p.y + p.vy * dt;
                if (!checkCollisionTopDown(p.x, newY, p.width, p.height)) {
                    p.y = newY;
                }

                // Bounds
                p.x = Math.max(0, Math.min(p.x, state.gridWidth * tileSize - p.width));
                p.y = Math.max(0, Math.min(p.y, state.gridHeight * tileSize - p.height));
            }
        }

        function checkCollisionTopDown(x, y, w, h) {
            const tileSize = 24;
            const left = Math.floor(x / tileSize);
            const right = Math.floor((x + w - 1) / tileSize);
            const top = Math.floor(y / tileSize);
            const bottom = Math.floor((y + h - 1) / tileSize);

            for (let ty = top; ty <= bottom; ty++) {
                for (let tx = left; tx <= right; tx++) {
                    const tile = state.tiles[ty]?.[tx];
                    // Only obstruction blocks movement (open, spawn, undefined are walkable)
                    if (tile === 'obstruction') {
                        return true;
                    }
                }
            }
            return false;
        }

        function renderDemo() {
            const ctx = demo.ctx;
            const tileSize = 24;

            // Clear
            ctx.fillStyle = '#0d0d14';
            ctx.fillRect(0, 0, elements.demoCanvas.width, elements.demoCanvas.height);

            // Draw tiles
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = state.tiles[y][x];
                    if (tile === 'open') {
                        ctx.fillStyle = '#2a5a30';
                    } else if (tile === 'obstruction') {
                        ctx.fillStyle = '#6a2a2a';
                    } else if (tile === 'spawn') {
                        ctx.fillStyle = '#2a4a6a';
                    } else {
                        ctx.fillStyle = '#1a1a2e';
                    }
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                }
            }

            // Draw player
            ctx.fillStyle = '#e07020';
            ctx.fillRect(
                Math.round(demo.player.x),
                Math.round(demo.player.y),
                demo.player.width,
                demo.player.height
            );

            // Player face indicator (shows direction)
            ctx.fillStyle = '#fff';
            const eyeY = Math.round(demo.player.y) + 6;
            const eyeSize = 3;
            ctx.fillRect(Math.round(demo.player.x) + 4, eyeY, eyeSize, eyeSize);
            ctx.fillRect(Math.round(demo.player.x) + demo.player.width - 7, eyeY, eyeSize, eyeSize);
        }

        // Demo key handlers
        function handleDemoKeyDown(e) {
            if (!demo.active) return;

            // Prevent default for game controls to avoid page scrolling/other browser behavior
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' ||
                e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                e.preventDefault();
            }

            demo.keys[e.code] = true;

            if (e.code === 'Escape') {
                stopDemo();
            }
        }

        function handleDemoKeyUp(e) {
            if (!demo.active) return;

            // Prevent default for game controls
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' ||
                e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                e.preventDefault();
            }

            demo.keys[e.code] = false;
        }

        window.addEventListener('keydown', handleDemoKeyDown);
        window.addEventListener('keyup', handleDemoKeyUp);

        elements.playDemoBtn.addEventListener('click', startDemo);
        elements.exitDemoBtn.addEventListener('click', stopDemo);

        // ==========================================
        // Initialize
        // ==========================================
        initGrid();
    </script>
</body>
</html>
