<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incarnum | Game Wizard</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           INCARNUM - CSS
           ============================================ */

        :root {
            /* Backgrounds */
            --bg-deep: #0d0d14;
            --bg-mid: #1a1a2e;
            --bg-surface: #252542;

            /* Accents - pink/purple */
            --accent-pink: #ff6b9d;
            --accent-pink-glow: #ff8fb3;
            --accent-purple: #9b6dff;

            /* Stone/neutral tones */
            --stone-dark: #3a3a5c;
            --stone-mid: #6a6a8e;
            --stone-light: #9a9abe;
            --stone-bright: #d0d0e8;

            /* Status */
            --success: #4ade80;
            --warning: #fbbf24;
            --error: #f87171;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--stone-light);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .home-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            font-size: 18px;
            text-decoration: none;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .home-btn:hover {
            background: var(--stone-dark);
            border-color: var(--accent-pink);
        }

        .brand-icon {
            font-size: 20px;
        }

        .brand-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .brand-text span {
            color: var(--accent-pink);
            text-shadow: 0 0 10px rgba(255, 107, 157, 0.5);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-select {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-light);
            cursor: pointer;
            min-width: 160px;
        }

        .header-select:focus {
            outline: none;
            border-color: var(--accent-pink);
        }

        .auth-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .auth-indicator.logged-in {
            border-color: var(--accent-purple);
            color: var(--stone-light);
        }

        .auth-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--stone-dark);
        }

        .auth-indicator.logged-in .auth-dot {
            background: var(--success);
        }

        .save-indicator {
            font-size: 10px;
            color: var(--stone-mid);
            min-width: 60px;
            text-align: right;
        }

        .save-indicator.saving {
            color: var(--accent-pink);
        }

        .save-indicator.saved {
            color: var(--success);
        }

        /* Buttons */
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--stone-dark);
            border-color: var(--stone-mid);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3a2a4a, #4a3a5a);
            border-color: var(--accent-pink);
            color: var(--accent-pink);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--accent-pink);
            color: white;
        }

        .btn-danger {
            border-color: var(--error);
            color: var(--error);
        }

        .btn-danger:hover {
            background: var(--error);
            color: white;
        }

        .btn-ai {
            background: linear-gradient(135deg, #4a2a6a, #6a3a8a);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }

        .btn-ai:hover:not(:disabled) {
            background: var(--accent-purple);
            color: white;
        }

        /* AI Generation Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 12px;
            width: 100%;
            max-width: 520px;
            max-height: 90vh;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform 0.2s;
        }

        .modal-overlay.active .modal {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .modal-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--accent-purple);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--stone-mid);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--stone-bright);
        }

        .modal-body {
            padding: 20px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 11px;
            color: var(--stone-mid);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 10px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--accent-purple);
        }

        .form-textarea {
            min-height: 80px;
            resize: vertical;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .form-hint {
            font-size: 10px;
            color: var(--stone-dark);
            margin-top: 4px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid var(--stone-dark);
            background: var(--bg-surface);
        }

        .generation-progress {
            display: none;
            text-align: center;
            padding: 40px 20px;
        }

        .generation-progress.active {
            display: block;
        }

        .generation-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--stone-dark);
            border-top-color: var(--accent-purple);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .generation-status {
            font-size: 12px;
            color: var(--stone-light);
            margin-bottom: 8px;
        }

        .generation-substatus {
            font-size: 10px;
            color: var(--stone-mid);
        }

        .generation-preview {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .generation-preview.active {
            display: block;
        }

        .preview-header {
            font-size: 12px;
            color: var(--accent-purple);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .preview-canvas-wrapper {
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            padding: 20px;
            display: inline-block;
            margin-bottom: 12px;
        }

        #previewCanvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .preview-info {
            font-size: 10px;
            color: var(--stone-mid);
            margin-bottom: 16px;
        }

        .preview-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 360px;
            height: calc(100vh - 53px);
            overflow: hidden;
        }

        /* Left Panel */
        .left-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 20px;
            gap: 20px;
        }

        /* Preview Area */
        .preview-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            min-height: 300px;
        }

        .preview-canvas-wrapper {
            position: relative;
            background:
                repeating-conic-gradient(var(--bg-surface) 0% 25%, var(--bg-deep) 0% 50%)
                50% / 16px 16px;
            border-radius: 4px;
            padding: 20px;
        }

        #previewCanvas {
            display: block;
            image-rendering: pixelated;
        }

        .preview-label {
            margin-top: 16px;
            font-size: 12px;
            color: var(--stone-mid);
        }

        .preview-empty {
            text-align: center;
            color: var(--stone-dark);
        }

        .preview-empty-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Character Library */
        .library-section {
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            padding: 16px;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .library-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--accent-pink);
        }

        .library-grid {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-height: 120px;
            overflow-y: auto;
        }

        .character-tile {
            width: 56px;
            height: 56px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 24px;
        }

        .character-tile:hover {
            border-color: var(--accent-pink);
        }

        .character-tile.active {
            border-color: var(--accent-pink);
            box-shadow: 0 0 10px rgba(255, 107, 157, 0.3);
        }

        .character-tile canvas {
            image-rendering: pixelated;
        }

        .character-tile-delete {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--error);
            color: white;
            border: none;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .character-tile:hover .character-tile-delete {
            display: flex;
        }

        .library-empty {
            text-align: center;
            padding: 20px;
            color: var(--stone-dark);
            font-size: 12px;
        }

        /* Right Panel */
        .right-panel {
            background: var(--bg-mid);
            border-left: 1px solid var(--stone-dark);
            overflow-y: auto;
            padding: 20px;
        }

        .panel-section {
            margin-bottom: 24px;
        }

        .panel-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--accent-pink);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--stone-dark);
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            font-family: inherit;
            font-size: 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            color: var(--stone-light);
            border-radius: 4px;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-pink);
        }

        .form-select {
            width: 100%;
            padding: 8px 12px;
            font-family: inherit;
            font-size: 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            color: var(--stone-light);
            border-radius: 4px;
            cursor: pointer;
        }

        /* Sprite Grid */
        .sprite-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
            gap: 6px;
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-surface);
            border-radius: 4px;
            padding: 8px;
        }

        .sprite-tile {
            width: 48px;
            height: 48px;
            background: var(--bg-deep);
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .sprite-tile:hover {
            border-color: var(--stone-mid);
        }

        .sprite-tile.selected {
            border-color: var(--accent-pink);
            box-shadow: 0 0 8px rgba(255, 107, 157, 0.4);
        }

        .sprite-tile canvas {
            image-rendering: pixelated;
        }

        .sprite-empty {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            color: var(--stone-dark);
            font-size: 11px;
        }

        /* Animation Slots */
        .animation-category {
            margin-bottom: 16px;
        }

        .animation-category-header {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--stone-mid);
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .animation-category-header.essential {
            color: var(--accent-purple);
            border-color: var(--accent-purple);
        }

        .animation-category-header.advanced {
            color: var(--stone-mid);
        }

        .animation-slot {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .animation-slot-label {
            width: 80px;
            font-size: 11px;
            color: var(--stone-light);
            text-transform: capitalize;
        }

        .animation-slot-select {
            flex: 1;
            padding: 6px 10px;
            font-family: inherit;
            font-size: 11px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            color: var(--stone-light);
            border-radius: 4px;
        }

        .animation-slot-remove {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--stone-mid);
            cursor: pointer;
            font-size: 14px;
            border-radius: 4px;
        }

        .animation-slot-remove:hover {
            background: var(--error);
            color: white;
        }

        .custom-slots {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed var(--stone-dark);
        }

        .custom-slot {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .custom-slot-name {
            width: 80px;
            padding: 6px 8px;
            font-family: inherit;
            font-size: 11px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            color: var(--stone-light);
            border-radius: 4px;
        }

        /* Tags */
        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 8px;
        }

        .tag {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--accent-purple);
            color: white;
            border-radius: 12px;
            font-size: 10px;
        }

        .tag-remove {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            line-height: 1;
            opacity: 0.7;
        }

        .tag-remove:hover {
            opacity: 1;
        }

        .tag-input-wrapper {
            display: flex;
            gap: 6px;
        }

        .tag-input {
            flex: 1;
            padding: 6px 10px;
            font-family: inherit;
            font-size: 11px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            color: var(--stone-light);
            border-radius: 4px;
        }

        .tag-add-btn {
            padding: 6px 12px;
            font-size: 11px;
        }

        /* Properties Table */
        .properties-table {
            width: 100%;
            border-collapse: collapse;
        }

        .properties-table th {
            text-align: left;
            font-size: 9px;
            color: var(--stone-mid);
            text-transform: uppercase;
            padding: 6px 4px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .properties-table td {
            padding: 4px;
        }

        .property-row input,
        .property-row select {
            width: 100%;
            padding: 6px 8px;
            font-family: inherit;
            font-size: 11px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            color: var(--stone-light);
            border-radius: 4px;
        }

        .property-row .prop-key {
            width: 80px;
        }

        .property-row .prop-type {
            width: 70px;
        }

        .property-remove {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--stone-mid);
            cursor: pointer;
            font-size: 14px;
        }

        .property-remove:hover {
            color: var(--error);
        }

        .add-property-btn {
            width: 100%;
            margin-top: 8px;
            padding: 8px;
            font-size: 11px;
            border-style: dashed;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 24px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            font-size: 12px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.error {
            border-color: var(--error);
            color: var(--error);
        }

        .toast.success {
            border-color: var(--success);
            color: var(--success);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-deep);
        }

        /* Engine Selector */
        .engine-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            padding: 8px;
            background: var(--bg-deep);
            border-radius: 6px;
        }

        .engine-option {
            flex: 1;
            padding: 10px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .engine-option:hover {
            border-color: var(--stone-mid);
        }

        .engine-option.active {
            border-color: var(--accent-pink);
            background: rgba(255, 107, 157, 0.1);
        }

        .engine-option input {
            display: none;
        }

        .engine-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--stone-bright);
        }

        .engine-option.active .engine-label {
            color: var(--accent-pink);
        }

        .engine-desc {
            font-size: 9px;
            color: var(--stone-mid);
            margin-top: 4px;
        }

        /* Engine Forms */
        .claude-form {
            display: none;
        }

        .claude-form.active {
            display: block;
        }

        .pixellab-form {
            display: none;
        }

        .pixellab-form.active {
            display: block;
        }

        .pixellab-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .pixellab-section {
            background: var(--bg-surface);
            border-radius: 6px;
            padding: 12px;
        }

        .pixellab-section h4 {
            font-size: 10px;
            font-weight: 600;
            color: var(--stone-bright);
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .skeleton-container {
            background: var(--bg-deep);
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
        }

        .skeleton-presets {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .skeleton-preset-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            padding: 4px 8px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 3px;
            color: var(--stone-light);
            cursor: pointer;
        }

        .skeleton-preset-btn:hover {
            border-color: var(--accent-purple);
        }

        .skeleton-preset-btn.active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }

        /* Generation Queue Panel */
        .generation-queue-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 1500;
            display: none;
        }

        .generation-queue-panel.visible {
            display: block;
        }

        /* View Queue Button */
        .view-queue-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 16px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--stone-light);
            cursor: pointer;
            z-index: 1400;
            display: none;
        }

        .view-queue-btn:hover {
            border-color: var(--accent-pink);
            color: var(--accent-pink);
        }

        .view-queue-btn.has-jobs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .queue-count {
            background: var(--accent-pink);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="brand">
            <a href="/game-wizard/" class="home-btn" title="Back to Game Wizard">&#128302;</a>
            <span class="brand-icon">&#129497;</span>
            <span class="brand-text">GAME WIZARD / <span>INCARNUM</span></span>
        </div>
        <div class="header-actions">
            <select class="header-select" id="projectSelect">
                <option value="">-- Select Project --</option>
            </select>
            <span class="save-indicator" id="saveIndicator"></span>
            <div class="auth-indicator" id="authIndicator">
                <span class="auth-dot"></span>
                <span class="auth-text">Guest</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Left Panel -->
        <div class="left-panel">
            <!-- Preview -->
            <div class="preview-area">
                <div class="preview-empty" id="previewEmpty">
                    <div class="preview-empty-icon">&#129497;</div>
                    <div>Select a project and create a character</div>
                </div>
                <div class="preview-canvas-wrapper" id="previewWrapper" style="display: none;">
                    <canvas id="previewCanvas" width="128" height="128"></canvas>
                </div>
                <div class="preview-label" id="previewLabel"></div>
            </div>

            <!-- Character Library -->
            <div class="library-section">
                <div class="library-header">
                    <span class="library-title">Characters</span>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-ai" id="generateCharacterBtn" disabled>&#129302; Generate</button>
                        <button class="btn btn-primary" id="newCharacterBtn" disabled>+ New</button>
                    </div>
                </div>
                <div class="library-grid" id="characterLibrary">
                    <div class="library-empty">Select a project to see characters</div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Character Info -->
            <div class="panel-section">
                <div class="panel-header">Character Info</div>
                <div class="form-group">
                    <label class="form-label">Name</label>
                    <input type="text" class="form-input" id="characterName" placeholder="Character name..." disabled>
                </div>
                <div class="form-group">
                    <label class="form-label">Identifier</label>
                    <input type="text" class="form-input" id="characterIdentifier" placeholder="Auto-generated..." disabled>
                </div>
                <div class="form-group">
                    <label class="form-label">Type</label>
                    <select class="form-select" id="characterType" disabled>
                        <option value="playable">Playable</option>
                        <option value="npc">NPC</option>
                        <option value="enemy">Enemy</option>
                        <option value="object">Object</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Perspective</label>
                    <select class="form-select" id="characterPerspective" disabled>
                        <option value="side_view">Side View (Platformer)</option>
                        <option value="top_down">Top Down (RPG)</option>
                    </select>
                </div>
            </div>

            <!-- Default Sprite -->
            <div class="panel-section">
                <div class="panel-header">Default Sprite</div>
                <div class="sprite-grid" id="spriteGrid">
                    <div class="sprite-empty">Select a project to load sprites</div>
                </div>
            </div>

            <!-- Animations -->
            <div class="panel-section">
                <div class="panel-header">Animations</div>
                <div id="animationSlots">
                    <!-- Dynamically populated based on perspective -->
                </div>
                <div class="custom-slots" id="customSlots"></div>
                <button class="btn add-property-btn" id="addAnimationBtn" disabled>+ Add Custom Animation</button>
            </div>

            <!-- Tags -->
            <div class="panel-section">
                <div class="panel-header">Tags</div>
                <div class="tags-container" id="tagsContainer"></div>
                <div class="tag-input-wrapper">
                    <input type="text" class="tag-input" id="tagInput" placeholder="Add tag..." disabled>
                    <button class="btn tag-add-btn" id="addTagBtn" disabled>Add</button>
                </div>
            </div>

            <!-- Properties -->
            <div class="panel-section">
                <div class="panel-header">Properties</div>
                <table class="properties-table">
                    <thead>
                        <tr>
                            <th>Key</th>
                            <th>Type</th>
                            <th>Value</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="propertiesBody"></tbody>
                </table>
                <button class="btn add-property-btn" id="addPropertyBtn" disabled>+ Add Property</button>
            </div>

            <!-- Actions -->
            <div class="panel-section">
                <button class="btn btn-primary" id="saveCharacterBtn" style="width: 100%; margin-bottom: 8px;" disabled>Save Character</button>
                <button class="btn btn-danger" id="deleteCharacterBtn" style="width: 100%;" disabled>Delete Character</button>
            </div>
        </div>
    </main>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Help Drawer -->
    <link rel="stylesheet" href="../shared/help-drawer.css">
    <!-- AI Generation Modal -->
    <div class="modal-overlay" id="generateModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">&#129302; Generate Character</span>
                <button class="modal-close" id="closeGenerateModal">&times;</button>
            </div>
            <div class="modal-body" id="generateForm">
                <!-- Engine Selector -->
                <div class="engine-selector">
                    <label class="engine-option active" id="engineClaude">
                        <input type="radio" name="genEngine" value="claude" checked>
                        <div class="engine-label">Claude AI</div>
                        <div class="engine-desc">Built-in generation</div>
                    </label>
                    <label class="engine-option" id="enginePixelLab">
                        <input type="radio" name="genEngine" value="pixellab">
                        <div class="engine-label">PixelLab</div>
                        <div class="engine-desc">Professional pixel art</div>
                    </label>
                </div>

                <!-- Claude Form (existing) -->
                <div id="claudeForm" class="claude-form active">
                    <div class="form-group">
                        <label class="form-label">Character Description</label>
                        <textarea class="form-textarea" id="genPrompt" placeholder="A brave knight with silver armor, blue cape, and a glowing sword..."></textarea>
                        <div class="form-hint">Describe your character's appearance, colors, and style</div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Sprite Size</label>
                            <select class="form-select" id="genSize">
                                <option value="16">16x16</option>
                                <option value="24" selected>24x24</option>
                                <option value="32">32x32</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Art Style</label>
                            <select class="form-select" id="genStyle">
                                <option value="pixel_8bit">8-bit Retro</option>
                                <option value="pixel_16bit" selected>16-bit Classic</option>
                                <option value="pixel_32bit">32-bit Detailed</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Perspective</label>
                            <select class="form-select" id="genPerspective">
                                <option value="side_view" selected>Side View (Platformer)</option>
                                <option value="top_down">Top Down (RPG)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Palette Size</label>
                            <select class="form-select" id="genPalette">
                                <option value="8">8 Colors</option>
                                <option value="16" selected>16 Colors</option>
                                <option value="32">32 Colors</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Character Type</label>
                        <select class="form-select" id="genCharType">
                            <option value="humanoid" selected>Humanoid</option>
                            <option value="creature">Creature/Monster</option>
                        <option value="robot">Robot/Mech</option>
                        <option value="animal">Animal</option>
                        <option value="fantasy">Fantasy Being</option>
                    </select>
                    </div>
                </div>

                <!-- PixelLab Form -->
                <div id="pixellabForm" class="pixellab-form">
                    <div class="pixellab-grid">
                        <div class="pixellab-section">
                            <h4>Description</h4>
                            <div class="form-group">
                                <label class="form-label">Character Description *</label>
                                <textarea class="form-textarea" id="plPrompt" placeholder="A brave knight in silver armor with a red cape"></textarea>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Negative Prompt</label>
                                <input type="text" class="form-input" id="plNegative" placeholder="blurry, distorted">
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Directions</label>
                                    <select class="form-select" id="plDirections">
                                        <option value="1">1 (Front)</option>
                                        <option value="4">4 (Cardinal)</option>
                                        <option value="8" selected>8 (All)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Size</label>
                                    <select class="form-select" id="plSize">
                                        <option value="32">32x32</option>
                                        <option value="48" selected>48x48</option>
                                        <option value="64">64x64</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label class="form-label">Outline</label>
                                    <select class="form-select" id="plOutline">
                                        <option value="single_color_black_outline">Black</option>
                                        <option value="colored_outline">Colored</option>
                                        <option value="no_outline">None</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Shading</label>
                                    <select class="form-select" id="plShading">
                                        <option value="flat_shading">Flat</option>
                                        <option value="basic_shading" selected>Basic</option>
                                        <option value="detailed_shading">Detailed</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="pixellab-section">
                            <h4>Pose (Optional)</h4>
                            <p style="font-size: 10px; color: var(--stone-mid); margin-bottom: 8px;">Drag joints to set the idle pose</p>
                            <div class="skeleton-container">
                                <div class="skeleton-presets">
                                    <button class="skeleton-preset-btn active" data-pose="idle">Idle</button>
                                    <button class="skeleton-preset-btn" data-pose="walk1">Walk</button>
                                    <button class="skeleton-preset-btn" data-pose="attack">Attack</button>
                                    <button class="skeleton-preset-btn" data-pose="jump">Jump</button>
                                </div>
                                <div id="plSkeletonContainer"></div>
                            </div>
                            <div class="form-group" style="margin-top: 10px;">
                                <label class="form-label">Skeleton Guidance</label>
                                <input type="range" class="form-input" id="plGuidance" min="0" max="5" step="0.5" value="2">
                                <div style="display: flex; justify-content: space-between; font-size: 9px; color: var(--stone-mid);">
                                    <span>None</span>
                                    <span id="plGuidanceValue">2.0</span>
                                    <span>Strong</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="generation-progress" id="generationProgress">
                <div class="generation-spinner"></div>
                <div class="generation-status" id="generationStatus">Generating character sprites...</div>
                <div class="generation-substatus" id="generationSubstatus">This may take 30-60 seconds</div>
            </div>

            <div class="generation-preview" id="generationPreview">
                <div class="preview-header">Preview - Idle Animation</div>
                <div class="preview-canvas-wrapper">
                    <canvas id="previewCanvas" width="96" height="96"></canvas>
                </div>
                <div class="preview-info" id="previewInfo">2 frames at 24x24</div>
                <div class="preview-actions">
                    <button class="btn" id="rejectPreview">Try Again</button>
                    <button class="btn btn-ai" id="acceptPreview">&#10004; Accept & Generate All Poses</button>
                </div>
            </div>

            <div class="modal-footer" id="generateFooter">
                <button class="btn" id="cancelGenerate">Cancel</button>
                <button class="btn btn-ai" id="startGenerate">&#10024; Generate Preview</button>
                <button class="btn btn-ai" id="startPixelLabGen" style="display: none;">&#10024; Queue Generation</button>
            </div>
        </div>
    </div>

    <!-- Generation Queue Panel -->
    <div class="generation-queue-panel" id="generationQueuePanel"></div>

    <!-- View Queue Button -->
    <button class="view-queue-btn" id="viewQueueBtn">
        <span>&#128203;</span> Queue <span class="queue-count" id="queueCount">0</span>
    </button>

    <script src="../shared/help-drawer.js"></script>
    <script src="../shared/docs/incarnum-docs.js"></script>

    <!-- Supabase Client -->
    <script src="../shared/supabase-client.js"></script>
    <script src="../shared/project-gate.js"></script>

    <!-- PixelLab AI Generation -->
    <script src="../shared/pixellab-client.js"></script>
    <script src="../shared/skeleton-editor.js"></script>
    <script src="../shared/generation-queue.js"></script>

    <script>
        // ==========================================
        // State
        // ==========================================
        const state = {
            projectId: null,
            characters: [],
            currentCharacterId: null,
            sprites: [],
            animations: [],
            masterSheetImage: null,
            spritesheetImages: {},  // Map of sheetId -> Image for multi-sheet support
            selectedSprite: null,
            customAnimationSlots: [],
            tags: [],
            properties: {},
            isDirty: false,
            saveTimeout: null,
            user: null,
            // Generation preview state
            previewResult: null,
            previewRequest: null,
            previewAnimationFrame: null,

            // PixelLab integration
            selectedEngine: 'claude',
            skeletonEditor: null,
            generationQueue: null
        };

        // Animation presets by perspective
        const ANIMATION_PRESETS = {
            side_view: {
                essential: [
                    { key: 'idle', label: 'Idle' },
                    { key: 'walk', label: 'Walk' },
                    { key: 'run', label: 'Run' },
                    { key: 'jump', label: 'Jump' }
                ],
                advanced: [
                    { key: 'duck', label: 'Duck' },
                    { key: 'attack', label: 'Attack' },
                    { key: 'hurt', label: 'Hurt' },
                    { key: 'death', label: 'Death' }
                ]
            },
            top_down: {
                essential: [
                    { key: 'idle_down', label: 'Idle ↓' },
                    { key: 'idle_up', label: 'Idle ↑' },
                    { key: 'idle_side', label: 'Idle →' },
                    { key: 'walk_down', label: 'Walk ↓' },
                    { key: 'walk_up', label: 'Walk ↑' },
                    { key: 'walk_side', label: 'Walk →' },
                    { key: 'run_down', label: 'Run ↓' },
                    { key: 'run_up', label: 'Run ↑' },
                    { key: 'run_side', label: 'Run →' }
                ],
                advanced: [
                    { key: 'attack_down', label: 'Attack ↓' },
                    { key: 'attack_up', label: 'Attack ↑' },
                    { key: 'attack_side', label: 'Attack →' },
                    { key: 'hurt', label: 'Hurt' },
                    { key: 'death', label: 'Death' }
                ]
            }
        };

        // Get all predefined slot keys for a perspective
        function getPredefinedSlots(perspective = 'side_view') {
            const preset = ANIMATION_PRESETS[perspective] || ANIMATION_PRESETS.side_view;
            return [...preset.essential, ...preset.advanced].map(s => s.key);
        }

        // ==========================================
        // DOM Elements
        // ==========================================
        const elements = {
            projectSelect: document.getElementById('projectSelect'),
            saveIndicator: document.getElementById('saveIndicator'),
            authIndicator: document.getElementById('authIndicator'),
            previewEmpty: document.getElementById('previewEmpty'),
            previewWrapper: document.getElementById('previewWrapper'),
            previewCanvas: document.getElementById('previewCanvas'),
            previewLabel: document.getElementById('previewLabel'),
            characterLibrary: document.getElementById('characterLibrary'),
            newCharacterBtn: document.getElementById('newCharacterBtn'),
            generateCharacterBtn: document.getElementById('generateCharacterBtn'),
            generateModal: document.getElementById('generateModal'),
            closeGenerateModal: document.getElementById('closeGenerateModal'),
            cancelGenerate: document.getElementById('cancelGenerate'),
            startGenerate: document.getElementById('startGenerate'),
            generateForm: document.getElementById('generateForm'),
            generateFooter: document.getElementById('generateFooter'),
            generationProgress: document.getElementById('generationProgress'),
            generationStatus: document.getElementById('generationStatus'),
            generationSubstatus: document.getElementById('generationSubstatus'),
            generationPreview: document.getElementById('generationPreview'),
            previewCanvas: document.getElementById('previewCanvas'),
            previewInfo: document.getElementById('previewInfo'),
            rejectPreview: document.getElementById('rejectPreview'),
            acceptPreview: document.getElementById('acceptPreview'),
            genPrompt: document.getElementById('genPrompt'),
            genSize: document.getElementById('genSize'),
            genStyle: document.getElementById('genStyle'),
            genPerspective: document.getElementById('genPerspective'),
            genPalette: document.getElementById('genPalette'),
            genCharType: document.getElementById('genCharType'),
            characterName: document.getElementById('characterName'),
            characterIdentifier: document.getElementById('characterIdentifier'),
            characterType: document.getElementById('characterType'),
            characterPerspective: document.getElementById('characterPerspective'),
            spriteGrid: document.getElementById('spriteGrid'),
            animationSlots: document.getElementById('animationSlots'),
            customSlots: document.getElementById('customSlots'),
            addAnimationBtn: document.getElementById('addAnimationBtn'),
            tagsContainer: document.getElementById('tagsContainer'),
            tagInput: document.getElementById('tagInput'),
            addTagBtn: document.getElementById('addTagBtn'),
            propertiesBody: document.getElementById('propertiesBody'),
            addPropertyBtn: document.getElementById('addPropertyBtn'),
            saveCharacterBtn: document.getElementById('saveCharacterBtn'),
            deleteCharacterBtn: document.getElementById('deleteCharacterBtn'),
            toast: document.getElementById('toast'),

            // Engine selector
            engineClaude: document.getElementById('engineClaude'),
            enginePixelLab: document.getElementById('enginePixelLab'),
            claudeForm: document.getElementById('claudeForm'),
            pixellabForm: document.getElementById('pixellabForm'),
            startPixelLabGen: document.getElementById('startPixelLabGen'),

            // PixelLab form elements
            plPrompt: document.getElementById('plPrompt'),
            plNegative: document.getElementById('plNegative'),
            plDirections: document.getElementById('plDirections'),
            plSize: document.getElementById('plSize'),
            plOutline: document.getElementById('plOutline'),
            plShading: document.getElementById('plShading'),
            plSkeletonContainer: document.getElementById('plSkeletonContainer'),
            plGuidance: document.getElementById('plGuidance'),
            plGuidanceValue: document.getElementById('plGuidanceValue'),

            // Generation queue
            generationQueuePanel: document.getElementById('generationQueuePanel'),
            viewQueueBtn: document.getElementById('viewQueueBtn'),
            queueCount: document.getElementById('queueCount')
        };

        // ==========================================
        // Utilities
        // ==========================================
        function showToast(message, type = '') {
            elements.toast.textContent = message;
            elements.toast.className = 'toast show ' + type;
            setTimeout(() => elements.toast.classList.remove('show'), 3000);
        }

        function generateIdentifier(name) {
            return name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
        }

        // ==========================================
        // Initialization
        // ==========================================
        async function init() {
            // Check if user has projects (displays gate if not)
            const hasProject = await checkProjectGate();
            if (!hasProject) return;

            try {
                // Render initial animation slots (disabled)
                renderAnimationSlots('side_view', {});

                const crucible = await getCrucible();
                state.user = await crucible.getUser();
                updateAuthIndicator();
                await loadProjects();
                setupEventListeners();

                // Initialize PixelLab components
                initPixelLab();
            } catch (err) {
                console.error('Failed to initialize:', err);
                showToast('Failed to initialize', 'error');
            }
        }

        // ==========================================
        // PixelLab Integration
        // ==========================================
        function initPixelLab() {
            // Initialize skeleton editor
            if (typeof SkeletonEditor !== 'undefined' && elements.plSkeletonContainer) {
                state.skeletonEditor = new SkeletonEditor(elements.plSkeletonContainer, {
                    width: 220,
                    height: 220,
                    showControls: false
                });
            }

            // Initialize generation queue
            if (typeof GenerationQueue !== 'undefined' && elements.generationQueuePanel) {
                state.generationQueue = new GenerationQueue(elements.generationQueuePanel, {
                    onImport: handlePixelLabImport,
                    onError: (error) => showToast(error, 'error'),
                    onJobsChange: updateQueueCount
                });
            }

            // Setup engine toggle
            setupEngineToggle();

            // Setup skeleton presets
            document.querySelectorAll('.skeleton-preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.skeleton-preset-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    if (state.skeletonEditor) {
                        state.skeletonEditor.loadPreset(btn.dataset.pose);
                    }
                });
            });

            // Guidance slider
            if (elements.plGuidance) {
                elements.plGuidance.addEventListener('input', () => {
                    elements.plGuidanceValue.textContent = parseFloat(elements.plGuidance.value).toFixed(1);
                });
            }

            // View queue button
            if (elements.viewQueueBtn) {
                elements.viewQueueBtn.addEventListener('click', () => {
                    if (state.generationQueue) {
                        state.generationQueue.toggle();
                    }
                });
            }

            // PixelLab generate button
            if (elements.startPixelLabGen) {
                elements.startPixelLabGen.addEventListener('click', startPixelLabGeneration);
            }
        }

        function setupEngineToggle() {
            const claudeOption = elements.engineClaude;
            const pixelLabOption = elements.enginePixelLab;

            if (!claudeOption || !pixelLabOption) return;

            claudeOption.addEventListener('click', () => {
                state.selectedEngine = 'claude';
                claudeOption.classList.add('active');
                pixelLabOption.classList.remove('active');
                elements.claudeForm.classList.add('active');
                elements.pixellabForm.classList.remove('active');
                elements.startGenerate.style.display = '';
                elements.startPixelLabGen.style.display = 'none';
            });

            pixelLabOption.addEventListener('click', () => {
                state.selectedEngine = 'pixellab';
                pixelLabOption.classList.add('active');
                claudeOption.classList.remove('active');
                elements.pixellabForm.classList.add('active');
                elements.claudeForm.classList.remove('active');
                elements.startGenerate.style.display = 'none';
                elements.startPixelLabGen.style.display = '';
            });
        }

        function updateQueueCount(jobs) {
            const pending = jobs.filter(j => j.status === 'pending' || j.status === 'processing').length;
            if (elements.queueCount) {
                elements.queueCount.textContent = pending;
            }
            if (elements.viewQueueBtn) {
                elements.viewQueueBtn.classList.toggle('has-jobs', pending > 0);
            }
        }

        async function startPixelLabGeneration() {
            const prompt = elements.plPrompt.value.trim();
            if (!prompt) {
                showToast('Enter a character description', 'error');
                elements.plPrompt.focus();
                return;
            }

            if (!state.projectId) {
                showToast('Select a project first', 'error');
                return;
            }

            if (typeof PixelLabClient === 'undefined') {
                showToast('PixelLab client not available', 'error');
                return;
            }

            const options = {
                directions: parseInt(elements.plDirections.value),
                size: parseInt(elements.plSize.value),
                outline: elements.plOutline.value,
                shading: elements.plShading.value,
                negative_prompt: elements.plNegative.value.trim() || undefined
            };

            // Add skeleton if guidance > 0
            const guidance = parseFloat(elements.plGuidance.value);
            if (guidance > 0 && state.skeletonEditor) {
                options.skeleton = state.skeletonEditor.getKeypoints();
                options.skeleton_guidance = guidance;
            }

            closeGenerateModal();
            showToast('Queuing character generation...', '');

            try {
                const client = new PixelLabClient();
                const result = await client.createCharacter(prompt, options);

                if (result.job_id) {
                    if (state.generationQueue) {
                        await state.generationQueue.addJob({
                            pixellab_job_id: result.job_id,
                            job_type: 'character',
                            prompt: prompt,
                            parameters: options,
                            skeleton_keypoints: options.skeleton,
                            project_id: state.projectId,
                            user_id: state.user?.id
                        });
                        state.generationQueue.show();
                    }
                    showToast('Character generation queued!', '');
                }
            } catch (error) {
                console.error('PixelLab generation error:', error);
                showToast('Generation failed: ' + error.message, 'error');
            }
        }

        async function handlePixelLabImport(job) {
            if (!job.result_url) {
                showToast('No result URL available', 'error');
                return;
            }

            showToast('Generated character ready! Open Sprite-Rite to import.', '');

            // Could redirect to Sprite-Rite with the job info
            // For now, show a link
            const spriteRiteUrl = `/game-wizard/sprite-rite/?project=${state.projectId}`;
            console.log('Import in Sprite-Rite:', spriteRiteUrl, job);
        }

        function updateAuthIndicator() {
            if (state.user) {
                const name = state.user.user_metadata?.display_name || state.user.email?.split('@')[0] || 'User';
                elements.authIndicator.classList.add('logged-in');
                elements.authIndicator.querySelector('.auth-text').textContent = name;
            } else {
                elements.authIndicator.classList.remove('logged-in');
                elements.authIndicator.querySelector('.auth-text').textContent = 'Guest';
            }
        }

        async function loadProjects() {
            try {
                const crucible = await getCrucible();
                const projects = await crucible.getProjects();

                elements.projectSelect.innerHTML = '<option value="">-- Select Project --</option>';
                projects.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = p.name;
                    elements.projectSelect.appendChild(opt);
                });

                // Restore last project
                const lastProject = localStorage.getItem('character_forge_project');
                if (lastProject && projects.find(p => p.id === lastProject)) {
                    elements.projectSelect.value = lastProject;
                    await selectProject(lastProject);
                }
            } catch (err) {
                console.error('Failed to load projects:', err);
            }
        }

        async function selectProject(projectId) {
            state.projectId = projectId;
            state.currentCharacterId = null;
            localStorage.setItem('character_forge_project', projectId || '');

            if (!projectId) {
                clearEditor();
                return;
            }

            elements.newCharacterBtn.disabled = false;
            elements.generateCharacterBtn.disabled = false;

            try {
                const crucible = await getCrucible();

                // Load characters
                state.characters = await crucible.getCharacters(projectId);
                renderCharacterLibrary();

                // Load spritesheets
                const spritesheets = await crucible.getSpritesheets(projectId);

                // Try master sheet first, then fall back to first spritesheet with sprites
                const project = await crucible.getProject(projectId);
                if (project.master_sheet_png && project.master_sheet_atlas) {
                    await loadMasterSheet(project.master_sheet_png, project.master_sheet_atlas);
                } else if (spritesheets.length > 0) {
                    // Fall back to loading sprites from spritesheets
                    await loadSpritesFromSheets(spritesheets);
                } else {
                    state.sprites = [];
                    state.masterSheetImage = null;
                    state.spritesheetImages = {};
                    renderSpriteGrid();
                }
                state.animations = [];
                for (const sheet of spritesheets) {
                    const anims = await crucible.getAnimations(sheet.id);
                    state.animations.push(...anims.map(a => ({ ...a, sheetName: sheet.name })));
                }
                populateAnimationDropdowns();

            } catch (err) {
                console.error('Failed to load project:', err);
                showToast('Failed to load project', 'error');
            }
        }

        async function loadMasterSheet(pngData, atlasData) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    state.masterSheetImage = img;
                    state.sprites = atlasData.sprites || [];
                    renderSpriteGrid();
                    resolve();
                };
                img.onerror = () => {
                    console.error('Failed to load master sheet image');
                    state.sprites = [];
                    renderSpriteGrid();
                    resolve();
                };
                img.src = pngData;
            });
        }

        async function loadSpritesFromSheets(spritesheets) {
            state.sprites = [];
            state.spritesheetImages = {};

            // Load each spritesheet and collect sprites
            const loadPromises = spritesheets.map(async (sheet) => {
                if (!sheet.file_path) return;

                const publicUrl = crucibleClient.client.storage
                    .from('spritesheets')
                    .getPublicUrl(sheet.file_path).data.publicUrl;

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        state.spritesheetImages[sheet.id] = img;

                        // Add sprites from this sheet
                        const sprites = sheet.sprites || [];
                        sprites.forEach(s => {
                            state.sprites.push({
                                ...s,
                                sheetId: sheet.id,
                                sheetName: sheet.name
                            });
                        });
                        resolve();
                    };
                    img.onerror = () => {
                        console.error('Failed to load spritesheet:', sheet.name);
                        resolve();
                    };
                    img.src = publicUrl;
                });
            });

            await Promise.all(loadPromises);

            // Use first sheet as "master" for rendering if available
            const firstSheetWithImage = spritesheets.find(s => state.spritesheetImages[s.id]);
            if (firstSheetWithImage) {
                state.masterSheetImage = state.spritesheetImages[firstSheetWithImage.id];
            }

            renderSpriteGrid();
        }

        function clearEditor() {
            state.currentCharacterId = null;
            state.selectedSprite = null;
            state.customAnimationSlots = [];
            state.tags = [];
            state.properties = {};

            elements.characterName.value = '';
            elements.characterName.disabled = true;
            elements.characterIdentifier.value = '';
            elements.characterIdentifier.disabled = true;
            elements.characterType.value = 'npc';
            elements.characterType.disabled = true;
            elements.characterPerspective.value = 'side_view';
            elements.characterPerspective.disabled = true;
            elements.newCharacterBtn.disabled = !state.projectId;
            elements.generateCharacterBtn.disabled = !state.projectId;
            elements.saveCharacterBtn.disabled = true;
            elements.deleteCharacterBtn.disabled = true;
            elements.addAnimationBtn.disabled = true;
            elements.tagInput.disabled = true;
            elements.addTagBtn.disabled = true;
            elements.addPropertyBtn.disabled = true;

            // Render empty animation slots
            renderAnimationSlots('side_view', {});

            elements.customSlots.innerHTML = '';
            elements.tagsContainer.innerHTML = '';
            elements.propertiesBody.innerHTML = '';

            // Clear preview
            elements.previewEmpty.style.display = 'block';
            elements.previewWrapper.style.display = 'none';
            elements.previewLabel.textContent = '';

            // Clear sprite selection
            document.querySelectorAll('.sprite-tile.selected').forEach(el => el.classList.remove('selected'));

            // Clear character library selection
            document.querySelectorAll('.character-tile.active').forEach(el => el.classList.remove('active'));

            renderCharacterLibrary();
        }

        // ==========================================
        // Rendering
        // ==========================================

        function renderAnimationSlots(perspective = 'side_view', animations = {}) {
            const preset = ANIMATION_PRESETS[perspective] || ANIMATION_PRESETS.side_view;
            const disabled = !state.currentCharacterId ? 'disabled' : '';

            // Build options from loaded animations
            let options = '<option value="">-- None --</option>';
            state.animations.forEach(anim => {
                options += `<option value="${anim.id}">${anim.name}</option>`;
            });

            // Build HTML for each category
            let html = '';

            // Essential category
            html += `<div class="animation-category">
                <div class="animation-category-header essential">Essential</div>`;
            preset.essential.forEach(slot => {
                const value = animations[slot.key] || '';
                html += `
                    <div class="animation-slot">
                        <span class="animation-slot-label">${slot.label}</span>
                        <select class="animation-slot-select" data-slot="${slot.key}" ${disabled}>
                            ${options.replace(`value="${value}"`, `value="${value}" selected`)}
                        </select>
                    </div>`;
            });
            html += '</div>';

            // Advanced category
            html += `<div class="animation-category">
                <div class="animation-category-header advanced">Advanced</div>`;
            preset.advanced.forEach(slot => {
                const value = animations[slot.key] || '';
                html += `
                    <div class="animation-slot">
                        <span class="animation-slot-label">${slot.label}</span>
                        <select class="animation-slot-select" data-slot="${slot.key}" ${disabled}>
                            ${options.replace(`value="${value}"`, `value="${value}" selected`)}
                        </select>
                    </div>`;
            });
            html += '</div>';

            elements.animationSlots.innerHTML = html;

            // Re-attach change listeners
            elements.animationSlots.querySelectorAll('.animation-slot-select').forEach(sel => {
                sel.addEventListener('change', markDirty);
            });
        }

        function renderCharacterLibrary() {
            if (!state.projectId || state.characters.length === 0) {
                elements.characterLibrary.innerHTML = '<div class="library-empty">No characters yet</div>';
                return;
            }

            elements.characterLibrary.innerHTML = state.characters.map(char => {
                const isActive = char.id === state.currentCharacterId;
                return `
                    <div class="character-tile ${isActive ? 'active' : ''}" data-id="${char.id}" title="${char.name}">
                        ${char.default_sprite ? '' : '&#129497;'}
                        <button class="character-tile-delete" data-id="${char.id}">&times;</button>
                    </div>
                `;
            }).join('');

            // Render sprite thumbnails
            state.characters.forEach(char => {
                if (char.default_sprite && state.masterSheetImage) {
                    const tile = elements.characterLibrary.querySelector(`[data-id="${char.id}"]`);
                    if (tile) {
                        const canvas = document.createElement('canvas');
                        const sprite = char.default_sprite;
                        const scale = Math.min(40 / sprite.width, 40 / sprite.height);
                        canvas.width = Math.floor(sprite.width * scale);
                        canvas.height = Math.floor(sprite.height * scale);
                        const ctx = canvas.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(
                            state.masterSheetImage,
                            sprite.x, sprite.y, sprite.width, sprite.height,
                            0, 0, canvas.width, canvas.height
                        );
                        tile.innerHTML = '';
                        tile.appendChild(canvas);

                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'character-tile-delete';
                        deleteBtn.dataset.id = char.id;
                        deleteBtn.innerHTML = '&times;';
                        tile.appendChild(deleteBtn);
                    }
                }
            });

            // Event listeners
            elements.characterLibrary.querySelectorAll('.character-tile').forEach(tile => {
                tile.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('character-tile-delete')) {
                        loadCharacter(tile.dataset.id);
                    }
                });
            });

            elements.characterLibrary.querySelectorAll('.character-tile-delete').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await deleteCharacter(btn.dataset.id);
                });
            });
        }

        function renderSpriteGrid() {
            if (state.sprites.length === 0) {
                elements.spriteGrid.innerHTML = '<div class="sprite-empty">No sprites defined. Use Sprite Rite to define sprites on your spritesheet.</div>';
                return;
            }

            elements.spriteGrid.innerHTML = state.sprites.map((sprite, index) => {
                const isSelected = state.selectedSprite &&
                    state.selectedSprite.name === sprite.name;
                return `<div class="sprite-tile ${isSelected ? 'selected' : ''}" data-index="${index}" title="${sprite.name}"></div>`;
            }).join('');

            // Render sprite thumbnails
            state.sprites.forEach((sprite, index) => {
                const tile = elements.spriteGrid.querySelector(`[data-index="${index}"]`);
                if (!tile) return;

                // Get the correct image source (sheet-specific or master)
                const img = sprite.sheetId && state.spritesheetImages
                    ? state.spritesheetImages[sprite.sheetId]
                    : state.masterSheetImage;

                if (img) {
                    const canvas = document.createElement('canvas');
                    const scale = Math.min(40 / sprite.width, 40 / sprite.height);
                    canvas.width = Math.floor(sprite.width * scale);
                    canvas.height = Math.floor(sprite.height * scale);
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        img,
                        sprite.x, sprite.y, sprite.width, sprite.height,
                        0, 0, canvas.width, canvas.height
                    );
                    tile.appendChild(canvas);
                }
            });

            // Event listeners
            elements.spriteGrid.querySelectorAll('.sprite-tile').forEach(tile => {
                tile.addEventListener('click', () => selectSprite(parseInt(tile.dataset.index)));
            });
        }

        function selectSprite(index) {
            if (!state.currentCharacterId) return;

            const sprite = state.sprites[index];
            state.selectedSprite = sprite;

            // Update UI
            document.querySelectorAll('.sprite-tile').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });

            // Update preview
            renderPreview();
            markDirty();
        }

        function renderPreview() {
            const sprite = state.selectedSprite;

            // Get the correct image source
            const img = sprite && sprite.sheetId && state.spritesheetImages
                ? state.spritesheetImages[sprite.sheetId]
                : state.masterSheetImage;

            if (!sprite || !img) {
                elements.previewEmpty.style.display = 'block';
                elements.previewWrapper.style.display = 'none';
                elements.previewLabel.textContent = '';
                return;
            }

            elements.previewEmpty.style.display = 'none';
            elements.previewWrapper.style.display = 'block';

            const canvas = elements.previewCanvas;
            const scale = Math.min(128 / sprite.width, 128 / sprite.height, 4);
            canvas.width = Math.floor(sprite.width * scale);
            canvas.height = Math.floor(sprite.height * scale);

            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(
                img,
                sprite.x, sprite.y, sprite.width, sprite.height,
                0, 0, canvas.width, canvas.height
            );

            elements.previewLabel.textContent = elements.characterName.value || 'Unnamed';
        }

        function populateAnimationDropdowns() {
            const options = '<option value="">-- None --</option>' +
                state.animations.map(a => `<option value="${a.id}">${a.name}</option>`).join('');

            document.querySelectorAll('.animation-slot-select').forEach(sel => {
                sel.innerHTML = options;
            });
        }

        function renderTags() {
            elements.tagsContainer.innerHTML = state.tags.map(tag => `
                <span class="tag">
                    ${tag}
                    <button class="tag-remove" data-tag="${tag}">&times;</button>
                </span>
            `).join('');

            elements.tagsContainer.querySelectorAll('.tag-remove').forEach(btn => {
                btn.addEventListener('click', () => removeTag(btn.dataset.tag));
            });
        }

        function renderProperties() {
            const keys = Object.keys(state.properties);
            if (keys.length === 0) {
                elements.propertiesBody.innerHTML = '';
                return;
            }

            elements.propertiesBody.innerHTML = keys.map(key => {
                const value = state.properties[key];
                const type = typeof value;
                return `
                    <tr class="property-row" data-key="${key}">
                        <td><input type="text" class="prop-key" value="${key}" data-original="${key}"></td>
                        <td>
                            <select class="prop-type">
                                <option value="number" ${type === 'number' ? 'selected' : ''}>number</option>
                                <option value="string" ${type === 'string' ? 'selected' : ''}>string</option>
                                <option value="boolean" ${type === 'boolean' ? 'selected' : ''}>boolean</option>
                            </select>
                        </td>
                        <td>
                            ${type === 'boolean'
                                ? `<select class="prop-value"><option value="true" ${value ? 'selected' : ''}>true</option><option value="false" ${!value ? 'selected' : ''}>false</option></select>`
                                : `<input type="${type === 'number' ? 'number' : 'text'}" class="prop-value" value="${value}">`
                            }
                        </td>
                        <td><button class="property-remove" data-key="${key}">&times;</button></td>
                    </tr>
                `;
            }).join('');

            // Event listeners
            elements.propertiesBody.querySelectorAll('.property-row').forEach(row => {
                const keyInput = row.querySelector('.prop-key');
                const typeSelect = row.querySelector('.prop-type');
                const valueInput = row.querySelector('.prop-value');
                const removeBtn = row.querySelector('.property-remove');

                keyInput.addEventListener('change', () => {
                    const oldKey = keyInput.dataset.original;
                    const newKey = keyInput.value.trim();
                    if (newKey && newKey !== oldKey) {
                        state.properties[newKey] = state.properties[oldKey];
                        delete state.properties[oldKey];
                        keyInput.dataset.original = newKey;
                        markDirty();
                    }
                });

                typeSelect.addEventListener('change', () => {
                    const key = keyInput.value;
                    const newType = typeSelect.value;
                    let value = state.properties[key];

                    if (newType === 'number') value = parseFloat(value) || 0;
                    else if (newType === 'boolean') value = value === 'true' || value === true;
                    else value = String(value);

                    state.properties[key] = value;
                    renderProperties();
                    markDirty();
                });

                valueInput.addEventListener('change', () => {
                    const key = keyInput.value;
                    const type = typeSelect.value;
                    let value = valueInput.value;

                    if (type === 'number') value = parseFloat(value) || 0;
                    else if (type === 'boolean') value = value === 'true';

                    state.properties[key] = value;
                    markDirty();
                });

                removeBtn.addEventListener('click', () => {
                    delete state.properties[removeBtn.dataset.key];
                    renderProperties();
                    markDirty();
                });
            });
        }

        function renderCustomAnimationSlots() {
            elements.customSlots.innerHTML = state.customAnimationSlots.map((slot, index) => `
                <div class="custom-slot" data-index="${index}">
                    <input type="text" class="custom-slot-name" value="${slot.name}" placeholder="Slot name">
                    <select class="animation-slot-select" data-custom="${index}">
                        <option value="">-- None --</option>
                        ${state.animations.map(a => `<option value="${a.id}" ${a.id === slot.animationId ? 'selected' : ''}>${a.name}</option>`).join('')}
                    </select>
                    <button class="animation-slot-remove" data-index="${index}">&times;</button>
                </div>
            `).join('');

            elements.customSlots.querySelectorAll('.custom-slot').forEach(slot => {
                const index = parseInt(slot.dataset.index);
                const nameInput = slot.querySelector('.custom-slot-name');
                const select = slot.querySelector('.animation-slot-select');
                const removeBtn = slot.querySelector('.animation-slot-remove');

                nameInput.addEventListener('change', () => {
                    state.customAnimationSlots[index].name = nameInput.value;
                    markDirty();
                });

                select.addEventListener('change', () => {
                    state.customAnimationSlots[index].animationId = select.value || null;
                    markDirty();
                });

                removeBtn.addEventListener('click', () => {
                    state.customAnimationSlots.splice(index, 1);
                    renderCustomAnimationSlots();
                    markDirty();
                });
            });
        }

        // ==========================================
        // Character Operations
        // ==========================================
        async function createCharacter() {
            if (!state.projectId) return;

            const name = 'New Character ' + (state.characters.length + 1);

            try {
                const crucible = await getCrucible();
                const character = await crucible.createCharacter(state.projectId, name, 'npc');
                state.characters.push(character);
                renderCharacterLibrary();
                loadCharacter(character.id);
                showToast('Character created', 'success');
            } catch (err) {
                console.error('Failed to create character:', err);
                showToast('Failed to create character', 'error');
            }
        }

        async function loadCharacter(characterId) {
            const character = state.characters.find(c => c.id === characterId);
            if (!character) return;

            state.currentCharacterId = characterId;

            // Enable inputs
            elements.characterName.disabled = false;
            elements.characterIdentifier.disabled = false;
            elements.characterType.disabled = false;
            elements.characterPerspective.disabled = false;
            elements.saveCharacterBtn.disabled = false;
            elements.deleteCharacterBtn.disabled = false;
            elements.addAnimationBtn.disabled = false;
            elements.tagInput.disabled = false;
            elements.addTagBtn.disabled = false;
            elements.addPropertyBtn.disabled = false;

            // Load character data
            elements.characterName.value = character.name;
            elements.characterIdentifier.value = character.identifier || '';
            elements.characterType.value = character.character_type || 'npc';

            // Get perspective from properties or default to side_view
            const perspective = character.properties?.perspective || 'side_view';
            elements.characterPerspective.value = perspective;

            // Load sprite
            state.selectedSprite = character.default_sprite;
            renderSpriteGrid();
            renderPreview();

            // Load animations
            const animations = character.animations || {};

            // Render animation slots for this perspective
            renderAnimationSlots(perspective, animations);

            // Load custom animation slots (animations not in predefined slots for this perspective)
            const predefinedSlots = getPredefinedSlots(perspective);
            state.customAnimationSlots = [];
            Object.keys(animations).forEach(key => {
                if (!predefinedSlots.includes(key)) {
                    state.customAnimationSlots.push({
                        name: key,
                        animationId: animations[key]
                    });
                }
            });
            renderCustomAnimationSlots();

            // Load tags
            state.tags = character.tags || [];
            renderTags();

            // Load properties
            state.properties = character.properties || {};
            renderProperties();

            // Update library selection
            document.querySelectorAll('.character-tile').forEach(el => {
                el.classList.toggle('active', el.dataset.id === characterId);
            });

            state.isDirty = false;
            elements.saveIndicator.textContent = '';
        }

        async function saveCharacter() {
            if (!state.currentCharacterId) return;

            const name = elements.characterName.value.trim();
            if (!name) {
                showToast('Please enter a character name', 'error');
                return;
            }

            const perspective = elements.characterPerspective.value;
            const predefinedSlots = getPredefinedSlots(perspective);

            // Collect animations from current perspective's slots
            const animations = {};
            predefinedSlots.forEach(slot => {
                const select = document.querySelector(`[data-slot="${slot}"]`);
                if (select && select.value) {
                    animations[slot] = select.value;
                }
            });
            state.customAnimationSlots.forEach(slot => {
                if (slot.name && slot.animationId) {
                    animations[slot.name] = slot.animationId;
                }
            });

            // Include perspective in properties
            const properties = {
                ...state.properties,
                perspective
            };

            elements.saveIndicator.textContent = 'Saving...';
            elements.saveIndicator.className = 'save-indicator saving';

            try {
                const crucible = await getCrucible();
                await crucible.updateCharacter(state.currentCharacterId, {
                    name,
                    identifier: elements.characterIdentifier.value || generateIdentifier(name),
                    character_type: elements.characterType.value,
                    default_sprite: state.selectedSprite,
                    animations,
                    tags: state.tags,
                    properties
                });

                // Update local state
                state.properties = properties; // Update state with perspective included
                const index = state.characters.findIndex(c => c.id === state.currentCharacterId);
                if (index >= 0) {
                    state.characters[index] = {
                        ...state.characters[index],
                        name,
                        identifier: elements.characterIdentifier.value,
                        character_type: elements.characterType.value,
                        default_sprite: state.selectedSprite,
                        animations,
                        tags: state.tags,
                        properties
                    };
                }

                renderCharacterLibrary();
                elements.saveIndicator.textContent = 'Saved';
                elements.saveIndicator.className = 'save-indicator saved';
                state.isDirty = false;
                showToast('Character saved', 'success');
            } catch (err) {
                console.error('Failed to save character:', err);
                elements.saveIndicator.textContent = 'Error';
                showToast('Failed to save character', 'error');
            }
        }

        async function deleteCharacter(characterId) {
            if (!confirm('Delete this character?')) return;

            try {
                const crucible = await getCrucible();
                await crucible.deleteCharacter(characterId);
                state.characters = state.characters.filter(c => c.id !== characterId);

                if (state.currentCharacterId === characterId) {
                    clearEditor();
                }

                renderCharacterLibrary();
                showToast('Character deleted', 'success');
            } catch (err) {
                console.error('Failed to delete character:', err);
                showToast('Failed to delete character', 'error');
            }
        }

        // ==========================================
        // Tags & Properties
        // ==========================================
        function addTag() {
            const tag = elements.tagInput.value.trim().toLowerCase();
            if (!tag || state.tags.includes(tag)) {
                elements.tagInput.value = '';
                return;
            }

            state.tags.push(tag);
            elements.tagInput.value = '';
            renderTags();
            markDirty();
        }

        function removeTag(tag) {
            state.tags = state.tags.filter(t => t !== tag);
            renderTags();
            markDirty();
        }

        function addProperty() {
            const key = 'property_' + (Object.keys(state.properties).length + 1);
            state.properties[key] = 0;
            renderProperties();
            markDirty();
        }

        function addCustomAnimationSlot() {
            state.customAnimationSlots.push({
                name: 'custom_' + (state.customAnimationSlots.length + 1),
                animationId: null
            });
            renderCustomAnimationSlots();
            markDirty();
        }

        // ==========================================
        // Dirty State & Auto-save
        // ==========================================
        function markDirty() {
            state.isDirty = true;
            elements.saveIndicator.textContent = 'Modified';
            elements.saveIndicator.className = 'save-indicator';

            // Auto-save after 3 seconds
            if (state.saveTimeout) clearTimeout(state.saveTimeout);
            state.saveTimeout = setTimeout(() => {
                if (state.isDirty && state.currentCharacterId) {
                    saveCharacter();
                }
            }, 3000);
        }

        // ==========================================
        // AI Character Generation
        // ==========================================
        async function openGenerateModal() {
            elements.generateModal.classList.add('active');
            elements.generateForm.style.display = 'block';
            elements.generateFooter.style.display = 'flex';
            elements.generationProgress.classList.remove('active');

            // Load project settings for art style defaults
            if (state.projectId && typeof crucibleClient !== 'undefined') {
                try {
                    const settings = await crucibleClient.getProjectSettings(state.projectId);
                    const style = settings.artStyle || {};
                    const charDefaults = settings.characterDefaults || {};

                    // Map outline values (project uses short form, modal uses long form)
                    if (style.outline) {
                        const outlineMap = {
                            'no_outline': 'no_outline',
                            'single_color_black': 'single_color_black_outline',
                            'single_color_colored': 'colored_outline'
                        };
                        const plOutline = document.getElementById('plOutline');
                        if (plOutline) plOutline.value = outlineMap[style.outline] || style.outline;
                    }
                    // Map shading values
                    if (style.shading) {
                        const shadingMap = {
                            'flat': 'flat_shading',
                            'basic': 'basic_shading',
                            'detailed': 'detailed_shading'
                        };
                        const plShading = document.getElementById('plShading');
                        if (plShading) plShading.value = shadingMap[style.shading] || style.shading;
                    }
                    // Character size
                    if (charDefaults.size) {
                        const plSize = document.getElementById('plSize');
                        if (plSize) plSize.value = String(charDefaults.size);
                    }
                    // Directions
                    if (charDefaults.directions) {
                        const plDirections = document.getElementById('plDirections');
                        if (plDirections) plDirections.value = String(charDefaults.directions);
                    }

                    // Also update the classic form perspective based on game view
                    if (settings.gameView) {
                        const perspectiveMap = {
                            'side-scroll': 'side_view',
                            'top-down': 'top_down',
                            'isometric': 'top_down'
                        };
                        elements.genPerspective.value = perspectiveMap[settings.gameView] || 'side_view';
                    }
                } catch (err) {
                    console.warn('Could not load project settings:', err);
                }
            }

            elements.genPrompt.focus();
        }

        function closeGenerateModal() {
            stopPreviewAnimation();
            elements.generateModal.classList.remove('active');
            // Reset to initial state for next open
            elements.generateForm.style.display = 'block';
            elements.generateFooter.style.display = 'flex';
            elements.generationProgress.classList.remove('active');
            elements.generationPreview.classList.remove('active');
            state.previewResult = null;
            state.previewRequest = null;
        }

        function updateGenerationStatus(status, substatus = '') {
            elements.generationStatus.textContent = status;
            elements.generationSubstatus.textContent = substatus;
        }

        // Step 1: Generate preview (idle pose only)
        async function startGeneration() {
            if (!state.projectId) {
                showToast('Select a project first', 'error');
                return;
            }

            const prompt = elements.genPrompt.value.trim();
            if (!prompt) {
                showToast('Enter a character description', 'error');
                elements.genPrompt.focus();
                return;
            }

            // Show progress
            elements.generateForm.style.display = 'none';
            elements.generateFooter.style.display = 'none';
            elements.generationProgress.classList.add('active');
            updateGenerationStatus('Generating preview...', 'Creating idle pose (2 frames)');

            try {
                const crucible = await getCrucible();

                // Prepare request for IDLE ONLY
                const request = {
                    prompt: prompt,
                    width: parseInt(elements.genSize.value),
                    height: parseInt(elements.genSize.value),
                    artStyle: elements.genStyle.value,
                    perspective: elements.genPerspective.value,
                    paletteSize: parseInt(elements.genPalette.value),
                    characterType: elements.genCharType.value,
                    poses: ['idle'] // Only generate idle for preview
                };

                // Call AI generation
                const result = await crucible.generateCharacterSprites(request);

                if (!result || !result.poses || !result.palette || !result.poses.idle) {
                    throw new Error('Invalid response from AI');
                }

                // Store for later use
                state.previewResult = result;
                state.previewRequest = request;

                // Show preview
                elements.generationProgress.classList.remove('active');
                showPreview(result, request.width, request.height);

            } catch (err) {
                console.error('Preview generation failed:', err);
                showToast(err.message || 'Failed to generate preview', 'error');
                resetGenerateModal();
            }
        }

        function showPreview(result, width, height) {
            const canvas = elements.previewCanvas;
            const ctx = canvas.getContext('2d');
            const scale = 4; // Scale up for visibility

            // Set canvas size
            canvas.width = width * scale;
            canvas.height = height * scale;
            ctx.imageSmoothingEnabled = false;

            // Convert idle frames to image data
            const frames = result.poses.idle;
            const palette = result.palette;
            const frameImages = [];

            for (const framePixels of frames) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                const imageData = tempCtx.createImageData(width, height);

                for (let y = 0; y < height; y++) {
                    const row = framePixels[y];
                    if (!row) continue;
                    for (let x = 0; x < width; x++) {
                        const paletteIndex = row[x] || 0;
                        const color = palette[paletteIndex] || '#00000000';
                        const rgba = hexToRgba(color);
                        const idx = (y * width + x) * 4;
                        imageData.data[idx] = rgba.r;
                        imageData.data[idx + 1] = rgba.g;
                        imageData.data[idx + 2] = rgba.b;
                        imageData.data[idx + 3] = rgba.a;
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);
                frameImages.push(tempCanvas);
            }

            // Animate preview
            let frameIndex = 0;
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(frameImages[frameIndex], 0, 0, canvas.width, canvas.height);
                frameIndex = (frameIndex + 1) % frameImages.length;
                state.previewAnimationFrame = setTimeout(animate, 400);
            }
            animate();

            // Update info
            elements.previewInfo.textContent = `${frames.length} frames at ${width}x${height} • ${palette.length} colors`;

            // Show preview section
            elements.generationPreview.classList.add('active');
        }

        function stopPreviewAnimation() {
            if (state.previewAnimationFrame) {
                clearTimeout(state.previewAnimationFrame);
                state.previewAnimationFrame = null;
            }
        }

        function resetGenerateModal() {
            stopPreviewAnimation();
            elements.generateForm.style.display = 'block';
            elements.generateFooter.style.display = 'flex';
            elements.generationProgress.classList.remove('active');
            elements.generationPreview.classList.remove('active');
            state.previewResult = null;
            state.previewRequest = null;
        }

        // Step 2: Accept preview and generate remaining poses
        async function acceptPreview() {
            if (!state.previewResult || !state.previewRequest) return;

            stopPreviewAnimation();
            elements.generationPreview.classList.remove('active');
            elements.generationProgress.classList.add('active');
            updateGenerationStatus('Generating remaining poses...', 'walk, attack, hurt, death');

            try {
                const crucible = await getCrucible();
                const baseRequest = state.previewRequest;
                const previewResult = state.previewResult;

                // Generate remaining poses using the same palette
                const remainingRequest = {
                    ...baseRequest,
                    poses: ['walk', 'attack', 'hurt', 'death'],
                    existingPalette: previewResult.palette
                };

                updateGenerationStatus('Generating poses...', '12 more frames');
                const remainingResult = await crucible.generateCharacterSprites(remainingRequest);

                // Merge results
                const fullResult = {
                    characterName: previewResult.characterName,
                    description: previewResult.description,
                    palette: previewResult.palette,
                    poses: {
                        idle: previewResult.poses.idle,
                        ...remainingResult.poses
                    }
                };

                // Process sprites
                updateGenerationStatus('Processing sprites...', 'Publishing to master sheet');
                const sprites = await processGeneratedSprites(fullResult, baseRequest.width, baseRequest.height);

                // Create animations
                updateGenerationStatus('Creating animations...', 'Building sequences');
                const animations = await createAnimationsFromSprites(sprites, fullResult);

                // Create character
                updateGenerationStatus('Creating character...', 'Linking together');
                const characterName = fullResult.characterName || 'Generated Character';
                const character = await crucible.createCharacter(
                    state.projectId,
                    characterName,
                    baseRequest.characterType === 'humanoid' ? 'playable' : 'npc'
                );

                // Update character with animations and default sprite
                const defaultSprite = sprites.idle?.[0] || sprites[Object.keys(sprites)[0]]?.[0];
                const animationLinks = {};
                for (const [pose, anim] of Object.entries(animations)) {
                    if (anim) animationLinks[pose] = anim.id;
                }

                await crucible.updateCharacter(character.id, {
                    default_sprite: defaultSprite ? {
                        name: defaultSprite.name,
                        x: defaultSprite.x,
                        y: defaultSprite.y,
                        width: defaultSprite.width,
                        height: defaultSprite.height
                    } : null,
                    animations: animationLinks,
                    properties: {
                        generated: true,
                        prompt: baseRequest.prompt,
                        palette: fullResult.palette
                    }
                });

                // Reload data
                state.characters = await crucible.getCharacters(state.projectId);
                await loadMasterSheet(state.projectId);
                renderCharacterLibrary();
                loadCharacter(character.id);

                closeGenerateModal();
                showToast('Character generated successfully!', 'success');

            } catch (err) {
                console.error('Generation failed:', err);
                showToast(err.message || 'Failed to generate character', 'error');
                resetGenerateModal();
            }
        }

        function rejectPreview() {
            resetGenerateModal();
        }

        async function processGeneratedSprites(result, width, height) {
            const crucible = await getCrucible();
            const sprites = {};
            const palette = result.palette;

            for (const [poseName, frames] of Object.entries(result.poses)) {
                if (!frames || !Array.isArray(frames)) continue;

                sprites[poseName] = [];

                for (let i = 0; i < frames.length; i++) {
                    const framePixels = frames[i];
                    if (!framePixels || !Array.isArray(framePixels)) continue;

                    // Convert palette indices to ImageData
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.createImageData(width, height);

                    for (let y = 0; y < height && y < framePixels.length; y++) {
                        const row = framePixels[y];
                        if (!row) continue;

                        for (let x = 0; x < width && x < row.length; x++) {
                            const colorIndex = row[x];
                            const color = palette[colorIndex] || '#00000000';
                            const rgba = hexToRgba(color);

                            const pixelIndex = (y * width + x) * 4;
                            imageData.data[pixelIndex] = rgba.r;
                            imageData.data[pixelIndex + 1] = rgba.g;
                            imageData.data[pixelIndex + 2] = rgba.b;
                            imageData.data[pixelIndex + 3] = rgba.a;
                        }
                    }

                    ctx.putImageData(imageData, 0, 0);

                    // Publish to master sheet
                    const spriteName = `${result.characterName || 'char'}_${poseName}_${i}`;
                    const published = await crucible.publishToMasterSheet(
                        state.projectId,
                        spriteName,
                        imageData,
                        width,
                        height,
                        'incarnum'
                    );

                    // Get sprite position from atlas
                    const spriteInfo = published.atlas.sprites[spriteName];
                    sprites[poseName].push({
                        name: spriteName,
                        x: spriteInfo?.x || 0,
                        y: spriteInfo?.y || 0,
                        width: width,
                        height: height
                    });
                }
            }

            return sprites;
        }

        async function createAnimationsFromSprites(sprites, result) {
            const crucible = await getCrucible();
            const animations = {};

            // Get or create a spritesheet for this project's animations
            let spritesheet = await getProjectSpritesheet();

            for (const [poseName, poseSprites] of Object.entries(sprites)) {
                if (!poseSprites || poseSprites.length === 0) continue;

                // Build frames array
                const frames = poseSprites.map((sprite, index) => ({
                    spriteIndex: index,
                    spriteName: sprite.name,
                    duration: poseName === 'idle' ? 200 : 100, // Slower for idle
                    offsetX: 0,
                    offsetY: 0
                }));

                try {
                    const animName = `${result.characterName || 'char'}_${poseName}`;
                    const animation = await crucible.createAnimation(
                        spritesheet.id,
                        animName,
                        frames,
                        { fps: 10, loop: poseName !== 'death' }
                    );
                    animations[poseName] = animation;
                } catch (err) {
                    console.warn(`Failed to create animation for ${poseName}:`, err);
                }
            }

            return animations;
        }

        async function getProjectSpritesheet() {
            const crucible = await getCrucible();

            // Try to find existing spritesheet for this project
            const spritesheets = await crucible.getSpritesheets(state.projectId);
            if (spritesheets.length > 0) {
                return spritesheets[0];
            }

            // Create a new one
            return await crucible.createSpritesheet(state.projectId, 'Generated Characters');
        }

        function hexToRgba(hex) {
            // Handle transparent
            if (hex === '#00000000' || hex === 'transparent') {
                return { r: 0, g: 0, b: 0, a: 0 };
            }

            // Remove # if present
            hex = hex.replace('#', '');

            // Handle different formats
            if (hex.length === 8) {
                // #RRGGBBAA
                return {
                    r: parseInt(hex.substr(0, 2), 16),
                    g: parseInt(hex.substr(2, 2), 16),
                    b: parseInt(hex.substr(4, 2), 16),
                    a: parseInt(hex.substr(6, 2), 16)
                };
            } else if (hex.length === 6) {
                // #RRGGBB
                return {
                    r: parseInt(hex.substr(0, 2), 16),
                    g: parseInt(hex.substr(2, 2), 16),
                    b: parseInt(hex.substr(4, 2), 16),
                    a: 255
                };
            } else if (hex.length === 3) {
                // #RGB
                return {
                    r: parseInt(hex[0] + hex[0], 16),
                    g: parseInt(hex[1] + hex[1], 16),
                    b: parseInt(hex[2] + hex[2], 16),
                    a: 255
                };
            }

            return { r: 0, g: 0, b: 0, a: 255 };
        }

        // ==========================================
        // Event Listeners
        // ==========================================
        function setupEventListeners() {
            elements.projectSelect.addEventListener('change', (e) => {
                selectProject(e.target.value);
            });

            elements.newCharacterBtn.addEventListener('click', createCharacter);

            // AI Generation Modal
            elements.generateCharacterBtn.addEventListener('click', openGenerateModal);
            elements.closeGenerateModal.addEventListener('click', closeGenerateModal);
            elements.cancelGenerate.addEventListener('click', closeGenerateModal);
            elements.startGenerate.addEventListener('click', startGeneration);
            elements.acceptPreview.addEventListener('click', acceptPreview);
            elements.rejectPreview.addEventListener('click', rejectPreview);
            elements.generateModal.addEventListener('click', (e) => {
                if (e.target === elements.generateModal) closeGenerateModal();
            });

            elements.characterName.addEventListener('input', () => {
                if (!elements.characterIdentifier.value ||
                    elements.characterIdentifier.value === generateIdentifier(elements.characterName.dataset.lastValue || '')) {
                    elements.characterIdentifier.value = generateIdentifier(elements.characterName.value);
                }
                elements.characterName.dataset.lastValue = elements.characterName.value;
                renderPreview();
                markDirty();
            });

            elements.characterIdentifier.addEventListener('input', markDirty);
            elements.characterType.addEventListener('change', markDirty);

            elements.characterPerspective.addEventListener('change', () => {
                const perspective = elements.characterPerspective.value;
                const currentAnimations = {};
                // Preserve any currently selected animations
                document.querySelectorAll('.animation-slot-select[data-slot]').forEach(sel => {
                    if (sel.value) {
                        currentAnimations[sel.dataset.slot] = sel.value;
                    }
                });
                renderAnimationSlots(perspective, currentAnimations);
                markDirty();
            });

            // Animation slot listeners are added dynamically in renderAnimationSlots()

            elements.addAnimationBtn.addEventListener('click', addCustomAnimationSlot);

            elements.addTagBtn.addEventListener('click', addTag);
            elements.tagInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addTag();
            });

            elements.addPropertyBtn.addEventListener('click', addProperty);

            elements.saveCharacterBtn.addEventListener('click', saveCharacter);
            elements.deleteCharacterBtn.addEventListener('click', () => {
                if (state.currentCharacterId) {
                    deleteCharacter(state.currentCharacterId);
                }
            });
        }

        // ==========================================
        // Initialize
        // ==========================================
        init();

        // Initialize Help Drawer
        if (typeof HelpDrawer !== 'undefined' && typeof INCARNUM_DOCS !== 'undefined') {
            HelpDrawer.init({
                toolId: 'incarnum',
                toolName: 'Incarnum',
                toolIcon: '&#129497;',
                accentColor: '#ff6b9d',
                docs: INCARNUM_DOCS
            });
        }
    </script>
</body>
</html>
