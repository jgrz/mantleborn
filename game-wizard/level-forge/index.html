<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Forge | Mantleborn Dev Tools</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           MANTLEBORN LEVEL-FORGE - CSS
           ============================================ */

        :root {
            /* Backgrounds */
            --bg-deep: #0d0d14;
            --bg-mid: #1a1a2e;
            --bg-surface: #252542;

            /* Accents - ember warmth */
            --accent-ember: #e07020;
            --accent-ember-glow: #ff9040;
            --accent-magma: #c04020;

            /* Stone/neutral tones */
            --stone-dark: #3a3a5c;
            --stone-mid: #6a6a8e;
            --stone-light: #9a9abe;
            --stone-bright: #d0d0e8;

            /* Purple undertones */
            --mystic-deep: #2a1a3e;
            --mystic-glow: #8060c0;

            /* Tile states */
            --tile-undefined: transparent;
            --tile-undefined-hover: rgba(255, 255, 255, 0.05);
            --tile-open: #2a5a30;
            --tile-open-bright: #3a7a40;
            --tile-obstruction: #6a2a2a;
            --tile-obstruction-bright: #8a3a3a;
            --tile-spawn: #2a4a6a;
            --tile-spawn-bright: #3a6a9a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--stone-light);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .home-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            font-size: 18px;
            text-decoration: none;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .home-btn:hover {
            background: var(--stone-dark);
            border-color: var(--accent-ember);
        }

        .brand-icon {
            font-size: 20px;
            animation: flicker 2s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            70% { opacity: 1; }
            75% { opacity: 0.7; }
            80% { opacity: 1; }
        }

        .brand-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .brand-text span {
            color: var(--accent-ember);
            text-shadow: 0 0 10px rgba(224, 112, 32, 0.5);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Buttons */
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--stone-dark);
            border-color: var(--stone-mid);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--mystic-glow);
        }

        .btn-primary {
            background: var(--accent-ember);
            border-color: var(--accent-ember);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--accent-ember-glow);
            border-color: var(--accent-ember-glow);
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
        }

        .btn-danger {
            background: var(--accent-magma);
            border-color: var(--accent-magma);
            color: white;
        }

        .btn-danger:hover {
            background: #d04030;
            border-color: #d04030;
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 320px;
            height: calc(100vh - 53px);
        }

        /* Left Panel - Grid Editor */
        .editor-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 16px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-label {
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-right: 8px;
        }

        .tool-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            padding: 0;
            border-radius: 4px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.15s;
        }

        .tool-btn:hover {
            border-color: var(--stone-mid);
            background: var(--stone-dark);
        }

        .tool-btn.active {
            border-color: var(--accent-ember);
            background: var(--mystic-deep);
            color: var(--accent-ember);
        }

        .state-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            padding: 0;
            border-radius: 4px;
            border: 2px solid var(--stone-dark);
            cursor: pointer;
            transition: all 0.15s;
        }

        .state-btn.active {
            border-color: var(--accent-ember);
            box-shadow: 0 0 8px rgba(224, 112, 32, 0.5);
        }

        .state-btn[data-state="undefined"] {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 8px 8px;
        }

        .state-btn[data-state="open"] {
            background: var(--tile-open);
        }

        .state-btn[data-state="obstruction"] {
            background: var(--tile-obstruction);
        }

        .state-btn[data-state="spawn"] {
            background: var(--tile-spawn);
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--stone-dark);
        }

        /* Grid Container */
        .grid-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
            background: var(--bg-deep);
        }

        .grid-wrapper {
            position: relative;
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            padding: 2px;
        }

        .grid {
            display: grid;
            gap: 1px;
            background: var(--stone-dark);
        }

        .tile {
            width: 24px;
            height: 24px;
            background: var(--bg-mid);
            cursor: pointer;
            transition: background 0.1s;
            position: relative;
        }

        .tile:hover {
            background: var(--tile-undefined-hover);
        }

        .tile[data-state="open"] {
            background: var(--tile-open);
        }

        .tile[data-state="open"]:hover {
            background: var(--tile-open-bright);
        }

        .tile[data-state="obstruction"] {
            background: var(--tile-obstruction);
        }

        .tile[data-state="obstruction"]:hover {
            background: var(--tile-obstruction-bright);
        }

        .tile[data-state="spawn"] {
            background: var(--tile-spawn);
        }

        .tile[data-state="spawn"]:hover {
            background: var(--tile-spawn-bright);
        }

        .tile.selected {
            outline: 2px solid var(--accent-ember);
            outline-offset: -2px;
            z-index: 1;
        }

        .tile.preview {
            opacity: 0.7;
        }

        /* Selection box */
        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent-ember);
            background: rgba(224, 112, 32, 0.1);
            pointer-events: none;
            display: none;
        }

        /* Right Panel - Settings & Output */
        .right-panel {
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border-left: 1px solid var(--stone-dark);
            overflow: hidden;
            min-height: 0;
        }

        .section {
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .section-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--mystic-glow);
        }

        .form-row {
            display: flex;
            gap: 12px;
        }

        .form-row .form-group {
            flex: 1;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            padding: 8px;
            background: var(--bg-surface);
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--stone-bright);
        }

        .stat-label {
            font-size: 8px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-top: 4px;
        }

        .stat-item.open .stat-value {
            color: var(--tile-open-bright);
        }

        .stat-item.obstruction .stat-value {
            color: var(--tile-obstruction-bright);
        }

        /* Export Section */
        .export-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            min-height: 0;
            overflow: hidden;
        }

        .export-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .export-actions .btn {
            flex: 1;
        }

        .json-preview {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .json-preview-header {
            padding: 8px 12px;
            background: var(--bg-surface);
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .json-preview-content {
            flex: 1;
            overflow: auto;
            padding: 8px 12px;
            background: var(--bg-deep);
            font-size: 10px;
            line-height: 1.5;
            white-space: pre;
            min-height: 0;
        }

        .json-preview-content::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .json-preview-content::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 3px;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 16px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border-radius: 4px;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            border: 1px solid var(--stone-dark);
        }

        .legend-color.undefined {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 6px 6px;
        }

        .legend-color.open {
            background: var(--tile-open);
        }

        .legend-color.obstruction {
            background: var(--tile-obstruction);
        }

        .legend-color.spawn {
            background: var(--tile-spawn);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 20px;
            background: var(--bg-surface);
            border: 1px solid var(--accent-ember);
            border-radius: 4px;
            font-size: 12px;
            color: var(--stone-bright);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Keyboard hints */
        .keyboard-hints {
            font-size: 9px;
            color: var(--stone-dark);
            margin-top: 8px;
        }

        .keyboard-hints kbd {
            padding: 2px 5px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 3px;
            font-family: inherit;
        }

        /* Demo Mode */
        .demo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-deep);
            display: none;
            z-index: 100;
        }

        .demo-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .demo-canvas {
            image-rendering: pixelated;
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
        }

        .demo-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(13, 13, 20, 0.9);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 10px;
            color: var(--stone-light);
            z-index: 101;
        }

        .demo-hud-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--accent-ember);
            margin-bottom: 6px;
        }

        .demo-hud-controls {
            line-height: 1.6;
        }

        .demo-hud-controls kbd {
            padding: 1px 4px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 2px;
            font-family: inherit;
            font-size: 9px;
        }

        .demo-exit-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 101;
        }

        .btn-play {
            background: var(--tile-open);
            border-color: var(--tile-open);
            color: white;
        }

        .btn-play:hover {
            background: var(--tile-open-bright);
            border-color: var(--tile-open-bright);
        }

        /* ============================================
           TAB SYSTEM
           ============================================ */

        .tab-bar {
            display: flex;
            gap: 2px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .tab-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-mid);
            cursor: pointer;
            transition: all 0.15s;
        }

        .tab-btn:hover {
            background: var(--stone-dark);
            color: var(--stone-light);
        }

        .tab-btn.active {
            background: var(--mystic-deep);
            color: var(--accent-ember);
            border-color: var(--accent-ember);
        }

        .tab-icon {
            font-size: 14px;
        }

        .tab-label {
            font-weight: 500;
        }

        .tab-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            background: var(--bg-deep);
            position: relative;
        }

        .tab-panel {
            display: none;
            flex: 1;
            overflow: auto;
            padding: 20px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .tab-panel.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Grid editor toolbar - only show when grid tab active */
        .grid-toolbar {
            display: none;
        }

        .grid-toolbar.active {
            display: flex;
        }

        /* ============================================
           BACKGROUND EDITOR
           ============================================ */

        .background-editor {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            max-width: 100%;
            align-items: stretch;
        }

        .background-toolbar {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: var(--bg-mid);
            border-radius: 4px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .background-preview-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            overflow: hidden;
            min-height: 300px;
        }

        #backgroundCanvas {
            image-rendering: pixelated;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
        }

        .background-layers {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 12px;
            padding: 8px;
            background: var(--bg-mid);
            border-radius: 4px;
        }

        .bg-layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .bg-layer-item:hover {
            border-color: var(--stone-mid);
        }

        .bg-layer-item.selected {
            border-color: var(--accent-ember);
            background: var(--mystic-deep);
        }

        .bg-layer-thumb {
            width: 40px;
            height: 30px;
            background: var(--bg-deep);
            border-radius: 2px;
            overflow: hidden;
        }

        .bg-layer-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .bg-layer-info {
            flex: 1;
            min-width: 0;
        }

        .bg-layer-name {
            font-size: 11px;
            color: var(--stone-bright);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bg-layer-meta {
            font-size: 9px;
            color: var(--stone-mid);
        }

        .bg-layer-actions {
            display: flex;
            gap: 4px;
        }

        .bg-layer-visibility {
            padding: 4px 6px;
            background: transparent;
            border: none;
            color: var(--stone-mid);
            cursor: pointer;
            font-size: 12px;
        }

        .bg-layer-visibility.hidden {
            opacity: 0.4;
        }

        .bg-layer-delete {
            padding: 4px 6px;
            background: transparent;
            border: none;
            color: var(--accent-magma);
            cursor: pointer;
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .bg-layer-item:hover .bg-layer-delete {
            opacity: 1;
        }

        .no-layers-message {
            text-align: center;
            padding: 20px;
            color: var(--stone-mid);
            font-size: 11px;
        }

        /* ============================================
           TILE PAINTER
           ============================================ */

        .tile-painter {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .tile-toolbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px;
            background: var(--bg-mid);
            border-radius: 4px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .tile-painter-main {
            display: flex;
            flex: 1;
            gap: 16px;
            min-height: 0;
        }

        .tile-canvas-wrapper {
            flex: 1;
            position: relative;
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #tileCanvas {
            image-rendering: pixelated;
        }

        .sprite-palette {
            width: 200px;
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .palette-header {
            padding: 10px 12px;
            background: var(--bg-surface);
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .palette-sheet-select {
            padding: 8px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 4px;
            padding: 8px;
            overflow-y: auto;
            flex: 1;
        }

        .palette-sprite {
            aspect-ratio: 1;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 8px 8px;
            border: 2px solid var(--stone-dark);
            border-radius: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            overflow: hidden;
        }

        .palette-sprite:hover {
            border-color: var(--stone-mid);
        }

        .palette-sprite.selected {
            border-color: var(--accent-ember);
            box-shadow: 0 0 8px rgba(224, 112, 32, 0.5);
        }

        .palette-sprite img {
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 100%;
        }

        .no-sprites-message {
            padding: 20px;
            text-align: center;
            color: var(--stone-mid);
            font-size: 10px;
        }

        /* Contextual settings visibility */
        .tab-settings {
            display: none;
        }

        .tab-settings.active {
            display: block;
        }

        /* Selected sprite preview */
        .selected-sprite-preview {
            display: flex;
            justify-content: center;
            padding: 12px;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            margin-bottom: 12px;
            min-height: 80px;
        }

        .selected-sprite-preview img {
            image-rendering: pixelated;
            max-width: 64px;
            max-height: 64px;
        }

        /* File input styling */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* Range slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-deep);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-ember);
            border-radius: 50%;
            cursor: pointer;
        }

        .range-value {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .range-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .range-row input[type="range"] {
            flex: 1;
        }

        /* Checkbox styling */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-ember);
        }

        .checkbox-group label {
            font-size: 11px;
            color: var(--stone-light);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="brand">
            <a href="/game-wizard/" class="home-btn" title="Back to Game Wizard">&#127968;</a>
            <span class="brand-icon">&#128293;</span>
            <span class="brand-text">MANTLEBORN / <span>LEVEL-FORGE</span></span>
        </div>
        <div class="header-actions">
            <button class="btn btn-play" id="playDemoBtn">&#9658; Play Demo</button>
            <button class="btn" id="newLevelBtn">New Level</button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Editor Panel -->
        <div class="editor-panel">
            <!-- Grid Editor Toolbar -->
            <div class="toolbar grid-toolbar active" id="gridToolbar">
                <div class="toolbar-group">
                    <span class="toolbar-label">Tool</span>
                    <button class="tool-btn active" data-tool="paint" title="Paint (P)">&#9998;</button>
                    <button class="tool-btn" data-tool="fill" title="Fill (F)">&#9699;</button>
                    <button class="tool-btn" data-tool="select" title="Select (S)">&#9634;</button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <span class="toolbar-label">State</span>
                    <button class="state-btn" data-state="undefined" title="Undefined (1)">?</button>
                    <button class="state-btn active" data-state="open" title="Open (2)">&#10003;</button>
                    <button class="state-btn" data-state="obstruction" title="Obstruction (3)">&#10005;</button>
                    <button class="state-btn" data-state="spawn" title="Spawn Point (4)">&#9679;</button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <button class="btn btn-small btn-danger" id="clearGridBtn">Clear All</button>
                </div>
            </div>

            <!-- Tab Content -->
            <div class="tab-content">
                <!-- Grid Editor Panel -->
                <div class="tab-panel active" id="gridPanel">
                    <div class="grid-wrapper">
                        <div class="grid" id="grid"></div>
                        <div class="selection-box" id="selectionBox"></div>
                    </div>

                    <!-- Demo Mode Overlay -->
                    <div class="demo-overlay" id="demoOverlay">
                        <canvas class="demo-canvas" id="demoCanvas"></canvas>
                        <div class="demo-hud" id="demoHud">
                            <div class="demo-hud-title">DEMO MODE</div>
                            <div class="demo-hud-controls" id="demoControls"></div>
                        </div>
                        <button class="btn btn-danger demo-exit-btn" id="exitDemoBtn">Exit Demo</button>
                    </div>
                </div>

                <!-- Background Editor Panel -->
                <div class="tab-panel" id="backgroundPanel">
                    <div class="background-editor">
                        <div class="background-toolbar">
                            <div class="file-input-wrapper">
                                <button class="btn btn-small">+ Add Layer</button>
                                <input type="file" id="bgFileInput" accept="image/*">
                            </div>
                            <button class="btn btn-small" id="pixelifyBtn" disabled>Pixelify</button>
                        </div>
                        <div class="background-preview-wrapper">
                            <canvas id="backgroundCanvas"></canvas>
                        </div>
                        <div class="background-layers" id="backgroundLayers">
                            <div class="no-layers-message">No background layers. Click "+ Add Layer" to upload an image.<br><br>Recommended: 768x432px (32x18 tiles at 24px)</div>
                        </div>
                    </div>
                </div>

                <!-- Tile Painter Panel -->
                <div class="tab-panel" id="tilesPanel">
                    <div class="tile-painter">
                        <div class="tile-toolbar">
                            <div class="toolbar-group">
                                <span class="toolbar-label">Tool</span>
                                <button class="tool-btn active" data-tile-tool="paint" title="Paint (P)">&#9998;</button>
                                <button class="tool-btn" data-tile-tool="erase" title="Erase (E)">&#9003;</button>
                                <button class="tool-btn" data-tile-tool="fill" title="Fill (F)">&#9699;</button>
                            </div>
                            <div class="toolbar-divider"></div>
                            <div class="toolbar-group">
                                <button class="btn btn-small btn-danger" id="clearTilesBtn">Clear Tiles</button>
                            </div>
                        </div>
                        <div class="tile-painter-main">
                            <div class="tile-canvas-wrapper">
                                <canvas id="tileCanvas"></canvas>
                            </div>
                            <div class="sprite-palette">
                                <div class="palette-header">Sprite Palette</div>
                                <div class="palette-sheet-select">
                                    <select class="form-input" id="spriteSheetSelect">
                                        <option value="">-- Select Sheet --</option>
                                    </select>
                                </div>
                                <div class="palette-grid" id="paletteGrid">
                                    <div class="no-sprites-message">Select a sprite sheet to load sprites</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Tab Bar -->
            <div class="tab-bar">
                <button class="tab-btn active" data-tab="grid" title="Grid Editor">
                    <span class="tab-icon">&#9638;</span>
                    <span class="tab-label">Grid</span>
                </button>
                <button class="tab-btn" data-tab="background" title="Background Editor">
                    <span class="tab-icon">&#127748;</span>
                    <span class="tab-label">BG</span>
                </button>
                <button class="tab-btn" data-tab="tiles" title="Tile Painter">
                    <span class="tab-icon">&#127912;</span>
                    <span class="tab-label">Tiles</span>
                </button>
            </div>

            <!-- Grid Settings -->
            <div class="section">
                <div class="section-header">Grid Settings</div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Width (tiles)</label>
                        <input type="number" class="form-input" id="gridWidth" value="32" min="4" max="100">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Height (tiles)</label>
                        <input type="number" class="form-input" id="gridHeight" value="18" min="4" max="100">
                    </div>
                </div>
                <button class="btn btn-small" id="resizeGridBtn" style="width: 100%;">Resize Grid</button>
            </div>

            <!-- Level Info (Grid Tab) -->
            <div class="section tab-settings active" id="gridSettings">
                <div class="section-header">Level Info</div>
                <div class="form-group">
                    <label class="form-label">Level Name</label>
                    <input type="text" class="form-input" id="levelName" placeholder="level_01">
                </div>

                <div class="form-group">
                    <label class="form-label">Level Type</label>
                    <select class="form-input" id="levelType">
                        <option value="platformer">Platformer (side-scroll, gravity)</option>
                        <option value="topdown">Top-Down (free movement, no gravity)</option>
                    </select>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color undefined"></div>
                        <span>Undefined</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color open"></div>
                        <span>Open</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color obstruction"></div>
                        <span>Obstruction</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color spawn"></div>
                        <span>Spawn</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalTiles">576</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="undefinedTiles">576</div>
                        <div class="stat-label">Undefined</div>
                    </div>
                    <div class="stat-item open">
                        <div class="stat-value" id="openTiles">0</div>
                        <div class="stat-label">Open</div>
                    </div>
                    <div class="stat-item obstruction">
                        <div class="stat-value" id="obstructionTiles">0</div>
                        <div class="stat-label">Obstruction</div>
                    </div>
                </div>

                <div class="keyboard-hints">
                    <kbd>P</kbd> Paint &nbsp;
                    <kbd>F</kbd> Fill &nbsp;
                    <kbd>S</kbd> Select<br>
                    <kbd>1</kbd> Undefined &nbsp;
                    <kbd>2</kbd> Open &nbsp;
                    <kbd>3</kbd> Obstruction &nbsp;
                    <kbd>4</kbd> Spawn
                </div>
            </div>

            <!-- Background Settings -->
            <div class="section tab-settings" id="bgSettings">
                <div class="section-header">Layer Settings</div>
                <div id="bgLayerSettings">
                    <div class="no-layers-message">Select a layer to edit its settings</div>
                </div>
                <div id="bgLayerControls" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Layer Name</label>
                        <input type="text" class="form-input" id="bgLayerName" placeholder="background_01">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Depth</label>
                            <input type="number" class="form-input" id="bgDepth" value="0" min="-100" max="100">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Scroll Rate</label>
                            <input type="number" class="form-input" id="bgScrollRate" value="1" min="0" max="2" step="0.1">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">X Offset</label>
                            <input type="number" class="form-input" id="bgOffsetX" value="0">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Y Offset</label>
                            <input type="number" class="form-input" id="bgOffsetY" value="0">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Scale</label>
                        <div class="range-row">
                            <input type="range" id="bgScale" value="1" min="0.25" max="4" step="0.25">
                            <span class="range-value" id="bgScaleValue">1x</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pixelify Settings -->
            <div class="section tab-settings" id="pixelifySettings">
                <div class="section-header">Pixelify Effect</div>
                <div class="form-group">
                    <label class="form-label">Pixel Size</label>
                    <div class="range-row">
                        <input type="range" id="pixelSize" value="4" min="1" max="16">
                        <span class="range-value" id="pixelSizeValue">4px</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Color Depth</label>
                    <div class="range-row">
                        <input type="range" id="colorDepth" value="8" min="2" max="32">
                        <span class="range-value" id="colorDepthValue">8</span>
                    </div>
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableDithering">
                        <label for="enableDithering">Enable Dithering</label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Dither Pattern</label>
                    <select class="form-input" id="ditherPattern">
                        <option value="ordered">Ordered (Bayer)</option>
                        <option value="floyd-steinberg">Floyd-Steinberg</option>
                    </select>
                </div>
                <button class="btn btn-primary" id="applyPixelify" style="width: 100%;">Apply Effect</button>
                <button class="btn btn-small" id="resetPixelify" style="width: 100%; margin-top: 8px;">Reset to Original</button>
            </div>

            <!-- Tile Painter Settings -->
            <div class="section tab-settings" id="tileSettings">
                <div class="section-header">Selected Sprite</div>
                <div class="selected-sprite-preview" id="selectedSpritePreview">
                    <span class="no-sprites-message">No sprite selected</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Sprite Name</label>
                    <input type="text" class="form-input" id="selectedSpriteName" readonly value="None">
                </div>
                <div class="keyboard-hints">
                    <kbd>P</kbd> Paint &nbsp;
                    <kbd>E</kbd> Erase &nbsp;
                    <kbd>F</kbd> Fill
                </div>
            </div>

            <!-- Export -->
            <div class="export-section">
                <div class="export-actions">
                    <button class="btn btn-primary" id="copyJsonBtn">Copy JSON</button>
                    <button class="btn" id="loadJsonBtn">Load JSON</button>
                </div>
                <div class="json-preview">
                    <div class="json-preview-header">JSON Output</div>
                    <div class="json-preview-content" id="jsonOutput">{}</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        /* ============================================
           MANTLEBORN LEVEL-FORGE - JavaScript
           ============================================ */

        // ==========================================
        // State
        // ==========================================
        const state = {
            // Grid settings
            gridWidth: 32,
            gridHeight: 18,
            levelType: 'platformer',  // 'platformer' | 'topdown'
            tiles: [],  // 2D array of tile states: 'undefined' | 'open' | 'obstruction' | 'spawn'

            // Grid editor state
            currentTool: 'paint',
            currentState: 'open',
            isMouseDown: false,
            selectionStart: null,
            selectionEnd: null,
            selectedTiles: new Set(),

            // Tab state
            activeTab: 'grid',  // 'grid' | 'background' | 'tiles'

            // Background editor state
            backgrounds: [],  // Array of background layer objects
            selectedBgLayer: -1,
            pixelifySettings: {
                pixelSize: 4,
                colorDepth: 8,
                dithering: false,
                ditherPattern: 'ordered'
            },

            // Tile painter state
            visualTiles: [],  // 2D array parallel to collision grid
            selectedSprite: null,
            currentTileTool: 'paint',  // 'paint' | 'erase' | 'fill'
            spriteSheets: {},  // Loaded sprite sheet data
            spriteImages: {},  // Loaded sprite sheet images
            selectedSpriteSheet: '',
            tileMouseDown: false
        };

        const TILE_STATES = ['undefined', 'open', 'obstruction', 'spawn'];

        // ==========================================
        // DOM Elements
        // ==========================================
        const elements = {
            // Grid editor
            grid: document.getElementById('grid'),
            selectionBox: document.getElementById('selectionBox'),
            gridWidth: document.getElementById('gridWidth'),
            gridHeight: document.getElementById('gridHeight'),
            resizeGridBtn: document.getElementById('resizeGridBtn'),
            levelName: document.getElementById('levelName'),
            levelType: document.getElementById('levelType'),
            totalTiles: document.getElementById('totalTiles'),
            undefinedTiles: document.getElementById('undefinedTiles'),
            openTiles: document.getElementById('openTiles'),
            obstructionTiles: document.getElementById('obstructionTiles'),
            copyJsonBtn: document.getElementById('copyJsonBtn'),
            loadJsonBtn: document.getElementById('loadJsonBtn'),
            clearGridBtn: document.getElementById('clearGridBtn'),
            newLevelBtn: document.getElementById('newLevelBtn'),
            jsonOutput: document.getElementById('jsonOutput'),
            toast: document.getElementById('toast'),
            gridToolbar: document.getElementById('gridToolbar'),

            // Demo mode
            playDemoBtn: document.getElementById('playDemoBtn'),
            demoOverlay: document.getElementById('demoOverlay'),
            demoCanvas: document.getElementById('demoCanvas'),
            demoControls: document.getElementById('demoControls'),
            exitDemoBtn: document.getElementById('exitDemoBtn'),

            // Tab panels
            gridPanel: document.getElementById('gridPanel'),
            backgroundPanel: document.getElementById('backgroundPanel'),
            tilesPanel: document.getElementById('tilesPanel'),

            // Background editor
            bgFileInput: document.getElementById('bgFileInput'),
            pixelifyBtn: document.getElementById('pixelifyBtn'),
            backgroundCanvas: document.getElementById('backgroundCanvas'),
            backgroundLayers: document.getElementById('backgroundLayers'),
            bgLayerControls: document.getElementById('bgLayerControls'),
            bgLayerName: document.getElementById('bgLayerName'),
            bgDepth: document.getElementById('bgDepth'),
            bgScrollRate: document.getElementById('bgScrollRate'),
            bgOffsetX: document.getElementById('bgOffsetX'),
            bgOffsetY: document.getElementById('bgOffsetY'),
            bgScale: document.getElementById('bgScale'),
            bgScaleValue: document.getElementById('bgScaleValue'),
            pixelSize: document.getElementById('pixelSize'),
            pixelSizeValue: document.getElementById('pixelSizeValue'),
            colorDepth: document.getElementById('colorDepth'),
            colorDepthValue: document.getElementById('colorDepthValue'),
            enableDithering: document.getElementById('enableDithering'),
            ditherPattern: document.getElementById('ditherPattern'),
            applyPixelify: document.getElementById('applyPixelify'),
            resetPixelify: document.getElementById('resetPixelify'),

            // Tile painter
            tileCanvas: document.getElementById('tileCanvas'),
            spriteSheetSelect: document.getElementById('spriteSheetSelect'),
            paletteGrid: document.getElementById('paletteGrid'),
            selectedSpritePreview: document.getElementById('selectedSpritePreview'),
            selectedSpriteName: document.getElementById('selectedSpriteName'),
            clearTilesBtn: document.getElementById('clearTilesBtn'),

            // Tab settings panels
            gridSettings: document.getElementById('gridSettings'),
            bgSettings: document.getElementById('bgSettings'),
            pixelifySettings: document.getElementById('pixelifySettings'),
            tileSettings: document.getElementById('tileSettings')
        };

        // ==========================================
        // Utilities
        // ==========================================
        function showToast(message) {
            elements.toast.textContent = message;
            elements.toast.classList.add('show');
            setTimeout(() => elements.toast.classList.remove('show'), 2500);
        }

        // ==========================================
        // Grid Management
        // ==========================================
        function initGrid() {
            state.tiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    row.push('undefined');
                }
                state.tiles.push(row);
            }
            // Also initialize visual tiles if not already done
            if (state.visualTiles.length === 0) {
                for (let y = 0; y < state.gridHeight; y++) {
                    const row = [];
                    for (let x = 0; x < state.gridWidth; x++) {
                        row.push(null);
                    }
                    state.visualTiles.push(row);
                }
            }
            renderGrid();
            updateStats();
            updateJsonOutput();
        }

        function renderGrid() {
            elements.grid.innerHTML = '';
            elements.grid.style.gridTemplateColumns = `repeat(${state.gridWidth}, 24px)`;
            elements.grid.style.gridTemplateRows = `repeat(${state.gridHeight}, 24px)`;

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.x = x;
                    tile.dataset.y = y;

                    const tileState = state.tiles[y][x];
                    if (tileState !== 'undefined') {
                        tile.dataset.state = tileState;
                    }

                    // Mouse events
                    tile.addEventListener('mousedown', handleTileMouseDown);
                    tile.addEventListener('mouseenter', handleTileMouseEnter);
                    tile.addEventListener('mouseup', handleTileMouseUp);

                    elements.grid.appendChild(tile);
                }
            }
        }

        function resizeGrid() {
            const newWidth = parseInt(elements.gridWidth.value) || 32;
            const newHeight = parseInt(elements.gridHeight.value) || 18;

            // Clamp values
            state.gridWidth = Math.max(4, Math.min(100, newWidth));
            state.gridHeight = Math.max(4, Math.min(100, newHeight));

            elements.gridWidth.value = state.gridWidth;
            elements.gridHeight.value = state.gridHeight;

            // Resize tiles array, preserving existing data where possible
            const newTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.tiles[y] && state.tiles[y][x]) {
                        row.push(state.tiles[y][x]);
                    } else {
                        row.push('undefined');
                    }
                }
                newTiles.push(row);
            }
            state.tiles = newTiles;

            // Resize visual tiles array too
            const newVisualTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.visualTiles[y] && state.visualTiles[y][x]) {
                        row.push(state.visualTiles[y][x]);
                    } else {
                        row.push(null);
                    }
                }
                newVisualTiles.push(row);
            }
            state.visualTiles = newVisualTiles;

            renderGrid();
            renderTileCanvas();
            renderBackgroundPreview();
            updateStats();
            updateJsonOutput();
            showToast(`Grid resized to ${state.gridWidth}x${state.gridHeight}`);
        }

        function clearGrid() {
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    state.tiles[y][x] = 'undefined';
                }
            }
            renderGrid();
            updateStats();
            updateJsonOutput();
            showToast('Grid cleared');
        }

        // ==========================================
        // Tile Operations
        // ==========================================
        function setTileState(x, y, newState) {
            if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;

            // Spawn point limit: only one allowed
            if (newState === 'spawn') {
                // Find and remove existing spawn point
                for (let sy = 0; sy < state.gridHeight; sy++) {
                    for (let sx = 0; sx < state.gridWidth; sx++) {
                        if (state.tiles[sy][sx] === 'spawn' && (sx !== x || sy !== y)) {
                            state.tiles[sy][sx] = 'open';  // Convert old spawn to open
                            const oldTile = getTileElement(sx, sy);
                            if (oldTile) oldTile.dataset.state = 'open';
                        }
                    }
                }
            }

            state.tiles[y][x] = newState;

            // Update DOM
            const tile = getTileElement(x, y);
            if (tile) {
                if (newState === 'undefined') {
                    delete tile.dataset.state;
                } else {
                    tile.dataset.state = newState;
                }
            }
        }

        function getTileElement(x, y) {
            return elements.grid.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        }

        function cycleTileState(x, y) {
            const currentState = state.tiles[y][x];
            const currentIndex = TILE_STATES.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % TILE_STATES.length;
            setTileState(x, y, TILE_STATES[nextIndex]);
        }

        // Flood fill algorithm
        function floodFill(startX, startY, fillState) {
            const originalState = state.tiles[startY][startX];
            if (originalState === fillState) return; // Already the target state

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) continue;
                if (state.tiles[y][x] !== originalState) continue;

                visited.add(key);
                setTileState(x, y, fillState);

                // Add adjacent tiles (4-directional)
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
        }

        // ==========================================
        // Mouse Handlers
        // ==========================================
        function handleTileMouseDown(e) {
            e.preventDefault();
            state.isMouseDown = true;

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);

            if (state.currentTool === 'paint') {
                // Cycle through states on click
                cycleTileState(x, y);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'fill') {
                floodFill(x, y, state.currentState);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'select') {
                state.selectionStart = { x, y };
                state.selectionEnd = { x, y };
                state.selectedTiles.clear();
                updateSelectionBox();
            }
        }

        function handleTileMouseEnter(e) {
            if (!state.isMouseDown) return;

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);

            if (state.currentTool === 'paint') {
                // Paint with current state while dragging
                setTileState(x, y, state.currentState);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'select') {
                state.selectionEnd = { x, y };
                updateSelectionBox();
            }
        }

        function handleTileMouseUp(e) {
            if (state.currentTool === 'select' && state.selectionStart && state.selectionEnd) {
                applySelectionFill();
            }
            state.isMouseDown = false;
        }

        // Global mouse up handler
        document.addEventListener('mouseup', () => {
            if (state.currentTool === 'select' && state.isMouseDown && state.selectionStart && state.selectionEnd) {
                applySelectionFill();
            }
            state.isMouseDown = false;
            elements.selectionBox.style.display = 'none';
        });

        // ==========================================
        // Selection
        // ==========================================
        function updateSelectionBox() {
            if (!state.selectionStart || !state.selectionEnd) {
                elements.selectionBox.style.display = 'none';
                return;
            }

            const minX = Math.min(state.selectionStart.x, state.selectionEnd.x);
            const maxX = Math.max(state.selectionStart.x, state.selectionEnd.x);
            const minY = Math.min(state.selectionStart.y, state.selectionEnd.y);
            const maxY = Math.max(state.selectionStart.y, state.selectionEnd.y);

            const tileSize = 25; // 24px + 1px gap

            elements.selectionBox.style.display = 'block';
            elements.selectionBox.style.left = (minX * tileSize + 2) + 'px';
            elements.selectionBox.style.top = (minY * tileSize + 2) + 'px';
            elements.selectionBox.style.width = ((maxX - minX + 1) * tileSize - 1) + 'px';
            elements.selectionBox.style.height = ((maxY - minY + 1) * tileSize - 1) + 'px';

            // Highlight selected tiles
            clearTileHighlights();
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const tile = getTileElement(x, y);
                    if (tile) tile.classList.add('selected');
                }
            }
        }

        function applySelectionFill() {
            if (!state.selectionStart || !state.selectionEnd) return;

            const minX = Math.min(state.selectionStart.x, state.selectionEnd.x);
            const maxX = Math.max(state.selectionStart.x, state.selectionEnd.x);
            const minY = Math.min(state.selectionStart.y, state.selectionEnd.y);
            const maxY = Math.max(state.selectionStart.y, state.selectionEnd.y);

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    setTileState(x, y, state.currentState);
                }
            }

            clearTileHighlights();
            state.selectionStart = null;
            state.selectionEnd = null;
            elements.selectionBox.style.display = 'none';

            updateStats();
            updateJsonOutput();
        }

        function clearTileHighlights() {
            document.querySelectorAll('.tile.selected').forEach(tile => {
                tile.classList.remove('selected');
            });
        }

        // ==========================================
        // Tool & State Selection
        // ==========================================
        function setTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            clearTileHighlights();
            elements.selectionBox.style.display = 'none';
        }

        function setState(newState) {
            state.currentState = newState;
            document.querySelectorAll('.state-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.state === newState);
            });
        }

        // Tool button click handlers
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => setTool(btn.dataset.tool));
        });

        // State button click handlers
        document.querySelectorAll('.state-btn').forEach(btn => {
            btn.addEventListener('click', () => setState(btn.dataset.state));
        });

        // ==========================================
        // Stats
        // ==========================================
        function updateStats() {
            let undefinedCount = 0;
            let openCount = 0;
            let obstructionCount = 0;
            let spawnCount = 0;

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'undefined') undefinedCount++;
                    else if (tileState === 'open') openCount++;
                    else if (tileState === 'obstruction') obstructionCount++;
                    else if (tileState === 'spawn') spawnCount++;
                }
            }

            const total = state.gridWidth * state.gridHeight;

            elements.totalTiles.textContent = total;
            elements.undefinedTiles.textContent = undefinedCount;
            // Include spawn in the "open" count since it's walkable
            elements.openTiles.textContent = openCount + spawnCount;
            elements.obstructionTiles.textContent = obstructionCount;
        }

        // ==========================================
        // JSON Export/Import
        // ==========================================
        function generateLevelData() {
            const levelName = elements.levelName.value || 'untitled';
            const levelType = state.levelType;

            // Encode tiles - we'll use a compact format
            // 0 = undefined, 1 = open, 2 = obstruction, 3 = spawn
            const tileData = [];
            let spawnPoint = null;

            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'undefined') row.push(0);
                    else if (tileState === 'open') row.push(1);
                    else if (tileState === 'obstruction') row.push(2);
                    else if (tileState === 'spawn') {
                        row.push(3);
                        spawnPoint = { x, y };
                    }
                }
                tileData.push(row);
            }

            // Also generate a list of walkable coordinates for easier game use
            const walkable = [];
            const obstructions = [];

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'open' || tileState === 'spawn') {
                        walkable.push({ x, y });
                    } else if (tileState === 'obstruction') {
                        obstructions.push({ x, y });
                    }
                }
            }

            // Physics settings based on level type
            const physics = levelType === 'platformer'
                ? {
                    gravity: true,
                    gravityStrength: 1800,
                    collisionMode: 'solid',  // obstructions are solid from all sides
                    playerCanLand: true       // player lands on top of obstructions
                }
                : {
                    gravity: false,
                    gravityStrength: 0,
                    collisionMode: 'blocking', // obstructions block movement
                    playerCanLand: false
                };

            // Background layers (without image data for smaller JSON)
            const backgrounds = state.backgrounds.map(layer => ({
                id: layer.id,
                name: layer.name,
                imageSrc: layer.imageSrc,
                depth: layer.depth,
                scrollRate: layer.scrollRate,
                offsetX: layer.offsetX,
                offsetY: layer.offsetY,
                scale: layer.scale,
                visible: layer.visible
            }));

            // Visual tiles (sparse encoding - only non-null tiles)
            const visualTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = state.visualTiles[y]?.[x];
                    if (tile) {
                        visualTiles.push({
                            x, y,
                            spriteSheet: tile.spriteSheet,
                            spriteName: tile.spriteName,
                            sourceX: tile.x,
                            sourceY: tile.y,
                            width: tile.width,
                            height: tile.height
                        });
                    }
                }
            }

            return {
                name: levelName,
                type: levelType,
                width: state.gridWidth,
                height: state.gridHeight,
                tileSize: 24,
                physics: physics,
                spawn: spawnPoint,
                grid: tileData,
                walkable: walkable,
                obstructions: obstructions,
                backgrounds: backgrounds,
                visualTiles: visualTiles,
                meta: {
                    totalTiles: state.gridWidth * state.gridHeight,
                    walkableCount: walkable.length,
                    obstructionCount: obstructions.length,
                    backgroundCount: backgrounds.length,
                    visualTileCount: visualTiles.length
                }
            };
        }

        function updateJsonOutput() {
            const levelData = generateLevelData();
            elements.jsonOutput.textContent = JSON.stringify(levelData, null, 2);
        }

        function copyJson() {
            navigator.clipboard.writeText(elements.jsonOutput.textContent)
                .then(() => showToast('Level JSON copied!'))
                .catch(() => showToast('Failed to copy'));
        }

        function loadJson() {
            const jsonStr = prompt('Paste level JSON:');
            if (!jsonStr) return;

            try {
                const levelData = JSON.parse(jsonStr);

                if (levelData.width && levelData.height && levelData.grid) {
                    state.gridWidth = levelData.width;
                    state.gridHeight = levelData.height;
                    elements.gridWidth.value = state.gridWidth;
                    elements.gridHeight.value = state.gridHeight;

                    state.tiles = [];
                    for (let y = 0; y < state.gridHeight; y++) {
                        const row = [];
                        for (let x = 0; x < state.gridWidth; x++) {
                            const value = levelData.grid[y]?.[x] ?? 0;
                            if (value === 1) row.push('open');
                            else if (value === 2) row.push('obstruction');
                            else if (value === 3) row.push('spawn');
                            else row.push('undefined');
                        }
                        state.tiles.push(row);
                    }

                    if (levelData.name) {
                        elements.levelName.value = levelData.name;
                    }

                    if (levelData.type) {
                        state.levelType = levelData.type;
                        elements.levelType.value = levelData.type;
                    }

                    // Load backgrounds
                    state.backgrounds = [];
                    if (levelData.backgrounds && levelData.backgrounds.length > 0) {
                        let loadedCount = 0;
                        levelData.backgrounds.forEach((bgData, index) => {
                            const img = new Image();
                            img.onload = () => {
                                state.backgrounds[index] = {
                                    id: bgData.id,
                                    name: bgData.name,
                                    imageSrc: bgData.imageSrc,
                                    image: img,
                                    depth: bgData.depth,
                                    scrollRate: bgData.scrollRate,
                                    offsetX: bgData.offsetX,
                                    offsetY: bgData.offsetY,
                                    scale: bgData.scale,
                                    visible: bgData.visible,
                                    pixelified: false,
                                    originalImageData: null
                                };
                                loadedCount++;
                                if (loadedCount === levelData.backgrounds.length) {
                                    state.selectedBgLayer = state.backgrounds.length > 0 ? 0 : -1;
                                    elements.pixelifyBtn.disabled = state.backgrounds.length === 0;
                                    renderBackgroundLayers();
                                    renderBackgroundPreview();
                                    updateBgLayerControls();
                                }
                            };
                            img.src = bgData.imageSrc;
                        });
                    }

                    // Load visual tiles
                    initVisualTiles();
                    if (levelData.visualTiles && levelData.visualTiles.length > 0) {
                        levelData.visualTiles.forEach(tile => {
                            if (tile.x >= 0 && tile.x < state.gridWidth &&
                                tile.y >= 0 && tile.y < state.gridHeight) {
                                state.visualTiles[tile.y][tile.x] = {
                                    spriteSheet: tile.spriteSheet,
                                    spriteName: tile.spriteName,
                                    x: tile.sourceX,
                                    y: tile.sourceY,
                                    width: tile.width,
                                    height: tile.height
                                };
                            }
                        });
                    }

                    renderGrid();
                    renderTileCanvas();
                    updateStats();
                    updateJsonOutput();
                    showToast('Level loaded!');
                } else {
                    showToast('Invalid level data');
                }
            } catch (e) {
                showToast('Invalid JSON');
            }
        }

        // ==========================================
        // Event Listeners
        // ==========================================
        elements.resizeGridBtn.addEventListener('click', resizeGrid);
        elements.clearGridBtn.addEventListener('click', clearGrid);
        elements.newLevelBtn.addEventListener('click', () => {
            if (confirm('Create new level? Current progress will be lost.')) {
                elements.levelName.value = '';
                clearGrid();
            }
        });
        elements.copyJsonBtn.addEventListener('click', copyJson);
        elements.loadJsonBtn.addEventListener('click', loadJson);
        elements.levelName.addEventListener('input', updateJsonOutput);
        elements.levelType.addEventListener('change', (e) => {
            state.levelType = e.target.value;
            updateJsonOutput();
        });

        // Keyboard shortcuts (editor mode only)
        window.addEventListener('keydown', (e) => {
            if (demo.active) return;  // Don't handle editor shortcuts in demo mode
            if (document.activeElement.tagName === 'INPUT') return;
            if (document.activeElement.tagName === 'SELECT') return;

            switch (e.key.toLowerCase()) {
                case 'p':
                    setTool('paint');
                    break;
                case 'f':
                    setTool('fill');
                    break;
                case 's':
                    setTool('select');
                    break;
                case '1':
                    setState('undefined');
                    break;
                case '2':
                    setState('open');
                    break;
                case '3':
                    setState('obstruction');
                    break;
                case '4':
                    setState('spawn');
                    break;
                case 'escape':
                    clearTileHighlights();
                    elements.selectionBox.style.display = 'none';
                    state.selectionStart = null;
                    state.selectionEnd = null;
                    break;
            }
        });

        // ==========================================
        // Demo Mode
        // ==========================================
        const demo = {
            active: false,
            ctx: null,
            player: {
                x: 100,
                y: 100,
                width: 20,
                height: 32,
                vx: 0,
                vy: 0,
                onGround: false
            },
            keys: {},
            animationFrame: null,
            lastTime: 0
        };

        const DEMO_SCALE = 2;
        const PLAYER_SPEED = 200;
        const JUMP_FORCE = 500;
        const GRAVITY = 1200;
        const TOPDOWN_SPEED = 150;

        function startDemo() {
            demo.active = true;
            demo.ctx = elements.demoCanvas.getContext('2d');
            demo.ctx.imageSmoothingEnabled = false;

            // Set canvas size
            const canvasWidth = state.gridWidth * 24;
            const canvasHeight = state.gridHeight * 24;
            elements.demoCanvas.width = canvasWidth;
            elements.demoCanvas.height = canvasHeight;
            elements.demoCanvas.style.width = (canvasWidth * DEMO_SCALE) + 'px';
            elements.demoCanvas.style.height = (canvasHeight * DEMO_SCALE) + 'px';

            // Find spawn point (first open tile from bottom-left for platformer, center for topdown)
            resetPlayerPosition();

            // Update HUD controls text
            if (state.levelType === 'platformer') {
                elements.demoControls.innerHTML = `
                    <kbd>&#8592;</kbd><kbd>&#8594;</kbd> Move<br>
                    <kbd>Space</kbd> Jump<br>
                    <kbd>Esc</kbd> Exit
                `;
            } else {
                elements.demoControls.innerHTML = `
                    <kbd>&#8592;</kbd><kbd>&#8594;</kbd><kbd>&#8593;</kbd><kbd>&#8595;</kbd> Move<br>
                    <kbd>Esc</kbd> Exit
                `;
            }

            // Show overlay
            elements.demoOverlay.classList.add('active');

            // Start game loop
            demo.lastTime = performance.now();
            demo.animationFrame = requestAnimationFrame(demoLoop);
        }

        function stopDemo() {
            demo.active = false;
            elements.demoOverlay.classList.remove('active');
            if (demo.animationFrame) {
                cancelAnimationFrame(demo.animationFrame);
                demo.animationFrame = null;
            }
            demo.keys = {};
        }

        function resetPlayerPosition() {
            const tileSize = 24;

            // First, look for spawn point
            let spawnX = -1, spawnY = -1;
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.tiles[y][x] === 'spawn') {
                        spawnX = x;
                        spawnY = y;
                        break;
                    }
                }
                if (spawnX !== -1) break;
            }

            // If spawn point found, use it
            if (spawnX !== -1) {
                demo.player.x = spawnX * tileSize + (tileSize - demo.player.width) / 2;
                demo.player.y = spawnY * tileSize + (tileSize - demo.player.height);
                demo.player.vx = 0;
                demo.player.vy = 0;
                demo.player.onGround = false;
                return;
            }

            if (state.levelType === 'platformer') {
                // Find first open tile from bottom, scanning left to right (not on obstruction)
                for (let y = state.gridHeight - 1; y >= 0; y--) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        if (state.tiles[y][x] === 'open') {
                            // Check if there's ground below or at bottom
                            const hasGround = y === state.gridHeight - 1 ||
                                             state.tiles[y + 1]?.[x] === 'obstruction';
                            if (hasGround) {
                                demo.player.x = x * tileSize + (tileSize - demo.player.width) / 2;
                                demo.player.y = y * tileSize + (tileSize - demo.player.height);
                                demo.player.vx = 0;
                                demo.player.vy = 0;
                                return;
                            }
                        }
                    }
                }
                // Fallback: top-left
                demo.player.x = tileSize;
                demo.player.y = tileSize;
            } else {
                // Top-down: find first open tile or center of level
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        if (state.tiles[y][x] === 'open') {
                            demo.player.x = x * tileSize + (tileSize - demo.player.width) / 2;
                            demo.player.y = y * tileSize + (tileSize - demo.player.height) / 2;
                            demo.player.vx = 0;
                            demo.player.vy = 0;
                            return;
                        }
                    }
                }
                // Fallback: center of level
                demo.player.x = (state.gridWidth * tileSize) / 2 - demo.player.width / 2;
                demo.player.y = (state.gridHeight * tileSize) / 2 - demo.player.height / 2;
            }
            demo.player.vx = 0;
            demo.player.vy = 0;
        }

        function demoLoop(currentTime) {
            if (!demo.active) return;

            const dt = Math.min((currentTime - demo.lastTime) / 1000, 0.05);
            demo.lastTime = currentTime;

            updatePlayer(dt);
            renderDemo();

            demo.animationFrame = requestAnimationFrame(demoLoop);
        }

        function updatePlayer(dt) {
            const p = demo.player;
            const tileSize = 24;

            if (state.levelType === 'platformer') {
                // Horizontal movement
                p.vx = 0;
                if (demo.keys['ArrowLeft'] || demo.keys['KeyA']) p.vx = -PLAYER_SPEED;
                if (demo.keys['ArrowRight'] || demo.keys['KeyD']) p.vx = PLAYER_SPEED;

                // Gravity
                p.vy += GRAVITY * dt;

                // Jump
                if ((demo.keys['Space'] || demo.keys['ArrowUp'] || demo.keys['KeyW']) && p.onGround) {
                    p.vy = -JUMP_FORCE;
                    p.onGround = false;
                }

                // Apply velocity
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Collision detection
                p.onGround = false;

                // Check tile collisions
                const left = Math.floor(p.x / tileSize);
                const right = Math.floor((p.x + p.width - 1) / tileSize);
                const top = Math.floor(p.y / tileSize);
                const bottom = Math.floor((p.y + p.height - 1) / tileSize);

                // Vertical collision (landing on platforms)
                for (let tx = left; tx <= right; tx++) {
                    // Check below
                    const tileBelow = state.tiles[bottom]?.[tx];
                    if (tileBelow === 'obstruction') {
                        if (p.vy > 0) {
                            p.y = bottom * tileSize - p.height;
                            p.vy = 0;
                            p.onGround = true;
                        }
                    }
                    // Check above
                    const tileAbove = state.tiles[top]?.[tx];
                    if (tileAbove === 'obstruction') {
                        if (p.vy < 0) {
                            p.y = (top + 1) * tileSize;
                            p.vy = 0;
                        }
                    }
                }

                // Recalculate after vertical adjustment
                const newTop = Math.floor(p.y / tileSize);
                const newBottom = Math.floor((p.y + p.height - 1) / tileSize);

                // Horizontal collision
                for (let ty = newTop; ty <= newBottom; ty++) {
                    // Check left
                    const newLeft = Math.floor(p.x / tileSize);
                    if (state.tiles[ty]?.[newLeft] === 'obstruction') {
                        p.x = (newLeft + 1) * tileSize;
                    }
                    // Check right
                    const newRight = Math.floor((p.x + p.width - 1) / tileSize);
                    if (state.tiles[ty]?.[newRight] === 'obstruction') {
                        p.x = newRight * tileSize - p.width;
                    }
                }

                // Bounds
                p.x = Math.max(0, Math.min(p.x, state.gridWidth * tileSize - p.width));
                p.y = Math.max(0, Math.min(p.y, state.gridHeight * tileSize - p.height));

                // Ground at bottom of level
                if (p.y >= state.gridHeight * tileSize - p.height) {
                    p.y = state.gridHeight * tileSize - p.height;
                    p.vy = 0;
                    p.onGround = true;
                }

            } else {
                // Top-down movement
                p.vx = 0;
                p.vy = 0;
                if (demo.keys['ArrowLeft'] || demo.keys['KeyA']) p.vx = -TOPDOWN_SPEED;
                if (demo.keys['ArrowRight'] || demo.keys['KeyD']) p.vx = TOPDOWN_SPEED;
                if (demo.keys['ArrowUp'] || demo.keys['KeyW']) p.vy = -TOPDOWN_SPEED;
                if (demo.keys['ArrowDown'] || demo.keys['KeyS']) p.vy = TOPDOWN_SPEED;

                // Normalize diagonal movement
                if (p.vx !== 0 && p.vy !== 0) {
                    p.vx *= 0.707;
                    p.vy *= 0.707;
                }

                // Try X movement
                const newX = p.x + p.vx * dt;
                if (!checkCollisionTopDown(newX, p.y, p.width, p.height)) {
                    p.x = newX;
                }

                // Try Y movement
                const newY = p.y + p.vy * dt;
                if (!checkCollisionTopDown(p.x, newY, p.width, p.height)) {
                    p.y = newY;
                }

                // Bounds
                p.x = Math.max(0, Math.min(p.x, state.gridWidth * tileSize - p.width));
                p.y = Math.max(0, Math.min(p.y, state.gridHeight * tileSize - p.height));
            }
        }

        function checkCollisionTopDown(x, y, w, h) {
            const tileSize = 24;
            const left = Math.floor(x / tileSize);
            const right = Math.floor((x + w - 1) / tileSize);
            const top = Math.floor(y / tileSize);
            const bottom = Math.floor((y + h - 1) / tileSize);

            for (let ty = top; ty <= bottom; ty++) {
                for (let tx = left; tx <= right; tx++) {
                    const tile = state.tiles[ty]?.[tx];
                    // Only obstruction blocks movement (open, spawn, undefined are walkable)
                    if (tile === 'obstruction') {
                        return true;
                    }
                }
            }
            return false;
        }

        function renderDemo() {
            const ctx = demo.ctx;
            const tileSize = 24;

            // Clear
            ctx.fillStyle = '#0d0d14';
            ctx.fillRect(0, 0, elements.demoCanvas.width, elements.demoCanvas.height);

            // Draw backgrounds (sorted by depth, furthest back first)
            const sortedBgs = [...state.backgrounds]
                .filter(l => l.visible)
                .sort((a, b) => a.depth - b.depth);

            ctx.imageSmoothingEnabled = false;
            sortedBgs.forEach(layer => {
                ctx.save();
                // Apply parallax offset based on player position
                const parallaxX = layer.offsetX - (demo.player.x * (1 - layer.scrollRate) * 0.1);
                const parallaxY = layer.offsetY - (demo.player.y * (1 - layer.scrollRate) * 0.1);
                ctx.translate(parallaxX, parallaxY);
                const scaledWidth = layer.image.width * layer.scale;
                const scaledHeight = layer.image.height * layer.scale;
                ctx.drawImage(layer.image, 0, 0, scaledWidth, scaledHeight);
                ctx.restore();
            });

            // Draw collision tiles (as fallback/debug if no visual tiles)
            const hasVisualTiles = state.visualTiles.some(row => row.some(t => t !== null));

            if (!hasVisualTiles) {
                // Draw collision grid colors
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        const tile = state.tiles[y][x];
                        if (tile === 'open') {
                            ctx.fillStyle = '#2a5a30';
                        } else if (tile === 'obstruction') {
                            ctx.fillStyle = '#6a2a2a';
                        } else if (tile === 'spawn') {
                            ctx.fillStyle = '#2a4a6a';
                        } else {
                            ctx.fillStyle = '#1a1a2e';
                        }
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                    }
                }
            } else {
                // Draw visual tiles
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        const vTile = state.visualTiles[y]?.[x];
                        if (vTile) {
                            const sheetImage = state.spriteImages[vTile.spriteSheet];
                            if (sheetImage) {
                                ctx.drawImage(
                                    sheetImage,
                                    vTile.x, vTile.y, vTile.width, vTile.height,
                                    x * tileSize, y * tileSize, tileSize, tileSize
                                );
                            }
                        } else {
                            // Draw collision color for empty tiles
                            const tile = state.tiles[y][x];
                            if (tile === 'obstruction') {
                                ctx.fillStyle = '#6a2a2a';
                                ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                            }
                        }
                    }
                }
            }

            // Draw player
            ctx.fillStyle = '#e07020';
            ctx.fillRect(
                Math.round(demo.player.x),
                Math.round(demo.player.y),
                demo.player.width,
                demo.player.height
            );

            // Player face indicator (shows direction)
            ctx.fillStyle = '#fff';
            const eyeY = Math.round(demo.player.y) + 6;
            const eyeSize = 3;
            ctx.fillRect(Math.round(demo.player.x) + 4, eyeY, eyeSize, eyeSize);
            ctx.fillRect(Math.round(demo.player.x) + demo.player.width - 7, eyeY, eyeSize, eyeSize);
        }

        // Demo key handlers
        function handleDemoKeyDown(e) {
            if (!demo.active) return;

            // Prevent default for game controls to avoid page scrolling/other browser behavior
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' ||
                e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                e.preventDefault();
            }

            demo.keys[e.code] = true;

            if (e.code === 'Escape') {
                stopDemo();
            }
        }

        function handleDemoKeyUp(e) {
            if (!demo.active) return;

            // Prevent default for game controls
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' ||
                e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                e.preventDefault();
            }

            demo.keys[e.code] = false;
        }

        window.addEventListener('keydown', handleDemoKeyDown);
        window.addEventListener('keyup', handleDemoKeyUp);

        elements.playDemoBtn.addEventListener('click', startDemo);
        elements.exitDemoBtn.addEventListener('click', stopDemo);

        // ==========================================
        // Tab Management
        // ==========================================
        function switchTab(tabName) {
            state.activeTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            // Update tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(tabName + 'Panel').classList.add('active');

            // Update grid toolbar visibility
            elements.gridToolbar.classList.toggle('active', tabName === 'grid');

            // Update right panel settings
            elements.gridSettings.classList.toggle('active', tabName === 'grid');
            elements.bgSettings.classList.toggle('active', tabName === 'background');
            elements.pixelifySettings.classList.toggle('active', tabName === 'background');
            elements.tileSettings.classList.toggle('active', tabName === 'tiles');

            // Render appropriate content
            if (tabName === 'background') {
                renderBackgroundPreview();
            } else if (tabName === 'tiles') {
                renderTileCanvas();
            }

            updateJsonOutput();
        }

        // Tab button click handlers
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // ==========================================
        // Background Editor
        // ==========================================
        function addBackgroundLayer(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const layer = {
                        id: 'bg_' + Date.now(),
                        name: file.name.replace(/\.[^.]+$/, ''),
                        imageSrc: e.target.result,
                        image: img,
                        depth: state.backgrounds.length * -10,
                        scrollRate: 1,
                        offsetX: 0,
                        offsetY: 0,
                        scale: 1,
                        visible: true,
                        pixelified: false,
                        originalImageData: null
                    };
                    state.backgrounds.push(layer);
                    state.selectedBgLayer = state.backgrounds.length - 1;
                    elements.pixelifyBtn.disabled = false;
                    renderBackgroundLayers();
                    renderBackgroundPreview();
                    updateBgLayerControls();
                    updateJsonOutput();
                    showToast('Background layer added');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function renderBackgroundLayers() {
            if (state.backgrounds.length === 0) {
                elements.backgroundLayers.innerHTML = '<div class="no-layers-message">No background layers. Click "+ Add Layer" to upload an image.<br><br>Recommended: 768x432px (32x18 tiles at 24px)</div>';
                return;
            }

            elements.backgroundLayers.innerHTML = state.backgrounds.map((layer, index) => `
                <div class="bg-layer-item ${index === state.selectedBgLayer ? 'selected' : ''}" data-index="${index}">
                    <div class="bg-layer-thumb">
                        <img src="${layer.imageSrc}" alt="${layer.name}">
                    </div>
                    <div class="bg-layer-info">
                        <div class="bg-layer-name">${layer.name}</div>
                        <div class="bg-layer-meta">Depth: ${layer.depth} | Scale: ${layer.scale}x</div>
                    </div>
                    <div class="bg-layer-actions">
                        <button class="bg-layer-visibility ${layer.visible ? '' : 'hidden'}" data-index="${index}" title="Toggle visibility">
                            ${layer.visible ? '&#128065;' : '&#128064;'}
                        </button>
                        <button class="bg-layer-delete" data-index="${index}" title="Delete layer">&#10005;</button>
                    </div>
                </div>
            `).join('');

            // Add event listeners
            elements.backgroundLayers.querySelectorAll('.bg-layer-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.bg-layer-visibility') && !e.target.closest('.bg-layer-delete')) {
                        selectBgLayer(parseInt(item.dataset.index));
                    }
                });
            });

            elements.backgroundLayers.querySelectorAll('.bg-layer-visibility').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleBgLayerVisibility(parseInt(btn.dataset.index));
                });
            });

            elements.backgroundLayers.querySelectorAll('.bg-layer-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteBgLayer(parseInt(btn.dataset.index));
                });
            });
        }

        function selectBgLayer(index) {
            state.selectedBgLayer = index;
            renderBackgroundLayers();
            updateBgLayerControls();
        }

        function toggleBgLayerVisibility(index) {
            state.backgrounds[index].visible = !state.backgrounds[index].visible;
            renderBackgroundLayers();
            renderBackgroundPreview();
            updateJsonOutput();
        }

        function deleteBgLayer(index) {
            state.backgrounds.splice(index, 1);
            if (state.selectedBgLayer >= state.backgrounds.length) {
                state.selectedBgLayer = state.backgrounds.length - 1;
            }
            elements.pixelifyBtn.disabled = state.backgrounds.length === 0;
            renderBackgroundLayers();
            renderBackgroundPreview();
            updateBgLayerControls();
            updateJsonOutput();
            showToast('Layer deleted');
        }

        function updateBgLayerControls() {
            if (state.selectedBgLayer < 0 || state.selectedBgLayer >= state.backgrounds.length) {
                elements.bgLayerControls.style.display = 'none';
                document.getElementById('bgLayerSettings').innerHTML = '<div class="no-layers-message">Select a layer to edit its settings</div>';
                return;
            }

            elements.bgLayerControls.style.display = 'block';
            document.getElementById('bgLayerSettings').innerHTML = '';

            const layer = state.backgrounds[state.selectedBgLayer];
            elements.bgLayerName.value = layer.name;
            elements.bgDepth.value = layer.depth;
            elements.bgScrollRate.value = layer.scrollRate;
            elements.bgOffsetX.value = layer.offsetX;
            elements.bgOffsetY.value = layer.offsetY;
            elements.bgScale.value = layer.scale;
            elements.bgScaleValue.textContent = layer.scale + 'x';
        }

        function updateSelectedBgLayer(property, value) {
            if (state.selectedBgLayer < 0) return;
            state.backgrounds[state.selectedBgLayer][property] = value;
            renderBackgroundLayers();
            renderBackgroundPreview();
            updateJsonOutput();
        }

        function renderBackgroundPreview() {
            const canvas = elements.backgroundCanvas;
            const ctx = canvas.getContext('2d');

            // Size canvas to level dimensions
            const levelWidth = state.gridWidth * 24;
            const levelHeight = state.gridHeight * 24;
            canvas.width = levelWidth;
            canvas.height = levelHeight;

            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, levelWidth, levelHeight);

            // Draw checkerboard for transparency
            const checkSize = 8;
            for (let y = 0; y < levelHeight; y += checkSize) {
                for (let x = 0; x < levelWidth; x += checkSize) {
                    ctx.fillStyle = ((x / checkSize + y / checkSize) % 2 === 0) ? '#252542' : '#1a1a2e';
                    ctx.fillRect(x, y, checkSize, checkSize);
                }
            }

            // Sort layers by depth (furthest back first)
            const sortedLayers = [...state.backgrounds]
                .filter(l => l.visible)
                .sort((a, b) => a.depth - b.depth);

            sortedLayers.forEach(layer => {
                ctx.save();
                ctx.translate(layer.offsetX, layer.offsetY);
                const scaledWidth = layer.image.width * layer.scale;
                const scaledHeight = layer.image.height * layer.scale;
                ctx.drawImage(layer.image, 0, 0, scaledWidth, scaledHeight);
                ctx.restore();
            });
        }

        // Background layer input handlers
        elements.bgFileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                addBackgroundLayer(e.target.files[0]);
                e.target.value = ''; // Reset for re-upload
            }
        });

        elements.bgLayerName.addEventListener('input', (e) => updateSelectedBgLayer('name', e.target.value));
        elements.bgDepth.addEventListener('input', (e) => updateSelectedBgLayer('depth', parseInt(e.target.value) || 0));
        elements.bgScrollRate.addEventListener('input', (e) => updateSelectedBgLayer('scrollRate', parseFloat(e.target.value) || 1));
        elements.bgOffsetX.addEventListener('input', (e) => updateSelectedBgLayer('offsetX', parseInt(e.target.value) || 0));
        elements.bgOffsetY.addEventListener('input', (e) => updateSelectedBgLayer('offsetY', parseInt(e.target.value) || 0));
        elements.bgScale.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            elements.bgScaleValue.textContent = val + 'x';
            updateSelectedBgLayer('scale', val);
        });

        // Pixelify controls
        elements.pixelSize.addEventListener('input', (e) => {
            elements.pixelSizeValue.textContent = e.target.value + 'px';
            state.pixelifySettings.pixelSize = parseInt(e.target.value);
        });

        elements.colorDepth.addEventListener('input', (e) => {
            elements.colorDepthValue.textContent = e.target.value;
            state.pixelifySettings.colorDepth = parseInt(e.target.value);
        });

        elements.enableDithering.addEventListener('change', (e) => {
            state.pixelifySettings.dithering = e.target.checked;
        });

        elements.ditherPattern.addEventListener('change', (e) => {
            state.pixelifySettings.ditherPattern = e.target.value;
        });

        // ==========================================
        // Pixelify Effect
        // ==========================================
        function applyPixelifyEffect() {
            if (state.selectedBgLayer < 0) {
                showToast('Select a layer first');
                return;
            }

            const layer = state.backgrounds[state.selectedBgLayer];
            const { pixelSize, colorDepth, dithering, ditherPattern } = state.pixelifySettings;

            // Create working canvas
            const workCanvas = document.createElement('canvas');
            const workCtx = workCanvas.getContext('2d');
            workCanvas.width = layer.image.width;
            workCanvas.height = layer.image.height;

            // Draw original image
            workCtx.drawImage(layer.image, 0, 0);

            // Store original for undo if not already stored
            if (!layer.originalImageData) {
                layer.originalImageData = workCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
            }

            // Downscale
            const smallWidth = Math.ceil(workCanvas.width / pixelSize);
            const smallHeight = Math.ceil(workCanvas.height / pixelSize);

            const smallCanvas = document.createElement('canvas');
            const smallCtx = smallCanvas.getContext('2d');
            smallCanvas.width = smallWidth;
            smallCanvas.height = smallHeight;
            smallCtx.imageSmoothingEnabled = false;
            smallCtx.drawImage(workCanvas, 0, 0, smallWidth, smallHeight);

            // Get pixel data for posterization
            const imageData = smallCtx.getImageData(0, 0, smallWidth, smallHeight);
            const data = imageData.data;

            // Posterize colors
            const levels = 256 / colorDepth;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.round(data[i] / levels) * levels;     // R
                data[i + 1] = Math.round(data[i + 1] / levels) * levels; // G
                data[i + 2] = Math.round(data[i + 2] / levels) * levels; // B
            }

            // Apply dithering if enabled
            if (dithering) {
                applyDithering(imageData, ditherPattern);
            }

            smallCtx.putImageData(imageData, 0, 0);

            // Upscale back
            workCtx.imageSmoothingEnabled = false;
            workCtx.clearRect(0, 0, workCanvas.width, workCanvas.height);
            workCtx.drawImage(smallCanvas, 0, 0, workCanvas.width, workCanvas.height);

            // Update layer image
            const newImg = new Image();
            newImg.onload = () => {
                layer.image = newImg;
                layer.pixelified = true;
                renderBackgroundPreview();
                showToast('Pixelify effect applied');
            };
            newImg.src = workCanvas.toDataURL();
        }

        function applyDithering(imageData, pattern) {
            const { width, height, data } = imageData;

            if (pattern === 'ordered') {
                // Bayer 4x4 matrix
                const bayer = [
                    [0, 8, 2, 10],
                    [12, 4, 14, 6],
                    [3, 11, 1, 9],
                    [15, 7, 13, 5]
                ];

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const threshold = (bayer[y % 4][x % 4] / 16 - 0.5) * 32;

                        data[i] = Math.max(0, Math.min(255, data[i] + threshold));
                        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + threshold));
                        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + threshold));
                    }
                }
            } else if (pattern === 'floyd-steinberg') {
                // Floyd-Steinberg error diffusion
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        for (let c = 0; c < 3; c++) {
                            const oldVal = data[i + c];
                            const newVal = Math.round(oldVal / 32) * 32;
                            data[i + c] = newVal;
                            const error = oldVal - newVal;

                            // Distribute error
                            if (x + 1 < width) data[i + 4 + c] += error * 7 / 16;
                            if (y + 1 < height) {
                                if (x > 0) data[i + width * 4 - 4 + c] += error * 3 / 16;
                                data[i + width * 4 + c] += error * 5 / 16;
                                if (x + 1 < width) data[i + width * 4 + 4 + c] += error * 1 / 16;
                            }
                        }
                    }
                }
            }
        }

        function resetPixelify() {
            if (state.selectedBgLayer < 0) return;

            const layer = state.backgrounds[state.selectedBgLayer];
            if (!layer.originalImageData) {
                showToast('No original to restore');
                return;
            }

            // Restore from original
            const canvas = document.createElement('canvas');
            canvas.width = layer.originalImageData.width;
            canvas.height = layer.originalImageData.height;
            const ctx = canvas.getContext('2d');
            ctx.putImageData(layer.originalImageData, 0, 0);

            const newImg = new Image();
            newImg.onload = () => {
                layer.image = newImg;
                layer.pixelified = false;
                renderBackgroundPreview();
                showToast('Reset to original');
            };
            newImg.src = canvas.toDataURL();
        }

        elements.applyPixelify.addEventListener('click', applyPixelifyEffect);
        elements.resetPixelify.addEventListener('click', resetPixelify);
        elements.pixelifyBtn.addEventListener('click', () => {
            // Just focus on the pixelify settings - they're already visible
            showToast('Adjust settings and click Apply');
        });

        // ==========================================
        // Tile Painter
        // ==========================================
        function initVisualTiles() {
            state.visualTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    row.push(null);
                }
                state.visualTiles.push(row);
            }
        }

        async function loadSpriteIndex() {
            try {
                const response = await fetch('/assets/sprites/sprite-index.json');
                if (response.ok) {
                    const data = await response.json();
                    state.spriteSheets = data;
                    populateSpriteSheetSelect();
                }
            } catch (e) {
                console.warn('Could not load sprite index:', e);
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">No sprite sheets found. Create some with Tilesmith!</div>';
            }
        }

        function populateSpriteSheetSelect() {
            const sheetNames = Object.keys(state.spriteSheets);
            if (sheetNames.length === 0) {
                elements.spriteSheetSelect.innerHTML = '<option value="">No sheets available</option>';
                return;
            }

            elements.spriteSheetSelect.innerHTML = '<option value="">-- Select Sheet --</option>' +
                sheetNames.map(name => `<option value="${name}">${name}</option>`).join('');
        }

        async function loadSpriteSheet(sheetName) {
            if (!sheetName || !state.spriteSheets[sheetName]) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Select a sprite sheet to load sprites</div>';
                return;
            }

            const sheetData = state.spriteSheets[sheetName];

            // Load image if not already loaded
            if (!state.spriteImages[sheetName]) {
                const img = new Image();
                img.src = sheetData.path || `/assets/sprites/${sheetName}.png`;
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => {
                        console.warn('Could not load sprite sheet:', sheetName);
                        reject();
                    };
                }).catch(() => {
                    elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Could not load sprite sheet image</div>';
                    return;
                });
                state.spriteImages[sheetName] = img;
            }

            state.selectedSpriteSheet = sheetName;
            renderSpritePalette();
        }

        function renderSpritePalette() {
            const sheetName = state.selectedSpriteSheet;
            if (!sheetName || !state.spriteSheets[sheetName]) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Select a sprite sheet</div>';
                return;
            }

            const sheetData = state.spriteSheets[sheetName];
            const sheetImage = state.spriteImages[sheetName];
            const sprites = sheetData.sprites || [];

            if (sprites.length === 0) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">No sprites in this sheet</div>';
                return;
            }

            elements.paletteGrid.innerHTML = sprites.map((sprite, index) => {
                const isSelected = state.selectedSprite &&
                    state.selectedSprite.sheetName === sheetName &&
                    state.selectedSprite.name === sprite.name;
                return `<div class="palette-sprite ${isSelected ? 'selected' : ''}"
                            data-sheet="${sheetName}"
                            data-sprite="${sprite.name}"
                            data-index="${index}"
                            title="${sprite.name}"></div>`;
            }).join('');

            // Draw sprite thumbnails
            elements.paletteGrid.querySelectorAll('.palette-sprite').forEach((el, index) => {
                const sprite = sprites[index];
                const canvas = document.createElement('canvas');
                const size = 36;
                const scale = Math.min(size / sprite.width, size / sprite.height, 2);
                canvas.width = Math.floor(sprite.width * scale);
                canvas.height = Math.floor(sprite.height * scale);

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                    sheetImage,
                    sprite.x, sprite.y, sprite.width, sprite.height,
                    0, 0, canvas.width, canvas.height
                );

                const img = document.createElement('img');
                img.src = canvas.toDataURL();
                el.appendChild(img);

                el.addEventListener('click', () => selectSprite(sheetName, sprite));
            });
        }

        function selectSprite(sheetName, sprite) {
            state.selectedSprite = { sheetName, ...sprite };

            // Update palette selection
            elements.paletteGrid.querySelectorAll('.palette-sprite').forEach(el => {
                el.classList.toggle('selected',
                    el.dataset.sheet === sheetName && el.dataset.sprite === sprite.name);
            });

            // Update preview
            renderSelectedSpritePreview();
            elements.selectedSpriteName.value = sprite.name;
        }

        function renderSelectedSpritePreview() {
            if (!state.selectedSprite) {
                elements.selectedSpritePreview.innerHTML = '<span class="no-sprites-message">No sprite selected</span>';
                return;
            }

            const sprite = state.selectedSprite;
            const sheetImage = state.spriteImages[sprite.sheetName];
            if (!sheetImage) return;

            const canvas = document.createElement('canvas');
            const maxSize = 64;
            const scale = Math.min(maxSize / sprite.width, maxSize / sprite.height, 4);
            canvas.width = Math.floor(sprite.width * scale);
            canvas.height = Math.floor(sprite.height * scale);

            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
                sheetImage,
                sprite.x, sprite.y, sprite.width, sprite.height,
                0, 0, canvas.width, canvas.height
            );

            const img = document.createElement('img');
            img.src = canvas.toDataURL();
            elements.selectedSpritePreview.innerHTML = '';
            elements.selectedSpritePreview.appendChild(img);
        }

        function paintVisualTile(x, y) {
            if (!state.selectedSprite) return;
            if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;

            state.visualTiles[y][x] = {
                spriteSheet: state.selectedSprite.sheetName,
                spriteName: state.selectedSprite.name,
                x: state.selectedSprite.x,
                y: state.selectedSprite.y,
                width: state.selectedSprite.width,
                height: state.selectedSprite.height
            };

            renderTileCanvas();
            updateJsonOutput();
        }

        function eraseVisualTile(x, y) {
            if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;
            state.visualTiles[y][x] = null;
            renderTileCanvas();
            updateJsonOutput();
        }

        function fillVisualTiles(startX, startY) {
            if (!state.selectedSprite) return;
            const originalTile = state.visualTiles[startY]?.[startX];
            const originalKey = originalTile ?
                `${originalTile.spriteSheet}:${originalTile.spriteName}` : null;

            const newKey = `${state.selectedSprite.sheetName}:${state.selectedSprite.name}`;
            if (originalKey === newKey) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) continue;

                const currentTile = state.visualTiles[y][x];
                const currentKey = currentTile ?
                    `${currentTile.spriteSheet}:${currentTile.spriteName}` : null;
                if (currentKey !== originalKey) continue;

                visited.add(key);
                paintVisualTile(x, y);

                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
        }

        function clearVisualTiles() {
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    state.visualTiles[y][x] = null;
                }
            }
            renderTileCanvas();
            updateJsonOutput();
            showToast('Visual tiles cleared');
        }

        function renderTileCanvas() {
            const canvas = elements.tileCanvas;
            const ctx = canvas.getContext('2d');
            const tileSize = 24;

            canvas.width = state.gridWidth * tileSize;
            canvas.height = state.gridHeight * tileSize;
            ctx.imageSmoothingEnabled = false;

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw collision grid as semi-transparent underlay
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = state.tiles[y]?.[x];
                    ctx.globalAlpha = 0.3;
                    if (tile === 'open') {
                        ctx.fillStyle = '#2a5a30';
                    } else if (tile === 'obstruction') {
                        ctx.fillStyle = '#6a2a2a';
                    } else if (tile === 'spawn') {
                        ctx.fillStyle = '#2a4a6a';
                    } else {
                        ctx.fillStyle = '#1a1a2e';
                    }
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            ctx.globalAlpha = 1;

            // Draw visual tiles
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = state.visualTiles[y]?.[x];
                    if (!tile) continue;

                    const sheetImage = state.spriteImages[tile.spriteSheet];
                    if (!sheetImage) continue;

                    ctx.drawImage(
                        sheetImage,
                        tile.x, tile.y, tile.width, tile.height,
                        x * tileSize, y * tileSize, tileSize, tileSize
                    );
                }
            }

            // Draw grid lines
            ctx.strokeStyle = 'rgba(106, 106, 142, 0.25)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= state.gridWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x * tileSize + 0.5, 0);
                ctx.lineTo(x * tileSize + 0.5, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= state.gridHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * tileSize + 0.5);
                ctx.lineTo(canvas.width, y * tileSize + 0.5);
                ctx.stroke();
            }
        }

        // Tile canvas mouse handlers
        function getTileFromCanvasEvent(e) {
            const canvas = elements.tileCanvas;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX / 24);
            const y = Math.floor((e.clientY - rect.top) * scaleY / 24);
            return { x, y };
        }

        elements.tileCanvas.addEventListener('mousedown', (e) => {
            state.tileMouseDown = true;
            const { x, y } = getTileFromCanvasEvent(e);

            if (state.currentTileTool === 'paint') {
                paintVisualTile(x, y);
            } else if (state.currentTileTool === 'erase') {
                eraseVisualTile(x, y);
            } else if (state.currentTileTool === 'fill') {
                fillVisualTiles(x, y);
            }
        });

        elements.tileCanvas.addEventListener('mousemove', (e) => {
            if (!state.tileMouseDown) return;
            const { x, y } = getTileFromCanvasEvent(e);

            if (state.currentTileTool === 'paint') {
                paintVisualTile(x, y);
            } else if (state.currentTileTool === 'erase') {
                eraseVisualTile(x, y);
            }
        });

        document.addEventListener('mouseup', () => {
            state.tileMouseDown = false;
        });

        // Tile tool buttons
        document.querySelectorAll('[data-tile-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                state.currentTileTool = btn.dataset.tileTool;
                document.querySelectorAll('[data-tile-tool]').forEach(b => {
                    b.classList.toggle('active', b.dataset.tileTool === state.currentTileTool);
                });
            });
        });

        elements.spriteSheetSelect.addEventListener('change', (e) => {
            loadSpriteSheet(e.target.value);
        });

        elements.clearTilesBtn.addEventListener('click', clearVisualTiles);

        // ==========================================
        // Initialize
        // ==========================================
        initGrid();
        initVisualTiles();
        loadSpriteIndex();
    </script>
</body>
</html>
