<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Forge | Mantleborn Dev Tools</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           MANTLEBORN LEVEL-FORGE - CSS
           ============================================ */

        :root {
            /* Backgrounds */
            --bg-deep: #0d0d14;
            --bg-mid: #1a1a2e;
            --bg-surface: #252542;

            /* Accents - ember warmth */
            --accent-ember: #e07020;
            --accent-ember-glow: #ff9040;
            --accent-magma: #c04020;

            /* Stone/neutral tones */
            --stone-dark: #3a3a5c;
            --stone-mid: #6a6a8e;
            --stone-light: #9a9abe;
            --stone-bright: #d0d0e8;

            /* Purple undertones */
            --mystic-deep: #2a1a3e;
            --mystic-glow: #8060c0;

            /* Tile states */
            --tile-undefined: transparent;
            --tile-undefined-hover: rgba(255, 255, 255, 0.05);
            --tile-open: #2a5a30;
            --tile-open-bright: #3a7a40;
            --tile-obstruction: #6a2a2a;
            --tile-obstruction-bright: #8a3a3a;
            --tile-spawn: #2a4a6a;
            --tile-spawn-bright: #3a6a9a;
            --tile-exit: #6a2a6a;
            --tile-exit-bright: #9a4a9a;
            --tile-return: #2a6a6a;
            --tile-return-bright: #4a9a9a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--stone-light);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .home-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            font-size: 18px;
            text-decoration: none;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .home-btn:hover {
            background: var(--stone-dark);
            border-color: var(--accent-ember);
        }

        .brand-icon {
            font-size: 20px;
            animation: flicker 2s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            70% { opacity: 1; }
            75% { opacity: 0.7; }
            80% { opacity: 1; }
        }

        .brand-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .brand-text span {
            color: var(--accent-ember);
            text-shadow: 0 0 10px rgba(224, 112, 32, 0.5);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-select {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-light);
            cursor: pointer;
            min-width: 160px;
        }

        .header-select:focus {
            outline: none;
            border-color: var(--accent-ember);
        }

        .auth-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .auth-indicator.logged-in {
            border-color: var(--tile-open);
            color: var(--stone-light);
        }

        .auth-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--stone-dark);
        }

        .auth-indicator.logged-in .auth-dot {
            background: var(--tile-open-bright);
        }

        /* Buttons */
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--stone-dark);
            border-color: var(--stone-mid);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--mystic-glow);
        }

        .btn-primary {
            background: var(--accent-ember);
            border-color: var(--accent-ember);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--accent-ember-glow);
            border-color: var(--accent-ember-glow);
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
        }

        .btn-danger {
            background: var(--accent-magma);
            border-color: var(--accent-magma);
            color: white;
        }

        .btn-danger:hover {
            background: #d04030;
            border-color: #d04030;
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 320px;
            height: calc(100vh - 53px);
        }

        /* Left Panel - Grid Editor */
        .editor-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 16px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-label {
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-right: 8px;
        }

        .tool-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            padding: 0;
            border-radius: 4px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.15s;
        }

        .tool-btn:hover {
            border-color: var(--stone-mid);
            background: var(--stone-dark);
        }

        .tool-btn.active {
            border-color: var(--accent-ember);
            background: var(--mystic-deep);
            color: var(--accent-ember);
        }

        .state-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            padding: 0;
            border-radius: 4px;
            border: 2px solid var(--stone-dark);
            cursor: pointer;
            transition: all 0.15s;
        }

        .state-btn.active {
            border-color: var(--accent-ember);
            box-shadow: 0 0 8px rgba(224, 112, 32, 0.5);
        }

        .state-btn[data-state="undefined"] {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 8px 8px;
        }

        .state-btn[data-state="open"] {
            background: var(--tile-open);
        }

        .state-btn[data-state="obstruction"] {
            background: var(--tile-obstruction);
        }

        .state-btn[data-state="spawn"] {
            background: var(--tile-spawn);
        }

        .state-btn[data-state="exit"] {
            background: var(--tile-exit);
        }

        .state-btn[data-state="return"] {
            background: var(--tile-return);
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--stone-dark);
        }

        /* Grid Container */
        .grid-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
            background: var(--bg-deep);
        }

        .grid-wrapper {
            position: relative;
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            padding: 2px;
        }

        .grid {
            display: grid;
            gap: 1px;
            background: var(--stone-dark);
        }

        .tile {
            width: 24px;
            height: 24px;
            background: var(--bg-mid);
            cursor: pointer;
            transition: background 0.1s;
            position: relative;
        }

        .tile:hover {
            background: var(--tile-undefined-hover);
        }

        .tile[data-state="open"] {
            background: var(--tile-open);
        }

        .tile[data-state="open"]:hover {
            background: var(--tile-open-bright);
        }

        .tile[data-state="obstruction"] {
            background: var(--tile-obstruction);
        }

        .tile[data-state="obstruction"]:hover {
            background: var(--tile-obstruction-bright);
        }

        .tile[data-state="spawn"] {
            background: var(--tile-spawn);
        }

        .tile[data-state="spawn"]:hover {
            background: var(--tile-spawn-bright);
        }

        .tile[data-state="exit"] {
            background: var(--tile-exit);
        }

        .tile[data-state="exit"]:hover {
            background: var(--tile-exit-bright);
        }

        .tile[data-state="return"] {
            background: var(--tile-return);
        }

        .tile[data-state="return"]:hover {
            background: var(--tile-return-bright);
        }

        /* Direction arrows for portal tiles */
        .tile[data-state="exit"]::after,
        .tile[data-state="return"]::after,
        .tile[data-state="spawn"]::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.7;
        }

        .tile[data-state="exit"]::after {
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid white;
        }

        .tile[data-state="return"]::after {
            border-left: 6px solid white;
            border-right: 6px solid white;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            width: 0;
            height: 0;
        }

        .tile[data-state="spawn"]::after {
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
        }

        /* Direction variants */
        .tile[data-direction="up"]::after {
            border-top: none !important;
            border-bottom: 6px solid white !important;
        }

        .tile[data-direction="left"]::after {
            border-top: 5px solid transparent !important;
            border-bottom: 5px solid transparent !important;
            border-left: none !important;
            border-right: 6px solid white !important;
        }

        .tile[data-direction="right"]::after {
            border-top: 5px solid transparent !important;
            border-bottom: 5px solid transparent !important;
            border-right: none !important;
            border-left: 6px solid white !important;
        }

        .tile.selected {
            outline: 2px solid var(--accent-ember);
            outline-offset: -2px;
            z-index: 1;
        }

        .tile.preview {
            opacity: 0.7;
        }

        /* Selection box */
        .selection-box {
            position: absolute;
            border: 2px dashed var(--accent-ember);
            background: rgba(224, 112, 32, 0.1);
            pointer-events: none;
            display: none;
        }

        /* Right Panel - Settings & Output */
        .right-panel {
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border-left: 1px solid var(--stone-dark);
            overflow: hidden;
            min-height: 0;
        }

        .section {
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .section-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--mystic-glow);
        }

        .form-row {
            display: flex;
            gap: 12px;
        }

        .form-row .form-group {
            flex: 1;
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            padding: 8px;
            background: var(--bg-surface);
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--stone-bright);
        }

        .stat-label {
            font-size: 8px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-top: 4px;
        }

        .stat-item.open .stat-value {
            color: var(--tile-open-bright);
        }

        .stat-item.obstruction .stat-value {
            color: var(--tile-obstruction-bright);
        }

        /* Export Section */
        .export-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            min-height: 0;
            overflow: hidden;
        }

        .export-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .export-actions .btn {
            flex: 1;
        }

        .json-preview {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .json-preview-header {
            padding: 8px 12px;
            background: var(--bg-surface);
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .json-preview-content {
            flex: 1;
            overflow: auto;
            padding: 8px 12px;
            background: var(--bg-deep);
            font-size: 10px;
            line-height: 1.5;
            white-space: pre;
            min-height: 0;
        }

        .json-preview-content::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .json-preview-content::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 3px;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 16px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border-radius: 4px;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            border: 1px solid var(--stone-dark);
        }

        .legend-color.undefined {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 6px 6px;
        }

        .legend-color.open {
            background: var(--tile-open);
        }

        .legend-color.obstruction {
            background: var(--tile-obstruction);
        }

        .legend-color.spawn {
            background: var(--tile-spawn);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 20px;
            background: var(--bg-surface);
            border: 1px solid var(--accent-ember);
            border-radius: 4px;
            font-size: 12px;
            color: var(--stone-bright);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 12px;
            padding: 24px;
            min-width: 360px;
            max-width: 90vw;
        }

        .modal-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--stone-bright);
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Keyboard hints */
        .keyboard-hints {
            font-size: 9px;
            color: var(--stone-dark);
            margin-top: 8px;
        }

        .keyboard-hints kbd {
            padding: 2px 5px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 3px;
            font-family: inherit;
        }

        /* Portal Markers Section */
        .markers-summary {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .marker-stat {
            font-size: 11px;
            color: var(--stone-mid);
        }

        .marker-count {
            font-weight: bold;
            color: var(--stone-light);
        }

        .unconfigured-markers {
            background: var(--bg-surface);
            border-radius: 4px;
            padding: 8px;
        }

        .unconfigured-header {
            font-size: 9px;
            color: var(--stone-dark);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .unconfigured-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .marker-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: var(--bg-mid);
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.15s;
        }

        .marker-item:hover {
            background: var(--bg-deep);
        }

        .marker-item.spawn {
            border-left: 3px solid var(--tile-spawn);
        }

        .marker-item.exit {
            border-left: 3px solid var(--tile-exit);
        }

        .marker-item.return {
            border-left: 3px solid var(--tile-return);
        }

        .marker-icon {
            font-size: 14px;
            opacity: 0.8;
        }

        .marker-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .marker-coords {
            color: var(--stone-dark);
            font-size: 9px;
        }

        .no-markers-message {
            color: var(--stone-dark);
            font-size: 11px;
            text-align: center;
            padding: 8px;
        }

        /* Demo Mode */
        .demo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-deep);
            display: none;
            z-index: 100;
        }

        .demo-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .demo-canvas {
            image-rendering: pixelated;
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
        }

        .demo-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background: rgba(13, 13, 20, 0.9);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 10px;
            color: var(--stone-light);
            z-index: 101;
        }

        .demo-hud-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--accent-ember);
            margin-bottom: 6px;
        }

        .demo-hud-controls {
            line-height: 1.6;
        }

        .demo-hud-controls kbd {
            padding: 1px 4px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 2px;
            font-family: inherit;
            font-size: 9px;
        }

        .demo-exit-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 101;
        }

        .btn-play {
            background: var(--tile-open);
            border-color: var(--tile-open);
            color: white;
        }

        .btn-crucible {
            background: #5a4a2a;
            border-color: #7a6a4a;
            color: #ffa500;
        }

        .btn-crucible:hover {
            background: #6a5a3a;
            border-color: #ffa500;
        }

        .btn-play:hover {
            background: var(--tile-open-bright);
            border-color: var(--tile-open-bright);
        }

        /* ============================================
           TAB SYSTEM
           ============================================ */

        .tab-bar {
            display: flex;
            gap: 2px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .tab-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-mid);
            cursor: pointer;
            transition: all 0.15s;
        }

        .tab-btn:hover {
            background: var(--stone-dark);
            color: var(--stone-light);
        }

        .tab-btn.active {
            background: var(--mystic-deep);
            color: var(--accent-ember);
            border-color: var(--accent-ember);
        }

        .tab-icon {
            font-size: 14px;
        }

        .tab-label {
            font-weight: 500;
        }

        .tab-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            background: var(--bg-deep);
            position: relative;
        }

        .tab-panel {
            display: none;
            flex: 1;
            overflow: auto;
            padding: 20px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .tab-panel.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Grid editor toolbar - only show when grid tab active */
        .grid-toolbar {
            display: none;
        }

        .grid-toolbar.active {
            display: flex;
        }

        /* ============================================
           BACKGROUND EDITOR
           ============================================ */

        .background-editor {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            max-width: 100%;
            align-items: stretch;
        }

        .background-toolbar {
            display: flex;
            gap: 8px;
            padding: 12px;
            background: var(--bg-mid);
            border-radius: 4px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .background-preview-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            overflow: hidden;
            min-height: 300px;
        }

        #backgroundCanvas {
            image-rendering: pixelated;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
        }

        .background-layers {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 12px;
            padding: 8px;
            background: var(--bg-mid);
            border-radius: 4px;
        }

        .bg-layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .bg-layer-item:hover {
            border-color: var(--stone-mid);
        }

        .bg-layer-item.selected {
            border-color: var(--accent-ember);
            background: var(--mystic-deep);
        }

        .bg-layer-thumb {
            width: 40px;
            height: 30px;
            background: var(--bg-deep);
            border-radius: 2px;
            overflow: hidden;
        }

        .bg-layer-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .bg-layer-info {
            flex: 1;
            min-width: 0;
        }

        .bg-layer-name {
            font-size: 11px;
            color: var(--stone-bright);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bg-layer-meta {
            font-size: 9px;
            color: var(--stone-mid);
        }

        .bg-layer-actions {
            display: flex;
            gap: 4px;
        }

        .bg-layer-visibility {
            padding: 4px 6px;
            background: transparent;
            border: none;
            color: var(--stone-mid);
            cursor: pointer;
            font-size: 12px;
        }

        .bg-layer-visibility.hidden {
            opacity: 0.4;
        }

        .bg-layer-delete {
            padding: 4px 6px;
            background: transparent;
            border: none;
            color: var(--accent-magma);
            cursor: pointer;
            font-size: 10px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .bg-layer-item:hover .bg-layer-delete {
            opacity: 1;
        }

        .no-layers-message {
            text-align: center;
            padding: 20px;
            color: var(--stone-mid);
            font-size: 11px;
        }

        /* ============================================
           TILE PAINTER
           ============================================ */

        .tile-painter {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .tile-toolbar {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px;
            background: var(--bg-mid);
            border-radius: 4px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .tile-painter-main {
            display: flex;
            flex: 1;
            gap: 16px;
            min-height: 0;
        }

        .tile-canvas-wrapper {
            flex: 1;
            position: relative;
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #tileCanvas {
            image-rendering: pixelated;
        }

        .sprite-palette {
            width: 240px;
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }

        .palette-header {
            padding: 10px 12px;
            background: var(--bg-surface);
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .palette-sheet-select {
            padding: 8px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .palette-grid {
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .palette-sprite {
            aspect-ratio: 1;
            min-width: 40px;
            min-height: 40px;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 8px 8px;
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            overflow: hidden;
            padding: 4px;
        }

        .palette-sprite:hover {
            border-color: var(--stone-mid);
        }

        .palette-sprite.selected {
            border-color: var(--accent-ember);
            box-shadow: 0 0 8px rgba(224, 112, 32, 0.5);
        }

        .palette-sprite img {
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .no-sprites-message {
            padding: 20px;
            text-align: center;
            color: var(--stone-mid);
            font-size: 10px;
        }

        /* Palette section headers */
        .palette-section-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 7px;
            color: var(--stone-mid);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 8px 8px 6px;
            background: var(--bg-surface);
            border-bottom: 1px solid var(--stone-dark);
        }

        .palette-groups, .palette-tiles {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            padding: 8px;
        }

        /* Group tiles in palette */
        .palette-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 4px;
            background: var(--bg-surface);
            border: 2px solid var(--fire-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .palette-group:hover {
            border-color: var(--fire-mid);
        }

        .palette-group.selected {
            border-color: var(--fire-bright);
            box-shadow: 0 0 8px rgba(239, 138, 23, 0.5);
        }

        .palette-group canvas {
            image-rendering: pixelated;
            max-width: 48px;
            max-height: 48px;
        }

        .palette-group .group-name {
            font-size: 7px;
            color: var(--stone-mid);
            margin-top: 2px;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Contextual settings visibility */
        .tab-settings {
            display: none;
        }

        .tab-settings.active {
            display: block;
        }

        /* Selected sprite preview */
        .selected-sprite-preview {
            display: flex;
            justify-content: center;
            padding: 12px;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            margin-bottom: 12px;
            min-height: 80px;
        }

        .selected-sprite-preview img {
            image-rendering: pixelated;
            max-width: 64px;
            max-height: 64px;
        }

        /* File input styling */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* Range slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-deep);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-ember);
            border-radius: 50%;
            cursor: pointer;
        }

        .range-value {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .range-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .range-row input[type="range"] {
            flex: 1;
        }

        /* Checkbox styling */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-ember);
        }

        .checkbox-group label {
            font-size: 11px;
            color: var(--stone-light);
        }

        /* AI Generation */
        .btn-ai {
            background: linear-gradient(135deg, #3a2a4a, #4a3a5a);
            border-color: var(--mystic-glow);
            color: var(--mystic-glow);
        }

        .btn-ai:hover {
            background: var(--mystic-glow);
            color: white;
        }

        .generation-queue-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 1500;
            display: none;
        }

        .generation-queue-panel.visible {
            display: block;
        }

        .palette-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .palette-header-actions {
            display: flex;
            gap: 4px;
        }

        .btn-tiny {
            font-size: 9px;
            padding: 3px 6px;
        }

        /* Background Library Modal */
        .bg-library-modal {
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .bg-library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            padding: 16px;
            overflow-y: auto;
            flex: 1;
            min-height: 200px;
            max-height: 400px;
            background: var(--bg-deep);
            border-radius: 4px;
        }

        .bg-library-item {
            aspect-ratio: 16/9;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .bg-library-item:hover {
            border-color: var(--accent-ember);
            transform: scale(1.02);
        }

        .bg-library-item.selected {
            border-color: var(--accent-ember);
            box-shadow: 0 0 12px rgba(224, 112, 32, 0.5);
        }

        .bg-library-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            image-rendering: pixelated;
        }

        .bg-library-item-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px 6px;
            background: rgba(0, 0, 0, 0.8);
            font-size: 9px;
            color: var(--stone-light);
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bg-library-empty {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 20px;
            color: var(--stone-mid);
            font-size: 12px;
        }

        .bg-library-empty a {
            color: var(--accent-ember);
            text-decoration: none;
        }

        .bg-library-empty a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="brand">
            <a href="/game-wizard/" class="home-btn" title="Back to Game Wizard">&#128302;</a>
            <span class="brand-icon">&#128293;</span>
            <span class="brand-text">GAME WIZARD / <span>LEVEL-FORGE</span></span>
        </div>
        <div class="header-actions">
            <select class="header-select" id="projectSelect">
                <option value="">-- Select Project --</option>
            </select>
            <button class="btn btn-crucible" id="sendToCrucibleBtn" title="Send to Crucible" disabled>&#129516; Send to Crucible</button>
            <button class="btn btn-play" id="playDemoBtn">&#9658; Play Demo</button>
            <button class="btn" id="newLevelBtn">New Level</button>
            <div class="auth-indicator" id="authIndicator">
                <span class="auth-dot"></span>
                <span class="auth-text">...</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Editor Panel -->
        <div class="editor-panel">
            <!-- Grid Editor Toolbar -->
            <div class="toolbar grid-toolbar active" id="gridToolbar">
                <div class="toolbar-group">
                    <span class="toolbar-label">Tool</span>
                    <button class="tool-btn active" data-tool="paint" title="Paint (P)">&#9998;</button>
                    <button class="tool-btn" data-tool="fill" title="Fill (F)">&#9699;</button>
                    <button class="tool-btn" data-tool="select" title="Select (S)">&#9634;</button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <span class="toolbar-label">State</span>
                    <button class="state-btn" data-state="undefined" title="Undefined (1)">?</button>
                    <button class="state-btn active" data-state="open" title="Open (2)">&#10003;</button>
                    <button class="state-btn" data-state="obstruction" title="Obstruction (3)">&#10005;</button>
                    <button class="state-btn" data-state="spawn" title="Spawn Point (4)">&#9679;</button>
                    <button class="state-btn" data-state="exit" title="Exit (5)">&#10132;</button>
                    <button class="state-btn" data-state="return" title="Return (6)">&#8644;</button>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <button class="btn btn-small btn-danger" id="clearGridBtn">Clear All</button>
                </div>
            </div>

            <!-- Tab Content -->
            <div class="tab-content">
                <!-- Grid Editor Panel -->
                <div class="tab-panel active" id="gridPanel">
                    <div class="grid-wrapper">
                        <div class="grid" id="grid"></div>
                        <div class="selection-box" id="selectionBox"></div>
                    </div>

                    <!-- Demo Mode Overlay -->
                    <div class="demo-overlay" id="demoOverlay">
                        <canvas class="demo-canvas" id="demoCanvas"></canvas>
                        <div class="demo-hud" id="demoHud">
                            <div class="demo-hud-title">DEMO MODE</div>
                            <div class="demo-hud-controls" id="demoControls"></div>
                        </div>
                        <button class="btn btn-danger demo-exit-btn" id="exitDemoBtn">Exit Demo</button>
                    </div>
                </div>

                <!-- Background Editor Panel -->
                <div class="tab-panel" id="backgroundPanel">
                    <div class="background-editor">
                        <div class="background-toolbar">
                            <div class="file-input-wrapper">
                                <button class="btn btn-small">+ Add Layer</button>
                                <input type="file" id="bgFileInput" accept="image/*">
                            </div>
                            <button class="btn btn-small btn-ai" id="fromLibraryBtn">From Library</button>
                            <button class="btn btn-small" id="pixelifyBtn" disabled>Pixelify</button>
                        </div>
                        <div class="background-preview-wrapper">
                            <canvas id="backgroundCanvas"></canvas>
                        </div>
                        <div class="background-layers" id="backgroundLayers">
                            <div class="no-layers-message">No background layers. Click "+ Add Layer" to upload an image.<br><br>Recommended: 768x432px (32x18 tiles at 24px)</div>
                        </div>
                    </div>
                </div>

                <!-- Tile Painter Panel -->
                <div class="tab-panel" id="tilesPanel">
                    <div class="tile-painter">
                        <div class="tile-toolbar">
                            <div class="toolbar-group">
                                <span class="toolbar-label">Tool</span>
                                <button class="tool-btn active" data-tile-tool="paint" title="Paint (P)">&#9998;</button>
                                <button class="tool-btn" data-tile-tool="erase" title="Erase (E)">&#9003;</button>
                                <button class="tool-btn" data-tile-tool="fill" title="Fill (F)">&#9699;</button>
                            </div>
                            <div class="toolbar-divider"></div>
                            <div class="toolbar-group">
                                <button class="btn btn-small btn-danger" id="clearTilesBtn">Clear Tiles</button>
                            </div>
                        </div>
                        <div class="tile-painter-main">
                            <div class="tile-canvas-wrapper">
                                <canvas id="tileCanvas"></canvas>
                            </div>
                            <div class="sprite-palette">
                                <div class="palette-header">
                                    <span>Tile Palette</span>
                                    <div class="palette-header-actions">
                                        <button class="btn btn-tiny btn-ai" id="generateTilesetBtn" title="Generate tileset with AI">&#10024;</button>
                                    </div>
                                </div>
                                <div class="palette-sheet-select">
                                    <select class="form-input" id="spriteSheetSelect">
                                        <option value="">-- Select Sheet --</option>
                                    </select>
                                </div>
                                <div class="palette-grid" id="paletteGrid">
                                    <div class="no-sprites-message">Select a tile sheet to load tiles</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Tab Bar -->
            <div class="tab-bar">
                <button class="tab-btn active" data-tab="grid" title="Grid Editor">
                    <span class="tab-icon">&#9638;</span>
                    <span class="tab-label">Grid</span>
                </button>
                <button class="tab-btn" data-tab="background" title="Background Editor">
                    <span class="tab-icon">&#127748;</span>
                    <span class="tab-label">BG</span>
                </button>
                <button class="tab-btn" data-tab="tiles" title="Tile Painter">
                    <span class="tab-icon">&#127912;</span>
                    <span class="tab-label">Tiles</span>
                </button>
            </div>

            <!-- Grid Settings -->
            <div class="section">
                <div class="section-header">Grid Settings</div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Width (tiles)</label>
                        <input type="number" class="form-input" id="gridWidth" value="32" min="4" max="100">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Height (tiles)</label>
                        <input type="number" class="form-input" id="gridHeight" value="18" min="4" max="100">
                    </div>
                </div>
                <button class="btn btn-small" id="resizeGridBtn" style="width: 100%;">Resize Grid</button>
                <div class="tile-size-info" id="tileSizeInfo" style="margin-top: 8px; font-size: 10px; color: var(--stone-mid); text-align: center;">
                    Tile Size: <span id="tileSizeDisplay">16</span>px (from project)
                </div>
            </div>

            <!-- Level Info (Grid Tab) -->
            <div class="section tab-settings active" id="gridSettings">
                <div class="section-header">Level Info</div>
                <div class="form-group">
                    <label class="form-label">Level Name</label>
                    <input type="text" class="form-input" id="levelName" placeholder="level_01">
                </div>

                <div class="form-group">
                    <label class="form-label">Level Type</label>
                    <select class="form-input" id="levelType">
                        <option value="platformer">Platformer (side-scroll, gravity)</option>
                        <option value="topdown">Top-Down (free movement, no gravity)</option>
                    </select>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color undefined"></div>
                        <span>Undefined</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color open"></div>
                        <span>Open</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color obstruction"></div>
                        <span>Obstruction</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color spawn"></div>
                        <span>Spawn</span>
                    </div>
                </div>

                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="totalTiles">576</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="undefinedTiles">576</div>
                        <div class="stat-label">Undefined</div>
                    </div>
                    <div class="stat-item open">
                        <div class="stat-value" id="openTiles">0</div>
                        <div class="stat-label">Open</div>
                    </div>
                    <div class="stat-item obstruction">
                        <div class="stat-value" id="obstructionTiles">0</div>
                        <div class="stat-label">Obstruction</div>
                    </div>
                </div>

                <div class="keyboard-hints">
                    <kbd>P</kbd> Paint &nbsp;
                    <kbd>F</kbd> Fill &nbsp;
                    <kbd>S</kbd> Select<br>
                    <kbd>1</kbd> Undefined &nbsp;
                    <kbd>2</kbd> Open &nbsp;
                    <kbd>3</kbd> Obstruction &nbsp;
                    <kbd>4</kbd> Spawn
                </div>
            </div>

            <!-- Background Settings -->
            <div class="section tab-settings" id="bgSettings">
                <div class="section-header">Layer Settings</div>
                <div id="bgLayerSettings">
                    <div class="no-layers-message">Select a layer to edit its settings</div>
                </div>
                <div id="bgLayerControls" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Layer Name</label>
                        <input type="text" class="form-input" id="bgLayerName" placeholder="background_01">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Depth</label>
                            <input type="number" class="form-input" id="bgDepth" value="0" min="-100" max="100">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Scroll Rate</label>
                            <input type="number" class="form-input" id="bgScrollRate" value="1" min="0" max="2" step="0.1">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">X Offset</label>
                            <input type="number" class="form-input" id="bgOffsetX" value="0">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Y Offset</label>
                            <input type="number" class="form-input" id="bgOffsetY" value="0">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Scale</label>
                        <div class="range-row">
                            <input type="range" id="bgScale" value="1" min="0.25" max="4" step="0.25">
                            <span class="range-value" id="bgScaleValue">1x</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pixelify Settings -->
            <div class="section tab-settings" id="pixelifySettings">
                <div class="section-header">Retro Pixelify</div>
                <div class="form-group">
                    <label class="form-label">Target Resolution</label>
                    <select class="form-input" id="targetResolution">
                        <option value="320x180">320180 (Mantleborn)</option>
                        <option value="320x224">320224 (Genesis)</option>
                        <option value="256x224">256224 (SNES)</option>
                        <option value="160x144">160144 (Game Boy)</option>
                        <option value="256x192">256192 (Master System)</option>
                        <option value="custom">Custom...</option>
                    </select>
                </div>
                <div class="form-group custom-res-group" id="customResGroup" style="display: none;">
                    <div class="range-row" style="gap: 4px;">
                        <input type="number" class="form-input" id="customWidth" value="320" min="16" max="1920" style="width: 70px;">
                        <span></span>
                        <input type="number" class="form-input" id="customHeight" value="180" min="16" max="1080" style="width: 70px;">
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Palette Colors</label>
                    <div class="range-row">
                        <input type="range" id="paletteColors" value="16" min="4" max="64" step="4">
                        <span class="range-value" id="paletteColorsValue">16</span>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Dithering</label>
                    <select class="form-input" id="ditherMode">
                        <option value="none">None</option>
                        <option value="bayer2">Bayer 22 (Subtle)</option>
                        <option value="bayer4" selected>Bayer 44 (Classic)</option>
                        <option value="bayer8">Bayer 88 (Strong)</option>
                        <option value="floyd">Floyd-Steinberg</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Dither Strength</label>
                    <div class="range-row">
                        <input type="range" id="ditherStrength" value="32" min="8" max="64">
                        <span class="range-value" id="ditherStrengthValue">32</span>
                    </div>
                </div>
                <button class="btn btn-primary" id="applyPixelify" style="width: 100%;">Apply Retro Effect</button>
                <button class="btn btn-small" id="resetPixelify" style="width: 100%; margin-top: 8px;">Reset to Original</button>
            </div>

            <!-- Tile Painter Settings -->
            <div class="section tab-settings" id="tileSettings">
                <div class="section-header">Selected Tile</div>
                <div class="selected-sprite-preview" id="selectedSpritePreview">
                    <span class="no-sprites-message">No tile selected</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Tile Name</label>
                    <input type="text" class="form-input" id="selectedSpriteName" readonly value="None">
                </div>
                <div class="keyboard-hints">
                    <kbd>P</kbd> Paint &nbsp;
                    <kbd>E</kbd> Erase &nbsp;
                    <kbd>F</kbd> Fill
                </div>
            </div>

            <!-- Portal Markers -->
            <div class="section" id="portalMarkersSection">
                <div class="section-header">Portal Markers</div>
                <div class="markers-summary" id="markersSummary">
                    <div class="marker-stat"><span class="marker-count" id="spawnCountDisplay">0</span> spawns</div>
                    <div class="marker-stat"><span class="marker-count" id="exitCountDisplay">0</span> exits</div>
                    <div class="marker-stat"><span class="marker-count" id="returnCountDisplay">0</span> returns</div>
                </div>
                <div class="unconfigured-markers" id="unconfiguredMarkers">
                    <div class="unconfigured-header">Unconfigured (configure in Portals)</div>
                    <div class="unconfigured-list" id="unconfiguredList">
                        <div class="no-markers-message">All markers configured</div>
                    </div>
                </div>
                <div class="keyboard-hints" style="margin-top: 8px;">
                    <kbd>Right-click</kbd> Cycle direction
                </div>
            </div>

            <!-- Export -->
            <div class="export-section">
                <div class="export-actions">
                    <button class="btn btn-primary" id="copyJsonBtn">Copy JSON</button>
                    <button class="btn" id="loadJsonBtn">Load JSON</button>
                </div>
                <div class="json-preview">
                    <div class="json-preview-header">JSON Output</div>
                    <div class="json-preview-content" id="jsonOutput">{}</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Crucible Modal -->
    <div class="modal-overlay" id="crucibleModal">
        <div class="modal">
            <div class="modal-header">Send to Crucible</div>
            <div class="form-group">
                <label class="form-label">Project</label>
                <div class="form-input" id="crucibleProjectName" style="background: var(--bg-mid); cursor: default;">No project selected</div>
            </div>
            <div class="form-group">
                <label class="form-label">Level</label>
                <select class="form-input" id="crucibleLevelSelect" disabled>
                    <option value="">Select a level...</option>
                </select>
            </div>
            <div class="crucible-status" id="crucibleStatus" style="margin-bottom: 16px; font-size: 11px; color: var(--stone-mid);"></div>
            <div class="modal-actions">
                <button class="btn" id="cancelCrucibleBtn">Cancel</button>
                <button class="btn btn-crucible" id="confirmCrucibleBtn" disabled>Send Data</button>
            </div>
        </div>
    </div>

    <!-- Background Library Modal -->
    <div class="modal-overlay" id="bgLibraryModal">
        <div class="modal bg-library-modal">
            <div class="modal-header">Background Library</div>
            <div class="bg-library-grid" id="bgLibraryGrid">
                <div class="bg-library-empty">Loading...</div>
            </div>
            <div class="modal-actions">
                <button class="btn" id="cancelBgLibraryBtn">Cancel</button>
                <button class="btn btn-primary" id="addFromLibraryBtn" disabled>Add to Level</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Generation Queue Panel -->
    <div class="generation-queue-panel" id="generationQueuePanel"></div>

    <!-- Supabase Client -->
    <script src="../shared/supabase-client.js"></script>
    <script src="../shared/project-gate.js"></script>
    <script src="../shared/master-sheet.js"></script>
    <script src="../shared/pixellab-client.js"></script>
    <script src="../shared/generation-queue.js"></script>
    <script src="../shared/help-drawer.js"></script>
    <script src="../shared/docs/level-forge-docs.js"></script>

    <script>
        /* ============================================
           MANTLEBORN LEVEL-FORGE - JavaScript
           ============================================ */

        // ==========================================
        // State
        // ==========================================
        const state = {
            // Grid settings
            gridWidth: 32,
            gridHeight: 18,
            tileSize: 16,  // Loaded from project settings
            levelType: 'platformer',  // 'platformer' | 'topdown'
            tiles: [],  // 2D array of tile states: 'undefined' | 'open' | 'obstruction' | 'spawn'

            // Grid editor state
            currentTool: 'paint',
            currentState: 'open',
            isMouseDown: false,
            selectionStart: null,
            selectionEnd: null,
            selectedTiles: new Set(),

            // Tab state
            activeTab: 'grid',  // 'grid' | 'background' | 'tiles'

            // Background editor state
            backgrounds: [],  // Array of background layer objects
            selectedBgLayer: -1,
            pixelifySettings: {
                targetRes: '320x180',
                customWidth: 320,
                customHeight: 180,
                paletteColors: 16,
                ditherMode: 'bayer4',
                ditherStrength: 32
            },

            // Tile painter state
            visualTiles: [],  // 2D array parallel to collision grid
            selectedSprite: null,
            currentTileTool: 'paint',  // 'paint' | 'erase' | 'fill'
            spriteSheets: {},  // Loaded sprite sheet data
            spriteImages: {},  // Loaded sprite sheet images
            selectedSpriteSheet: '',
            masterTileSheetAtlas: null,   // Master tile sheet atlas
            masterTileSheetImage: null,   // Master tile sheet image
            masterSpriteSheetAtlas: null, // Master sprite sheet atlas
            masterSpriteSheetImage: null, // Master sprite sheet image
            tileGroups: [],          // Tile groups from database
            selectedGroup: null,     // Currently selected group (for multi-tile stamp)
            currentProjectId: null,  // Currently selected project for master sheet
            tileMouseDown: false,

            // Background drag state
            bgDragging: false,
            bgDragStart: { x: 0, y: 0 },
            bgDragLayerStart: { x: 0, y: 0 },

            // Background library state
            bgLibrary: {},           // Atlas of saved backgrounds
            bgLibrarySheet: null,    // Master background sheet image
            selectedLibraryBg: null, // Selected background name in modal

            // Portal metadata (spawns, exits, returns)
            spawnMetadata: {},   // { "x,y": { name, direction, isPrimary } }
            exitMetadata: {},    // { "x,y": { name, direction, type } }
            returnMetadata: {},  // { "x,y": { name, direction } }
            spawnCount: 0,
            exitCount: 0,
            returnCount: 0,

            // AI Generation
            generationQueue: null,

            // Auth
            user: null
        };

        const TILE_STATES = ['undefined', 'open', 'obstruction', 'spawn', 'exit', 'return'];

        // ==========================================
        // DOM Elements
        // ==========================================
        const elements = {
            // Header
            projectSelect: document.getElementById('projectSelect'),
            sendToCrucibleBtn: document.getElementById('sendToCrucibleBtn'),
            authIndicator: document.getElementById('authIndicator'),

            // Grid editor
            grid: document.getElementById('grid'),
            selectionBox: document.getElementById('selectionBox'),
            gridWidth: document.getElementById('gridWidth'),
            gridHeight: document.getElementById('gridHeight'),
            resizeGridBtn: document.getElementById('resizeGridBtn'),
            levelName: document.getElementById('levelName'),
            levelType: document.getElementById('levelType'),
            totalTiles: document.getElementById('totalTiles'),
            undefinedTiles: document.getElementById('undefinedTiles'),
            openTiles: document.getElementById('openTiles'),
            obstructionTiles: document.getElementById('obstructionTiles'),
            copyJsonBtn: document.getElementById('copyJsonBtn'),
            loadJsonBtn: document.getElementById('loadJsonBtn'),
            clearGridBtn: document.getElementById('clearGridBtn'),
            newLevelBtn: document.getElementById('newLevelBtn'),
            jsonOutput: document.getElementById('jsonOutput'),
            toast: document.getElementById('toast'),
            gridToolbar: document.getElementById('gridToolbar'),

            // Demo mode
            playDemoBtn: document.getElementById('playDemoBtn'),
            demoOverlay: document.getElementById('demoOverlay'),
            demoCanvas: document.getElementById('demoCanvas'),
            demoControls: document.getElementById('demoControls'),
            exitDemoBtn: document.getElementById('exitDemoBtn'),

            // Tab panels
            gridPanel: document.getElementById('gridPanel'),
            backgroundPanel: document.getElementById('backgroundPanel'),
            tilesPanel: document.getElementById('tilesPanel'),

            // Background editor
            bgFileInput: document.getElementById('bgFileInput'),
            fromLibraryBtn: document.getElementById('fromLibraryBtn'),
            pixelifyBtn: document.getElementById('pixelifyBtn'),
            backgroundCanvas: document.getElementById('backgroundCanvas'),
            backgroundLayers: document.getElementById('backgroundLayers'),

            // Background library modal
            bgLibraryModal: document.getElementById('bgLibraryModal'),
            bgLibraryGrid: document.getElementById('bgLibraryGrid'),
            cancelBgLibraryBtn: document.getElementById('cancelBgLibraryBtn'),
            addFromLibraryBtn: document.getElementById('addFromLibraryBtn'),
            bgLayerControls: document.getElementById('bgLayerControls'),
            bgLayerName: document.getElementById('bgLayerName'),
            bgDepth: document.getElementById('bgDepth'),
            bgScrollRate: document.getElementById('bgScrollRate'),
            bgOffsetX: document.getElementById('bgOffsetX'),
            bgOffsetY: document.getElementById('bgOffsetY'),
            bgScale: document.getElementById('bgScale'),
            bgScaleValue: document.getElementById('bgScaleValue'),
            targetResolution: document.getElementById('targetResolution'),
            customResGroup: document.getElementById('customResGroup'),
            customWidth: document.getElementById('customWidth'),
            customHeight: document.getElementById('customHeight'),
            paletteColors: document.getElementById('paletteColors'),
            paletteColorsValue: document.getElementById('paletteColorsValue'),
            ditherMode: document.getElementById('ditherMode'),
            ditherStrength: document.getElementById('ditherStrength'),
            ditherStrengthValue: document.getElementById('ditherStrengthValue'),
            applyPixelify: document.getElementById('applyPixelify'),
            resetPixelify: document.getElementById('resetPixelify'),

            // Tile painter
            tileCanvas: document.getElementById('tileCanvas'),
            spriteSheetSelect: document.getElementById('spriteSheetSelect'),
            paletteGrid: document.getElementById('paletteGrid'),
            selectedSpritePreview: document.getElementById('selectedSpritePreview'),
            selectedSpriteName: document.getElementById('selectedSpriteName'),
            clearTilesBtn: document.getElementById('clearTilesBtn'),
            tileSizeDisplay: document.getElementById('tileSizeDisplay'),

            // Tab settings panels
            gridSettings: document.getElementById('gridSettings'),
            bgSettings: document.getElementById('bgSettings'),
            pixelifySettings: document.getElementById('pixelifySettings'),
            tileSettings: document.getElementById('tileSettings'),

            // Portal markers
            portalMarkersSection: document.getElementById('portalMarkersSection'),
            spawnCountDisplay: document.getElementById('spawnCountDisplay'),
            exitCountDisplay: document.getElementById('exitCountDisplay'),
            returnCountDisplay: document.getElementById('returnCountDisplay'),
            unconfiguredList: document.getElementById('unconfiguredList'),

            // AI Generation
            generateTilesetBtn: document.getElementById('generateTilesetBtn'),
            generationQueuePanel: document.getElementById('generationQueuePanel')
        };

        // ==========================================
        // Utilities
        // ==========================================
        function showToast(message) {
            elements.toast.textContent = message;
            elements.toast.classList.add('show');
            setTimeout(() => elements.toast.classList.remove('show'), 2500);
        }

        function updateAuthIndicator() {
            const indicator = elements.authIndicator;
            const textEl = indicator.querySelector('.auth-text');

            if (state.user) {
                const name = state.user.user_metadata?.display_name || state.user.email?.split('@')[0] || 'User';
                indicator.classList.add('logged-in');
                textEl.textContent = name;
            } else {
                indicator.classList.remove('logged-in');
                textEl.textContent = 'Guest';
            }
        }

        // ==========================================
        // Grid Management
        // ==========================================
        function initGrid() {
            state.tiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    row.push('undefined');
                }
                state.tiles.push(row);
            }
            // Also initialize visual tiles if not already done
            if (state.visualTiles.length === 0) {
                for (let y = 0; y < state.gridHeight; y++) {
                    const row = [];
                    for (let x = 0; x < state.gridWidth; x++) {
                        row.push(null);
                    }
                    state.visualTiles.push(row);
                }
            }
            renderGrid();
            updateStats();
            updateJsonOutput();
        }

        function renderGrid() {
            elements.grid.innerHTML = '';
            elements.grid.style.gridTemplateColumns = `repeat(${state.gridWidth}, 24px)`;
            elements.grid.style.gridTemplateRows = `repeat(${state.gridHeight}, 24px)`;

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.x = x;
                    tile.dataset.y = y;

                    const tileState = state.tiles[y][x];
                    if (tileState !== 'undefined') {
                        tile.dataset.state = tileState;
                    }

                    // Mouse events
                    tile.addEventListener('mousedown', handleTileMouseDown);
                    tile.addEventListener('mouseenter', handleTileMouseEnter);
                    tile.addEventListener('mouseup', handleTileMouseUp);
                    tile.addEventListener('contextmenu', (e) => e.preventDefault());

                    elements.grid.appendChild(tile);
                }
            }
        }

        function resizeGrid() {
            const newWidth = parseInt(elements.gridWidth.value) || 32;
            const newHeight = parseInt(elements.gridHeight.value) || 18;

            // Clamp values
            state.gridWidth = Math.max(4, Math.min(100, newWidth));
            state.gridHeight = Math.max(4, Math.min(100, newHeight));

            elements.gridWidth.value = state.gridWidth;
            elements.gridHeight.value = state.gridHeight;

            // Resize tiles array, preserving existing data where possible
            const newTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.tiles[y] && state.tiles[y][x]) {
                        row.push(state.tiles[y][x]);
                    } else {
                        row.push('undefined');
                    }
                }
                newTiles.push(row);
            }
            state.tiles = newTiles;

            // Resize visual tiles array too
            const newVisualTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.visualTiles[y] && state.visualTiles[y][x]) {
                        row.push(state.visualTiles[y][x]);
                    } else {
                        row.push(null);
                    }
                }
                newVisualTiles.push(row);
            }
            state.visualTiles = newVisualTiles;

            renderGrid();
            renderTileCanvas();
            renderBackgroundPreview();
            updateStats();
            updateJsonOutput();
            showToast(`Grid resized to ${state.gridWidth}x${state.gridHeight}`);
        }

        function clearGrid() {
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    state.tiles[y][x] = 'undefined';
                }
            }
            renderGrid();
            updateStats();
            updateJsonOutput();
            showToast('Grid cleared');
        }

        // ==========================================
        // Tile Operations
        // ==========================================
        function setTileState(x, y, newState) {
            if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;

            const key = `${x},${y}`;
            const oldState = state.tiles[y][x];
            const levelName = elements.levelName.value.trim().toLowerCase().replace(/[^a-z0-9]+/g, '_') || 'untitled';

            // Clean up old metadata when changing state
            if (oldState !== newState) {
                if (oldState === 'spawn' && state.spawnMetadata[key]) {
                    delete state.spawnMetadata[key];
                } else if (oldState === 'exit' && state.exitMetadata[key]) {
                    delete state.exitMetadata[key];
                } else if (oldState === 'return' && state.returnMetadata[key]) {
                    delete state.returnMetadata[key];
                }
            }

            // Handle portal tiles - require level name and generate metadata
            if (newState === 'spawn' || newState === 'exit' || newState === 'return') {
                if (!elements.levelName.value.trim()) {
                    showToast('Name the level before placing portal markers');
                    return;
                }

                if (newState === 'spawn' && !state.spawnMetadata[key]) {
                    state.spawnCount++;
                    state.spawnMetadata[key] = {
                        name: `${levelName}_spawn_${state.spawnCount}`,
                        direction: 'down',
                        isPrimary: Object.keys(state.spawnMetadata).length === 0
                    };
                } else if (newState === 'exit' && !state.exitMetadata[key]) {
                    state.exitCount++;
                    state.exitMetadata[key] = {
                        name: `${levelName}_exit_${state.exitCount}`,
                        direction: 'down',
                        type: 'exit'
                    };
                } else if (newState === 'return' && !state.returnMetadata[key]) {
                    state.returnCount++;
                    state.returnMetadata[key] = {
                        name: `${levelName}_return_${state.returnCount}`,
                        direction: 'down'
                    };
                }
            }

            state.tiles[y][x] = newState;

            // Update DOM
            const tile = getTileElement(x, y);
            if (tile) {
                if (newState === 'undefined') {
                    delete tile.dataset.state;
                    delete tile.dataset.direction;
                } else {
                    tile.dataset.state = newState;
                    // Set direction for portal tiles
                    const meta = state.spawnMetadata[key] || state.exitMetadata[key] || state.returnMetadata[key];
                    if (meta) {
                        tile.dataset.direction = meta.direction;
                    }
                }
            }
        }

        function cyclePortalDirection(x, y) {
            const key = `${x},${y}`;
            const meta = state.spawnMetadata[key] || state.exitMetadata[key] || state.returnMetadata[key];
            if (!meta) return;

            const directions = ['down', 'right', 'up', 'left'];
            const currentIndex = directions.indexOf(meta.direction);
            meta.direction = directions[(currentIndex + 1) % directions.length];

            const tile = getTileElement(x, y);
            if (tile) {
                tile.dataset.direction = meta.direction;
            }
            updateJsonOutput();
        }

        function getTileElement(x, y) {
            return elements.grid.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        }

        function cycleTileState(x, y) {
            const currentState = state.tiles[y][x];
            const currentIndex = TILE_STATES.indexOf(currentState);
            const nextIndex = (currentIndex + 1) % TILE_STATES.length;
            setTileState(x, y, TILE_STATES[nextIndex]);
        }

        // Flood fill algorithm
        function floodFill(startX, startY, fillState) {
            const originalState = state.tiles[startY][startX];
            if (originalState === fillState) return; // Already the target state

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) continue;
                if (state.tiles[y][x] !== originalState) continue;

                visited.add(key);
                setTileState(x, y, fillState);

                // Add adjacent tiles (4-directional)
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
        }

        // ==========================================
        // Mouse Handlers
        // ==========================================
        function handleTileMouseDown(e) {
            e.preventDefault();

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);

            // Right-click to cycle portal direction
            if (e.button === 2) {
                const tileState = state.tiles[y][x];
                if (tileState === 'spawn' || tileState === 'exit' || tileState === 'return') {
                    cyclePortalDirection(x, y);
                }
                return;
            }

            state.isMouseDown = true;

            if (state.currentTool === 'paint') {
                // Cycle through states on click
                cycleTileState(x, y);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'fill') {
                floodFill(x, y, state.currentState);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'select') {
                state.selectionStart = { x, y };
                state.selectionEnd = { x, y };
                state.selectedTiles.clear();
                updateSelectionBox();
            }
        }

        function handleTileMouseEnter(e) {
            if (!state.isMouseDown) return;

            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);

            if (state.currentTool === 'paint') {
                // Paint with current state while dragging
                setTileState(x, y, state.currentState);
                updateStats();
                updateJsonOutput();
            } else if (state.currentTool === 'select') {
                state.selectionEnd = { x, y };
                updateSelectionBox();
            }
        }

        function handleTileMouseUp(e) {
            if (state.currentTool === 'select' && state.selectionStart && state.selectionEnd) {
                applySelectionFill();
            }
            state.isMouseDown = false;
        }

        // Global mouse up handler
        document.addEventListener('mouseup', () => {
            if (state.currentTool === 'select' && state.isMouseDown && state.selectionStart && state.selectionEnd) {
                applySelectionFill();
            }
            state.isMouseDown = false;
            elements.selectionBox.style.display = 'none';
        });

        // ==========================================
        // Selection
        // ==========================================
        function updateSelectionBox() {
            if (!state.selectionStart || !state.selectionEnd) {
                elements.selectionBox.style.display = 'none';
                return;
            }

            const minX = Math.min(state.selectionStart.x, state.selectionEnd.x);
            const maxX = Math.max(state.selectionStart.x, state.selectionEnd.x);
            const minY = Math.min(state.selectionStart.y, state.selectionEnd.y);
            const maxY = Math.max(state.selectionStart.y, state.selectionEnd.y);

            const tileSize = 25; // 24px + 1px gap

            elements.selectionBox.style.display = 'block';
            elements.selectionBox.style.left = (minX * tileSize + 2) + 'px';
            elements.selectionBox.style.top = (minY * tileSize + 2) + 'px';
            elements.selectionBox.style.width = ((maxX - minX + 1) * tileSize - 1) + 'px';
            elements.selectionBox.style.height = ((maxY - minY + 1) * tileSize - 1) + 'px';

            // Highlight selected tiles
            clearTileHighlights();
            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const tile = getTileElement(x, y);
                    if (tile) tile.classList.add('selected');
                }
            }
        }

        function applySelectionFill() {
            if (!state.selectionStart || !state.selectionEnd) return;

            const minX = Math.min(state.selectionStart.x, state.selectionEnd.x);
            const maxX = Math.max(state.selectionStart.x, state.selectionEnd.x);
            const minY = Math.min(state.selectionStart.y, state.selectionEnd.y);
            const maxY = Math.max(state.selectionStart.y, state.selectionEnd.y);

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    setTileState(x, y, state.currentState);
                }
            }

            clearTileHighlights();
            state.selectionStart = null;
            state.selectionEnd = null;
            elements.selectionBox.style.display = 'none';

            updateStats();
            updateJsonOutput();
        }

        function clearTileHighlights() {
            document.querySelectorAll('.tile.selected').forEach(tile => {
                tile.classList.remove('selected');
            });
        }

        // ==========================================
        // Tool & State Selection
        // ==========================================
        function setTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            clearTileHighlights();
            elements.selectionBox.style.display = 'none';
        }

        function setState(newState) {
            state.currentState = newState;
            document.querySelectorAll('.state-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.state === newState);
            });
        }

        // Tool button click handlers
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => setTool(btn.dataset.tool));
        });

        // State button click handlers
        document.querySelectorAll('.state-btn').forEach(btn => {
            btn.addEventListener('click', () => setState(btn.dataset.state));
        });

        // ==========================================
        // Stats
        // ==========================================
        function updateTileSizeDisplay() {
            if (elements.tileSizeDisplay) {
                elements.tileSizeDisplay.textContent = state.tileSize;
            }
        }

        function updateStats() {
            let undefinedCount = 0;
            let openCount = 0;
            let obstructionCount = 0;
            let spawnCount = 0;
            let exitCount = 0;
            let returnCount = 0;

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'undefined') undefinedCount++;
                    else if (tileState === 'open') openCount++;
                    else if (tileState === 'obstruction') obstructionCount++;
                    else if (tileState === 'spawn') spawnCount++;
                    else if (tileState === 'exit') exitCount++;
                    else if (tileState === 'return') returnCount++;
                }
            }

            const total = state.gridWidth * state.gridHeight;

            elements.totalTiles.textContent = total;
            elements.undefinedTiles.textContent = undefinedCount;
            // Include spawn, exit, return in the "open" count since they're walkable
            elements.openTiles.textContent = openCount + spawnCount + exitCount + returnCount;
            elements.obstructionTiles.textContent = obstructionCount;

            // Update portal markers section
            updatePortalMarkers();
        }

        function updatePortalMarkers() {
            const spawnCount = Object.keys(state.spawnMetadata).length;
            const exitCount = Object.keys(state.exitMetadata).length;
            const returnCount = Object.keys(state.returnMetadata).length;

            elements.spawnCountDisplay.textContent = spawnCount;
            elements.exitCountDisplay.textContent = exitCount;
            elements.returnCountDisplay.textContent = returnCount;

            // Build unconfigured list
            // For now, exits and returns are always "unconfigured" until linked in Portals
            // Spawns don't need configuration
            const unconfigured = [];

            Object.entries(state.exitMetadata).forEach(([key, meta]) => {
                const [x, y] = key.split(',').map(Number);
                unconfigured.push({
                    type: 'exit',
                    name: meta.name,
                    x, y,
                    direction: meta.direction
                });
            });

            Object.entries(state.returnMetadata).forEach(([key, meta]) => {
                const [x, y] = key.split(',').map(Number);
                unconfigured.push({
                    type: 'return',
                    name: meta.name,
                    x, y,
                    direction: meta.direction
                });
            });

            if (unconfigured.length === 0) {
                elements.unconfiguredList.innerHTML = '<div class="no-markers-message">No exits or returns placed</div>';
                return;
            }

            elements.unconfiguredList.innerHTML = unconfigured.map(m => `
                <div class="marker-item ${m.type}" data-x="${m.x}" data-y="${m.y}">
                    <span class="marker-icon">${m.type === 'exit' ? '&#10132;' : '&#8644;'}</span>
                    <span class="marker-name">${m.name}</span>
                    <span class="marker-coords">(${m.x}, ${m.y})</span>
                </div>
            `).join('');

            // Add click handlers to scroll to the marker
            elements.unconfiguredList.querySelectorAll('.marker-item').forEach(item => {
                item.addEventListener('click', () => {
                    const x = parseInt(item.dataset.x);
                    const y = parseInt(item.dataset.y);
                    const tile = getTileElement(x, y);
                    if (tile) {
                        tile.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // Flash the tile
                        tile.style.outline = '2px solid var(--accent-ember)';
                        setTimeout(() => { tile.style.outline = ''; }, 1000);
                    }
                });
            });
        }

        // ==========================================
        // JSON Export/Import
        // ==========================================
        function generateLevelData() {
            const levelName = elements.levelName.value || 'untitled';
            const levelType = state.levelType;

            // Encode tiles - we'll use a compact format
            // 0 = undefined, 1 = open, 2 = obstruction, 3 = spawn, 4 = exit, 5 = return
            const tileData = [];

            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'undefined') row.push(0);
                    else if (tileState === 'open') row.push(1);
                    else if (tileState === 'obstruction') row.push(2);
                    else if (tileState === 'spawn') row.push(3);
                    else if (tileState === 'exit') row.push(4);
                    else if (tileState === 'return') row.push(5);
                }
                tileData.push(row);
            }

            // Collect spawn points with metadata
            const spawns = [];
            Object.entries(state.spawnMetadata).forEach(([key, meta]) => {
                const [x, y] = key.split(',').map(Number);
                spawns.push({
                    x, y,
                    name: meta.name,
                    direction: meta.direction,
                    isPrimary: meta.isPrimary
                });
            });

            // Collect exits with metadata
            const exits = [];
            Object.entries(state.exitMetadata).forEach(([key, meta]) => {
                const [x, y] = key.split(',').map(Number);
                exits.push({
                    x, y,
                    name: meta.name,
                    direction: meta.direction,
                    type: 'exit'
                });
            });

            // Collect returns with metadata
            Object.entries(state.returnMetadata).forEach(([key, meta]) => {
                const [x, y] = key.split(',').map(Number);
                exits.push({
                    x, y,
                    name: meta.name,
                    direction: meta.direction,
                    type: 'return'
                });
            });

            // Legacy spawn point (first primary or first spawn)
            const primarySpawn = spawns.find(s => s.isPrimary) || spawns[0];
            const spawnPoint = primarySpawn ? { x: primarySpawn.x, y: primarySpawn.y } : null;

            // Also generate a list of walkable coordinates for easier game use
            const walkable = [];
            const obstructions = [];

            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tileState = state.tiles[y][x];
                    if (tileState === 'open' || tileState === 'spawn' || tileState === 'exit' || tileState === 'return') {
                        walkable.push({ x, y });
                    } else if (tileState === 'obstruction') {
                        obstructions.push({ x, y });
                    }
                }
            }

            // Physics settings based on level type
            const physics = levelType === 'platformer'
                ? {
                    gravity: true,
                    gravityStrength: 1800,
                    collisionMode: 'solid',  // obstructions are solid from all sides
                    playerCanLand: true       // player lands on top of obstructions
                }
                : {
                    gravity: false,
                    gravityStrength: 0,
                    collisionMode: 'blocking', // obstructions block movement
                    playerCanLand: false
                };

            // Background layers (without image data for smaller JSON)
            const backgrounds = state.backgrounds.map(layer => ({
                id: layer.id,
                name: layer.name,
                imageSrc: layer.imageSrc,
                depth: layer.depth,
                scrollRate: layer.scrollRate,
                offsetX: layer.offsetX,
                offsetY: layer.offsetY,
                scale: layer.scale,
                visible: layer.visible
            }));

            // Visual tiles (sparse encoding - only non-null tiles)
            const visualTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = state.visualTiles[y]?.[x];
                    if (tile) {
                        visualTiles.push({
                            x, y,
                            spriteSheet: tile.spriteSheet,
                            spriteName: tile.spriteName,
                            sourceX: tile.x,
                            sourceY: tile.y,
                            width: tile.width,
                            height: tile.height
                        });
                    }
                }
            }

            return {
                name: levelName,
                type: levelType,
                width: state.gridWidth,
                height: state.gridHeight,
                tileSize: state.tileSize,
                physics: physics,
                spawn: spawnPoint,
                spawns: spawns,
                exits: exits,
                grid: tileData,
                walkable: walkable,
                obstructions: obstructions,
                backgrounds: backgrounds,
                visualTiles: visualTiles,
                meta: {
                    totalTiles: state.gridWidth * state.gridHeight,
                    walkableCount: walkable.length,
                    obstructionCount: obstructions.length,
                    backgroundCount: backgrounds.length,
                    visualTileCount: visualTiles.length,
                    spawnCount: spawns.length,
                    exitCount: exits.length
                }
            };
        }

        function updateJsonOutput() {
            const levelData = generateLevelData();
            elements.jsonOutput.textContent = JSON.stringify(levelData, null, 2);
        }

        function copyJson() {
            navigator.clipboard.writeText(elements.jsonOutput.textContent)
                .then(() => showToast('Level JSON copied!'))
                .catch(() => showToast('Failed to copy'));
        }

        function loadJson() {
            const jsonStr = prompt('Paste level JSON:');
            if (!jsonStr) return;

            try {
                const levelData = JSON.parse(jsonStr);

                if (levelData.width && levelData.height && levelData.grid) {
                    state.gridWidth = levelData.width;
                    state.gridHeight = levelData.height;
                    elements.gridWidth.value = state.gridWidth;
                    elements.gridHeight.value = state.gridHeight;

                    state.tiles = [];
                    for (let y = 0; y < state.gridHeight; y++) {
                        const row = [];
                        for (let x = 0; x < state.gridWidth; x++) {
                            const value = levelData.grid[y]?.[x] ?? 0;
                            if (value === 1) row.push('open');
                            else if (value === 2) row.push('obstruction');
                            else if (value === 3) row.push('spawn');
                            else row.push('undefined');
                        }
                        state.tiles.push(row);
                    }

                    if (levelData.name) {
                        elements.levelName.value = levelData.name;
                    }

                    if (levelData.type) {
                        state.levelType = levelData.type;
                        elements.levelType.value = levelData.type;
                    }

                    // Load backgrounds
                    state.backgrounds = [];
                    if (levelData.backgrounds && levelData.backgrounds.length > 0) {
                        let loadedCount = 0;
                        levelData.backgrounds.forEach((bgData, index) => {
                            const img = new Image();
                            img.onload = () => {
                                state.backgrounds[index] = {
                                    id: bgData.id,
                                    name: bgData.name,
                                    imageSrc: bgData.imageSrc,
                                    image: img,
                                    depth: bgData.depth,
                                    scrollRate: bgData.scrollRate,
                                    offsetX: bgData.offsetX,
                                    offsetY: bgData.offsetY,
                                    scale: bgData.scale,
                                    visible: bgData.visible,
                                    pixelified: false,
                                    originalImageData: null
                                };
                                loadedCount++;
                                if (loadedCount === levelData.backgrounds.length) {
                                    state.selectedBgLayer = state.backgrounds.length > 0 ? 0 : -1;
                                    elements.pixelifyBtn.disabled = state.backgrounds.length === 0;
                                    renderBackgroundLayers();
                                    renderBackgroundPreview();
                                    updateBgLayerControls();
                                }
                            };
                            img.src = bgData.imageSrc;
                        });
                    }

                    // Load visual tiles
                    initVisualTiles();
                    if (levelData.visualTiles && levelData.visualTiles.length > 0) {
                        levelData.visualTiles.forEach(tile => {
                            if (tile.x >= 0 && tile.x < state.gridWidth &&
                                tile.y >= 0 && tile.y < state.gridHeight) {
                                state.visualTiles[tile.y][tile.x] = {
                                    spriteSheet: tile.spriteSheet,
                                    spriteName: tile.spriteName,
                                    x: tile.sourceX,
                                    y: tile.sourceY,
                                    width: tile.width,
                                    height: tile.height
                                };
                            }
                        });
                    }

                    renderGrid();
                    renderTileCanvas();
                    updateStats();
                    updateJsonOutput();
                    showToast('Level loaded!');
                } else {
                    showToast('Invalid level data');
                }
            } catch (e) {
                showToast('Invalid JSON');
            }
        }

        // ==========================================
        // Event Listeners
        // ==========================================
        elements.resizeGridBtn.addEventListener('click', resizeGrid);
        elements.clearGridBtn.addEventListener('click', clearGrid);
        elements.newLevelBtn.addEventListener('click', () => {
            if (confirm('Create new level? Current progress will be lost.')) {
                elements.levelName.value = '';
                clearGrid();
            }
        });
        elements.copyJsonBtn.addEventListener('click', copyJson);
        elements.loadJsonBtn.addEventListener('click', loadJson);
        elements.levelName.addEventListener('input', updateJsonOutput);
        elements.levelType.addEventListener('change', (e) => {
            state.levelType = e.target.value;
            updateJsonOutput();
        });

        // Keyboard shortcuts (editor mode only)
        window.addEventListener('keydown', (e) => {
            if (demo.active) return;  // Don't handle editor shortcuts in demo mode
            if (document.activeElement.tagName === 'INPUT') return;
            if (document.activeElement.tagName === 'SELECT') return;

            switch (e.key.toLowerCase()) {
                case 'p':
                    setTool('paint');
                    break;
                case 'f':
                    setTool('fill');
                    break;
                case 's':
                    setTool('select');
                    break;
                case '1':
                    setState('undefined');
                    break;
                case '2':
                    setState('open');
                    break;
                case '3':
                    setState('obstruction');
                    break;
                case '4':
                    setState('spawn');
                    break;
                case 'escape':
                    clearTileHighlights();
                    elements.selectionBox.style.display = 'none';
                    state.selectionStart = null;
                    state.selectionEnd = null;
                    break;
            }
        });

        // ==========================================
        // Demo Mode
        // ==========================================
        const demo = {
            active: false,
            ctx: null,
            player: {
                x: 100,
                y: 100,
                width: 20,
                height: 32,
                vx: 0,
                vy: 0,
                onGround: false
            },
            keys: {},
            animationFrame: null,
            lastTime: 0
        };

        const DEMO_SCALE = 2;
        const PLAYER_SPEED = 200;
        const JUMP_FORCE = 500;
        const GRAVITY = 1200;
        const TOPDOWN_SPEED = 150;

        function startDemo() {
            demo.active = true;
            demo.ctx = elements.demoCanvas.getContext('2d');
            demo.ctx.imageSmoothingEnabled = false;

            // Set canvas size based on project tile size
            const canvasWidth = state.gridWidth * state.tileSize;
            const canvasHeight = state.gridHeight * state.tileSize;
            elements.demoCanvas.width = canvasWidth;
            elements.demoCanvas.height = canvasHeight;
            elements.demoCanvas.style.width = (canvasWidth * DEMO_SCALE) + 'px';
            elements.demoCanvas.style.height = (canvasHeight * DEMO_SCALE) + 'px';

            // Find spawn point (first open tile from bottom-left for platformer, center for topdown)
            resetPlayerPosition();

            // Update HUD controls text
            if (state.levelType === 'platformer') {
                elements.demoControls.innerHTML = `
                    <kbd>&#8592;</kbd><kbd>&#8594;</kbd> Move<br>
                    <kbd>Space</kbd> Jump<br>
                    <kbd>Esc</kbd> Exit
                `;
            } else {
                elements.demoControls.innerHTML = `
                    <kbd>&#8592;</kbd><kbd>&#8594;</kbd><kbd>&#8593;</kbd><kbd>&#8595;</kbd> Move<br>
                    <kbd>Esc</kbd> Exit
                `;
            }

            // Show overlay
            elements.demoOverlay.classList.add('active');

            // Start game loop
            demo.lastTime = performance.now();
            demo.animationFrame = requestAnimationFrame(demoLoop);
        }

        function stopDemo() {
            demo.active = false;
            elements.demoOverlay.classList.remove('active');
            if (demo.animationFrame) {
                cancelAnimationFrame(demo.animationFrame);
                demo.animationFrame = null;
            }
            demo.keys = {};
        }

        function resetPlayerPosition() {
            const tileSize = state.tileSize;

            // First, look for spawn point
            let spawnX = -1, spawnY = -1;
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    if (state.tiles[y][x] === 'spawn') {
                        spawnX = x;
                        spawnY = y;
                        break;
                    }
                }
                if (spawnX !== -1) break;
            }

            // If spawn point found, use it
            if (spawnX !== -1) {
                demo.player.x = spawnX * tileSize + (tileSize - demo.player.width) / 2;
                demo.player.y = spawnY * tileSize + (tileSize - demo.player.height);
                demo.player.vx = 0;
                demo.player.vy = 0;
                demo.player.onGround = false;
                return;
            }

            if (state.levelType === 'platformer') {
                // Find first open tile from bottom, scanning left to right (not on obstruction)
                for (let y = state.gridHeight - 1; y >= 0; y--) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        if (state.tiles[y][x] === 'open') {
                            // Check if there's ground below or at bottom
                            const hasGround = y === state.gridHeight - 1 ||
                                             state.tiles[y + 1]?.[x] === 'obstruction';
                            if (hasGround) {
                                demo.player.x = x * tileSize + (tileSize - demo.player.width) / 2;
                                demo.player.y = y * tileSize + (tileSize - demo.player.height);
                                demo.player.vx = 0;
                                demo.player.vy = 0;
                                return;
                            }
                        }
                    }
                }
                // Fallback: top-left
                demo.player.x = tileSize;
                demo.player.y = tileSize;
            } else {
                // Top-down: find first open tile or center of level
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        if (state.tiles[y][x] === 'open') {
                            demo.player.x = x * tileSize + (tileSize - demo.player.width) / 2;
                            demo.player.y = y * tileSize + (tileSize - demo.player.height) / 2;
                            demo.player.vx = 0;
                            demo.player.vy = 0;
                            return;
                        }
                    }
                }
                // Fallback: center of level
                demo.player.x = (state.gridWidth * tileSize) / 2 - demo.player.width / 2;
                demo.player.y = (state.gridHeight * tileSize) / 2 - demo.player.height / 2;
            }
            demo.player.vx = 0;
            demo.player.vy = 0;
        }

        function demoLoop(currentTime) {
            if (!demo.active) return;

            const dt = Math.min((currentTime - demo.lastTime) / 1000, 0.05);
            demo.lastTime = currentTime;

            updatePlayer(dt);
            renderDemo();

            demo.animationFrame = requestAnimationFrame(demoLoop);
        }

        function updatePlayer(dt) {
            const p = demo.player;
            const tileSize = state.tileSize;

            if (state.levelType === 'platformer') {
                // Horizontal movement
                p.vx = 0;
                if (demo.keys['ArrowLeft'] || demo.keys['KeyA']) p.vx = -PLAYER_SPEED;
                if (demo.keys['ArrowRight'] || demo.keys['KeyD']) p.vx = PLAYER_SPEED;

                // Gravity
                p.vy += GRAVITY * dt;

                // Jump
                if ((demo.keys['Space'] || demo.keys['ArrowUp'] || demo.keys['KeyW']) && p.onGround) {
                    p.vy = -JUMP_FORCE;
                    p.onGround = false;
                }

                // Apply velocity
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                // Collision detection
                p.onGround = false;

                // Check tile collisions
                const left = Math.floor(p.x / tileSize);
                const right = Math.floor((p.x + p.width - 1) / tileSize);
                const top = Math.floor(p.y / tileSize);
                const bottom = Math.floor((p.y + p.height - 1) / tileSize);

                // Vertical collision (landing on platforms)
                for (let tx = left; tx <= right; tx++) {
                    // Check below
                    const tileBelow = state.tiles[bottom]?.[tx];
                    if (tileBelow === 'obstruction') {
                        if (p.vy > 0) {
                            p.y = bottom * tileSize - p.height;
                            p.vy = 0;
                            p.onGround = true;
                        }
                    }
                    // Check above
                    const tileAbove = state.tiles[top]?.[tx];
                    if (tileAbove === 'obstruction') {
                        if (p.vy < 0) {
                            p.y = (top + 1) * tileSize;
                            p.vy = 0;
                        }
                    }
                }

                // Recalculate after vertical adjustment
                const newTop = Math.floor(p.y / tileSize);
                const newBottom = Math.floor((p.y + p.height - 1) / tileSize);

                // Horizontal collision
                for (let ty = newTop; ty <= newBottom; ty++) {
                    // Check left
                    const newLeft = Math.floor(p.x / tileSize);
                    if (state.tiles[ty]?.[newLeft] === 'obstruction') {
                        p.x = (newLeft + 1) * tileSize;
                    }
                    // Check right
                    const newRight = Math.floor((p.x + p.width - 1) / tileSize);
                    if (state.tiles[ty]?.[newRight] === 'obstruction') {
                        p.x = newRight * tileSize - p.width;
                    }
                }

                // Bounds
                p.x = Math.max(0, Math.min(p.x, state.gridWidth * tileSize - p.width));
                p.y = Math.max(0, Math.min(p.y, state.gridHeight * tileSize - p.height));

                // Ground at bottom of level
                if (p.y >= state.gridHeight * tileSize - p.height) {
                    p.y = state.gridHeight * tileSize - p.height;
                    p.vy = 0;
                    p.onGround = true;
                }

            } else {
                // Top-down movement
                p.vx = 0;
                p.vy = 0;
                if (demo.keys['ArrowLeft'] || demo.keys['KeyA']) p.vx = -TOPDOWN_SPEED;
                if (demo.keys['ArrowRight'] || demo.keys['KeyD']) p.vx = TOPDOWN_SPEED;
                if (demo.keys['ArrowUp'] || demo.keys['KeyW']) p.vy = -TOPDOWN_SPEED;
                if (demo.keys['ArrowDown'] || demo.keys['KeyS']) p.vy = TOPDOWN_SPEED;

                // Normalize diagonal movement
                if (p.vx !== 0 && p.vy !== 0) {
                    p.vx *= 0.707;
                    p.vy *= 0.707;
                }

                // Try X movement
                const newX = p.x + p.vx * dt;
                if (!checkCollisionTopDown(newX, p.y, p.width, p.height)) {
                    p.x = newX;
                }

                // Try Y movement
                const newY = p.y + p.vy * dt;
                if (!checkCollisionTopDown(p.x, newY, p.width, p.height)) {
                    p.y = newY;
                }

                // Bounds
                p.x = Math.max(0, Math.min(p.x, state.gridWidth * tileSize - p.width));
                p.y = Math.max(0, Math.min(p.y, state.gridHeight * tileSize - p.height));
            }
        }

        function checkCollisionTopDown(x, y, w, h) {
            const tileSize = state.tileSize;
            const left = Math.floor(x / tileSize);
            const right = Math.floor((x + w - 1) / tileSize);
            const top = Math.floor(y / tileSize);
            const bottom = Math.floor((y + h - 1) / tileSize);

            for (let ty = top; ty <= bottom; ty++) {
                for (let tx = left; tx <= right; tx++) {
                    const tile = state.tiles[ty]?.[tx];
                    // Only obstruction blocks movement (open, spawn, undefined are walkable)
                    if (tile === 'obstruction') {
                        return true;
                    }
                }
            }
            return false;
        }

        function renderDemo() {
            const ctx = demo.ctx;
            const tileSize = state.tileSize;

            // Clear
            ctx.fillStyle = '#0d0d14';
            ctx.fillRect(0, 0, elements.demoCanvas.width, elements.demoCanvas.height);

            // Draw backgrounds (sorted by depth, furthest back first)
            const sortedBgs = [...state.backgrounds]
                .filter(l => l.visible)
                .sort((a, b) => a.depth - b.depth);

            ctx.imageSmoothingEnabled = false;
            sortedBgs.forEach(layer => {
                ctx.save();
                // Apply parallax offset based on player position
                const parallaxX = layer.offsetX - (demo.player.x * (1 - layer.scrollRate) * 0.1);
                const parallaxY = layer.offsetY - (demo.player.y * (1 - layer.scrollRate) * 0.1);
                ctx.translate(parallaxX, parallaxY);
                const scaledWidth = layer.image.width * layer.scale;
                const scaledHeight = layer.image.height * layer.scale;
                ctx.drawImage(layer.image, 0, 0, scaledWidth, scaledHeight);
                ctx.restore();
            });

            // Draw collision tiles (as fallback/debug if no visual tiles)
            const hasVisualTiles = state.visualTiles.some(row => row.some(t => t !== null));

            if (!hasVisualTiles) {
                // Draw collision grid colors
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        const tile = state.tiles[y][x];
                        if (tile === 'open') {
                            ctx.fillStyle = '#2a5a30';
                        } else if (tile === 'obstruction') {
                            ctx.fillStyle = '#6a2a2a';
                        } else if (tile === 'spawn') {
                            ctx.fillStyle = '#2a4a6a';
                        } else {
                            ctx.fillStyle = '#1a1a2e';
                        }
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                    }
                }
            } else {
                // Draw visual tiles
                for (let y = 0; y < state.gridHeight; y++) {
                    for (let x = 0; x < state.gridWidth; x++) {
                        const vTile = state.visualTiles[y]?.[x];
                        if (vTile) {
                            let sheetImage;
                            if (vTile.spriteSheet === '__master_tiles__') {
                                sheetImage = state.masterTileSheetImage;
                            } else if (vTile.spriteSheet === '__master_sprites__') {
                                sheetImage = state.masterSpriteSheetImage;
                            } else {
                                sheetImage = state.spriteImages[vTile.spriteSheet];
                            }
                            if (sheetImage) {
                                ctx.drawImage(
                                    sheetImage,
                                    vTile.x, vTile.y, vTile.width, vTile.height,
                                    x * tileSize, y * tileSize, tileSize, tileSize
                                );
                            }
                        } else {
                            // Draw collision color for empty tiles
                            const tile = state.tiles[y][x];
                            if (tile === 'obstruction') {
                                ctx.fillStyle = '#6a2a2a';
                                ctx.fillRect(x * tileSize, y * tileSize, tileSize - 1, tileSize - 1);
                            }
                        }
                    }
                }
            }

            // Draw player
            ctx.fillStyle = '#e07020';
            ctx.fillRect(
                Math.round(demo.player.x),
                Math.round(demo.player.y),
                demo.player.width,
                demo.player.height
            );

            // Player face indicator (shows direction)
            ctx.fillStyle = '#fff';
            const eyeY = Math.round(demo.player.y) + 6;
            const eyeSize = 3;
            ctx.fillRect(Math.round(demo.player.x) + 4, eyeY, eyeSize, eyeSize);
            ctx.fillRect(Math.round(demo.player.x) + demo.player.width - 7, eyeY, eyeSize, eyeSize);
        }

        // Demo key handlers
        function handleDemoKeyDown(e) {
            if (!demo.active) return;

            // Prevent default for game controls to avoid page scrolling/other browser behavior
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' ||
                e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                e.preventDefault();
            }

            demo.keys[e.code] = true;

            if (e.code === 'Escape') {
                stopDemo();
            }
        }

        function handleDemoKeyUp(e) {
            if (!demo.active) return;

            // Prevent default for game controls
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown' ||
                e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
                e.preventDefault();
            }

            demo.keys[e.code] = false;
        }

        window.addEventListener('keydown', handleDemoKeyDown);
        window.addEventListener('keyup', handleDemoKeyUp);

        elements.playDemoBtn.addEventListener('click', startDemo);
        elements.exitDemoBtn.addEventListener('click', stopDemo);

        // ==========================================
        // Tab Management
        // ==========================================
        function switchTab(tabName) {
            state.activeTab = tabName;

            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            // Update tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(tabName + 'Panel').classList.add('active');

            // Update grid toolbar visibility
            elements.gridToolbar.classList.toggle('active', tabName === 'grid');

            // Update right panel settings
            elements.gridSettings.classList.toggle('active', tabName === 'grid');
            elements.bgSettings.classList.toggle('active', tabName === 'background');
            elements.pixelifySettings.classList.toggle('active', tabName === 'background');
            elements.tileSettings.classList.toggle('active', tabName === 'tiles');

            // Render appropriate content
            if (tabName === 'background') {
                renderBackgroundPreview();
            } else if (tabName === 'tiles') {
                renderTileCanvas();
            }

            updateJsonOutput();
        }

        // Tab button click handlers
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // ==========================================
        // Background Editor
        // ==========================================
        function addBackgroundLayer(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const layer = {
                        id: 'bg_' + Date.now(),
                        name: file.name.replace(/\.[^.]+$/, ''),
                        imageSrc: e.target.result,
                        image: img,
                        depth: state.backgrounds.length * -10,
                        scrollRate: 1,
                        offsetX: 0,
                        offsetY: 0,
                        scale: 1,
                        visible: true,
                        pixelified: false,
                        originalImageData: null
                    };
                    state.backgrounds.push(layer);
                    state.selectedBgLayer = state.backgrounds.length - 1;
                    elements.pixelifyBtn.disabled = false;
                    renderBackgroundLayers();
                    renderBackgroundPreview();
                    updateBgLayerControls();
                    updateJsonOutput();
                    showToast('Background layer added');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function renderBackgroundLayers() {
            if (state.backgrounds.length === 0) {
                elements.backgroundLayers.innerHTML = '<div class="no-layers-message">No background layers. Click "+ Add Layer" to upload an image.<br><br>Recommended: 768x432px (32x18 tiles at 24px)</div>';
                return;
            }

            elements.backgroundLayers.innerHTML = state.backgrounds.map((layer, index) => `
                <div class="bg-layer-item ${index === state.selectedBgLayer ? 'selected' : ''}" data-index="${index}">
                    <div class="bg-layer-thumb">
                        <img src="${layer.imageSrc}" alt="${layer.name}">
                    </div>
                    <div class="bg-layer-info">
                        <div class="bg-layer-name">${layer.name}</div>
                        <div class="bg-layer-meta">Depth: ${layer.depth} | Scale: ${layer.scale}x</div>
                    </div>
                    <div class="bg-layer-actions">
                        <button class="bg-layer-visibility ${layer.visible ? '' : 'hidden'}" data-index="${index}" title="Toggle visibility">
                            ${layer.visible ? '&#128065;' : '&#128064;'}
                        </button>
                        <button class="bg-layer-delete" data-index="${index}" title="Delete layer">&#10005;</button>
                    </div>
                </div>
            `).join('');

            // Add event listeners
            elements.backgroundLayers.querySelectorAll('.bg-layer-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.bg-layer-visibility') && !e.target.closest('.bg-layer-delete')) {
                        selectBgLayer(parseInt(item.dataset.index));
                    }
                });
            });

            elements.backgroundLayers.querySelectorAll('.bg-layer-visibility').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleBgLayerVisibility(parseInt(btn.dataset.index));
                });
            });

            elements.backgroundLayers.querySelectorAll('.bg-layer-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteBgLayer(parseInt(btn.dataset.index));
                });
            });
        }

        function selectBgLayer(index) {
            state.selectedBgLayer = index;
            renderBackgroundLayers();
            updateBgLayerControls();
            // Update cursor for drag-to-reposition
            elements.backgroundCanvas.style.cursor = index >= 0 ? 'grab' : 'default';
        }

        function toggleBgLayerVisibility(index) {
            state.backgrounds[index].visible = !state.backgrounds[index].visible;
            renderBackgroundLayers();
            renderBackgroundPreview();
            updateJsonOutput();
        }

        function deleteBgLayer(index) {
            state.backgrounds.splice(index, 1);
            if (state.selectedBgLayer >= state.backgrounds.length) {
                state.selectedBgLayer = state.backgrounds.length - 1;
            }
            elements.pixelifyBtn.disabled = state.backgrounds.length === 0;
            renderBackgroundLayers();
            renderBackgroundPreview();
            updateBgLayerControls();
            updateJsonOutput();
            showToast('Layer deleted');
        }

        function updateBgLayerControls() {
            if (state.selectedBgLayer < 0 || state.selectedBgLayer >= state.backgrounds.length) {
                elements.bgLayerControls.style.display = 'none';
                document.getElementById('bgLayerSettings').innerHTML = '<div class="no-layers-message">Select a layer to edit its settings</div>';
                return;
            }

            elements.bgLayerControls.style.display = 'block';
            document.getElementById('bgLayerSettings').innerHTML = '';

            const layer = state.backgrounds[state.selectedBgLayer];
            elements.bgLayerName.value = layer.name;
            elements.bgDepth.value = layer.depth;
            elements.bgScrollRate.value = layer.scrollRate;
            elements.bgOffsetX.value = layer.offsetX;
            elements.bgOffsetY.value = layer.offsetY;
            elements.bgScale.value = layer.scale;
            elements.bgScaleValue.textContent = layer.scale + 'x';
        }

        function updateSelectedBgLayer(property, value) {
            if (state.selectedBgLayer < 0) return;
            state.backgrounds[state.selectedBgLayer][property] = value;
            renderBackgroundLayers();
            renderBackgroundPreview();
            updateJsonOutput();
        }

        function renderBackgroundPreview() {
            const canvas = elements.backgroundCanvas;
            const ctx = canvas.getContext('2d');

            // Size canvas to level dimensions
            const levelWidth = state.gridWidth * 24;
            const levelHeight = state.gridHeight * 24;
            canvas.width = levelWidth;
            canvas.height = levelHeight;

            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, levelWidth, levelHeight);

            // Draw checkerboard for transparency
            const checkSize = 8;
            for (let y = 0; y < levelHeight; y += checkSize) {
                for (let x = 0; x < levelWidth; x += checkSize) {
                    ctx.fillStyle = ((x / checkSize + y / checkSize) % 2 === 0) ? '#252542' : '#1a1a2e';
                    ctx.fillRect(x, y, checkSize, checkSize);
                }
            }

            // Sort layers by depth (furthest back first)
            const sortedLayers = [...state.backgrounds]
                .filter(l => l.visible)
                .sort((a, b) => a.depth - b.depth);

            sortedLayers.forEach(layer => {
                ctx.save();
                ctx.translate(layer.offsetX, layer.offsetY);
                const scaledWidth = layer.image.width * layer.scale;
                const scaledHeight = layer.image.height * layer.scale;
                ctx.drawImage(layer.image, 0, 0, scaledWidth, scaledHeight);
                ctx.restore();
            });
        }

        // Background layer input handlers
        elements.bgFileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                addBackgroundLayer(e.target.files[0]);
                e.target.value = ''; // Reset for re-upload
            }
        });

        // Background Library Modal Functions
        function openBgLibraryModal() {
            if (!state.currentProjectId) {
                showToast('Please select a project first');
                return;
            }

            state.selectedLibraryBg = null;
            elements.addFromLibraryBtn.disabled = true;
            renderBgLibraryGrid();
            elements.bgLibraryModal.classList.add('active');
        }

        function closeBgLibraryModal() {
            elements.bgLibraryModal.classList.remove('active');
            state.selectedLibraryBg = null;
        }

        function renderBgLibraryGrid() {
            const bgNames = Object.keys(state.bgLibrary);

            if (bgNames.length === 0) {
                elements.bgLibraryGrid.innerHTML = `
                    <div class="bg-library-empty">
                        No backgrounds in library.<br><br>
                        Create backgrounds in <a href="../frameweft/" target="_blank">Frameweft</a>
                    </div>
                `;
                return;
            }

            elements.bgLibraryGrid.innerHTML = bgNames.map(name => {
                const bg = state.bgLibrary[name];
                return `
                    <div class="bg-library-item ${state.selectedLibraryBg === name ? 'selected' : ''}" data-name="${name}">
                        <canvas width="140" height="79" data-bg="${name}"></canvas>
                        <div class="bg-library-item-name">${name}</div>
                    </div>
                `;
            }).join('');

            // Draw thumbnails from sheet
            if (state.bgLibrarySheet) {
                elements.bgLibraryGrid.querySelectorAll('canvas[data-bg]').forEach(canvas => {
                    const name = canvas.dataset.bg;
                    const bg = state.bgLibrary[name];
                    if (!bg) return;

                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    // Calculate thumbnail scale to fit
                    const scale = Math.min(140 / bg.w, 79 / bg.h);
                    const drawW = bg.w * scale;
                    const drawH = bg.h * scale;
                    const drawX = (140 - drawW) / 2;
                    const drawY = (79 - drawH) / 2;

                    ctx.drawImage(
                        state.bgLibrarySheet,
                        bg.x, bg.y, bg.w, bg.h,
                        drawX, drawY, drawW, drawH
                    );
                });
            }

            // Add click handlers
            elements.bgLibraryGrid.querySelectorAll('.bg-library-item').forEach(item => {
                item.addEventListener('click', () => {
                    state.selectedLibraryBg = item.dataset.name;
                    elements.bgLibraryGrid.querySelectorAll('.bg-library-item').forEach(i => {
                        i.classList.toggle('selected', i.dataset.name === state.selectedLibraryBg);
                    });
                    elements.addFromLibraryBtn.disabled = false;
                });
            });
        }

        function addBgFromLibrary() {
            if (!state.selectedLibraryBg || !state.bgLibrarySheet) return;

            const bg = state.bgLibrary[state.selectedLibraryBg];
            if (!bg) return;

            // Extract the background image from the sheet
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = bg.w;
            tempCanvas.height = bg.h;
            const ctx = tempCanvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
                state.bgLibrarySheet,
                bg.x, bg.y, bg.w, bg.h,
                0, 0, bg.w, bg.h
            );

            // Create Image from canvas
            const img = new Image();
            img.onload = () => {
                const layer = {
                    name: state.selectedLibraryBg,
                    image: img,
                    imageSrc: tempCanvas.toDataURL('image/png'),
                    depth: state.backgrounds.length,
                    scrollRate: 1,
                    offsetX: 0,
                    offsetY: 0,
                    scale: 1,
                    visible: true,
                    originalImageData: null
                };
                state.backgrounds.push(layer);
                state.selectedBgLayer = state.backgrounds.length - 1;
                elements.pixelifyBtn.disabled = false;
                renderBackgroundLayers();
                renderBackgroundPreview();
                updateBgLayerControls();
                updateJsonOutput();
                closeBgLibraryModal();
                showToast(`Added "${state.selectedLibraryBg}" from library`);
            };
            img.src = tempCanvas.toDataURL('image/png');
        }

        // Background Library event listeners
        elements.fromLibraryBtn.addEventListener('click', openBgLibraryModal);
        elements.cancelBgLibraryBtn.addEventListener('click', closeBgLibraryModal);
        elements.addFromLibraryBtn.addEventListener('click', addBgFromLibrary);

        elements.bgLayerName.addEventListener('input', (e) => updateSelectedBgLayer('name', e.target.value));
        elements.bgDepth.addEventListener('input', (e) => updateSelectedBgLayer('depth', parseInt(e.target.value) || 0));
        elements.bgScrollRate.addEventListener('input', (e) => updateSelectedBgLayer('scrollRate', parseFloat(e.target.value) || 1));
        elements.bgOffsetX.addEventListener('input', (e) => updateSelectedBgLayer('offsetX', parseInt(e.target.value) || 0));
        elements.bgOffsetY.addEventListener('input', (e) => updateSelectedBgLayer('offsetY', parseInt(e.target.value) || 0));
        elements.bgScale.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            elements.bgScaleValue.textContent = val + 'x';
            updateSelectedBgLayer('scale', val);
        });

        // Background drag-to-reposition
        elements.backgroundCanvas.addEventListener('mousedown', (e) => {
            if (state.selectedBgLayer < 0) return;
            state.bgDragging = true;
            state.bgDragStart = { x: e.clientX, y: e.clientY };
            const layer = state.backgrounds[state.selectedBgLayer];
            state.bgDragLayerStart = { x: layer.offsetX, y: layer.offsetY };
            elements.backgroundCanvas.style.cursor = 'grabbing';
        });

        elements.backgroundCanvas.addEventListener('mousemove', (e) => {
            if (!state.bgDragging || state.selectedBgLayer < 0) return;
            const dx = e.clientX - state.bgDragStart.x;
            const dy = e.clientY - state.bgDragStart.y;

            const layer = state.backgrounds[state.selectedBgLayer];
            layer.offsetX = state.bgDragLayerStart.x + dx;
            layer.offsetY = state.bgDragLayerStart.y + dy;

            // Sync input fields
            elements.bgOffsetX.value = layer.offsetX;
            elements.bgOffsetY.value = layer.offsetY;

            renderBackgroundPreview();
        });

        elements.backgroundCanvas.addEventListener('mouseup', () => {
            if (state.bgDragging) {
                state.bgDragging = false;
                elements.backgroundCanvas.style.cursor = state.selectedBgLayer >= 0 ? 'grab' : 'default';
                updateJsonOutput();
            }
        });

        elements.backgroundCanvas.addEventListener('mouseleave', () => {
            if (state.bgDragging) {
                state.bgDragging = false;
                elements.backgroundCanvas.style.cursor = state.selectedBgLayer >= 0 ? 'grab' : 'default';
                updateJsonOutput();
            }
        });

        // Pixelify controls
        elements.targetResolution.addEventListener('change', (e) => {
            state.pixelifySettings.targetRes = e.target.value;
            elements.customResGroup.style.display = e.target.value === 'custom' ? 'block' : 'none';
        });

        elements.customWidth.addEventListener('input', (e) => {
            state.pixelifySettings.customWidth = parseInt(e.target.value) || 320;
        });

        elements.customHeight.addEventListener('input', (e) => {
            state.pixelifySettings.customHeight = parseInt(e.target.value) || 180;
        });

        elements.paletteColors.addEventListener('input', (e) => {
            elements.paletteColorsValue.textContent = e.target.value;
            state.pixelifySettings.paletteColors = parseInt(e.target.value);
        });

        elements.ditherMode.addEventListener('change', (e) => {
            state.pixelifySettings.ditherMode = e.target.value;
        });

        elements.ditherStrength.addEventListener('input', (e) => {
            elements.ditherStrengthValue.textContent = e.target.value;
            state.pixelifySettings.ditherStrength = parseInt(e.target.value);
        });

        // ==========================================
        // Retro Pixelify Effect (Proper Workflow)
        // ==========================================

        // Resolution presets
        const RESOLUTION_PRESETS = {
            '320x180': { w: 320, h: 180 },
            '320x224': { w: 320, h: 224 },
            '256x224': { w: 256, h: 224 },
            '160x144': { w: 160, h: 144 },
            '256x192': { w: 256, h: 192 }
        };

        // Bayer dither matrices
        const BAYER_2x2 = [
            [0, 2],
            [3, 1]
        ];
        const BAYER_4x4 = [
            [0,  8,  2, 10],
            [12, 4, 14,  6],
            [3, 11,  1,  9],
            [15, 7, 13,  5]
        ];
        const BAYER_8x8 = [
            [ 0, 32,  8, 40,  2, 34, 10, 42],
            [48, 16, 56, 24, 50, 18, 58, 26],
            [12, 44,  4, 36, 14, 46,  6, 38],
            [60, 28, 52, 20, 62, 30, 54, 22],
            [ 3, 35, 11, 43,  1, 33,  9, 41],
            [51, 19, 59, 27, 49, 17, 57, 25],
            [15, 47,  7, 39, 13, 45,  5, 37],
            [63, 31, 55, 23, 61, 29, 53, 21]
        ];

        // Median Cut palette extraction
        function extractPalette(imageData, numColors) {
            const pixels = [];
            const data = imageData.data;

            // Collect all pixels
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 128) { // Skip transparent
                    pixels.push([data[i], data[i + 1], data[i + 2]]);
                }
            }

            if (pixels.length === 0) return [[0, 0, 0]];

            // Median cut algorithm
            function medianCut(pixels, depth, maxDepth) {
                if (depth >= maxDepth || pixels.length === 0) {
                    // Average the pixels in this bucket
                    const avg = [0, 0, 0];
                    for (const p of pixels) {
                        avg[0] += p[0];
                        avg[1] += p[1];
                        avg[2] += p[2];
                    }
                    const len = pixels.length || 1;
                    return [[Math.round(avg[0] / len), Math.round(avg[1] / len), Math.round(avg[2] / len)]];
                }

                // Find the channel with the greatest range
                let rMin = 255, rMax = 0, gMin = 255, gMax = 0, bMin = 255, bMax = 0;
                for (const p of pixels) {
                    rMin = Math.min(rMin, p[0]); rMax = Math.max(rMax, p[0]);
                    gMin = Math.min(gMin, p[1]); gMax = Math.max(gMax, p[1]);
                    bMin = Math.min(bMin, p[2]); bMax = Math.max(bMax, p[2]);
                }

                const rRange = rMax - rMin;
                const gRange = gMax - gMin;
                const bRange = bMax - bMin;

                let sortChannel = 0;
                if (gRange >= rRange && gRange >= bRange) sortChannel = 1;
                else if (bRange >= rRange && bRange >= gRange) sortChannel = 2;

                // Sort by the channel with greatest range
                pixels.sort((a, b) => a[sortChannel] - b[sortChannel]);

                const mid = Math.floor(pixels.length / 2);
                const left = pixels.slice(0, mid);
                const right = pixels.slice(mid);

                return [
                    ...medianCut(left, depth + 1, maxDepth),
                    ...medianCut(right, depth + 1, maxDepth)
                ];
            }

            const maxDepth = Math.ceil(Math.log2(numColors));
            let palette = medianCut(pixels, 0, maxDepth);

            // Trim to exact size
            if (palette.length > numColors) {
                palette = palette.slice(0, numColors);
            }

            return palette;
        }

        // Find nearest palette color
        function findNearestColor(r, g, b, palette) {
            let minDist = Infinity;
            let nearest = palette[0];

            for (const color of palette) {
                const dr = r - color[0];
                const dg = g - color[1];
                const db = b - color[2];
                const dist = dr * dr + dg * dg + db * db;

                if (dist < minDist) {
                    minDist = dist;
                    nearest = color;
                }
            }

            return nearest;
        }

        // Apply ordered dithering with palette
        function applyOrderedDither(imageData, palette, matrix, strength) {
            const { width, height, data } = imageData;
            const matrixSize = matrix.length;
            const matrixMax = matrixSize * matrixSize;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] < 128) continue; // Skip transparent

                    // Get threshold from matrix
                    const threshold = (matrix[y % matrixSize][x % matrixSize] / matrixMax - 0.5) * strength;

                    // Add threshold to color
                    const r = Math.max(0, Math.min(255, data[i] + threshold));
                    const g = Math.max(0, Math.min(255, data[i + 1] + threshold));
                    const b = Math.max(0, Math.min(255, data[i + 2] + threshold));

                    // Find nearest palette color
                    const nearest = findNearestColor(r, g, b, palette);
                    data[i] = nearest[0];
                    data[i + 1] = nearest[1];
                    data[i + 2] = nearest[2];
                }
            }
        }

        // Apply Floyd-Steinberg dithering with palette
        function applyFloydSteinberg(imageData, palette) {
            const { width, height, data } = imageData;

            // Work with floating point errors
            const errors = new Float32Array(width * height * 3);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const ei = (y * width + x) * 3;

                    if (data[i + 3] < 128) continue;

                    // Get color with accumulated error
                    const r = Math.max(0, Math.min(255, data[i] + errors[ei]));
                    const g = Math.max(0, Math.min(255, data[i + 1] + errors[ei + 1]));
                    const b = Math.max(0, Math.min(255, data[i + 2] + errors[ei + 2]));

                    // Find nearest palette color
                    const nearest = findNearestColor(r, g, b, palette);
                    data[i] = nearest[0];
                    data[i + 1] = nearest[1];
                    data[i + 2] = nearest[2];

                    // Calculate error
                    const errR = r - nearest[0];
                    const errG = g - nearest[1];
                    const errB = b - nearest[2];

                    // Distribute error to neighbors
                    if (x + 1 < width) {
                        const ni = ei + 3;
                        errors[ni] += errR * 7 / 16;
                        errors[ni + 1] += errG * 7 / 16;
                        errors[ni + 2] += errB * 7 / 16;
                    }
                    if (y + 1 < height) {
                        if (x > 0) {
                            const ni = ei + width * 3 - 3;
                            errors[ni] += errR * 3 / 16;
                            errors[ni + 1] += errG * 3 / 16;
                            errors[ni + 2] += errB * 3 / 16;
                        }
                        const ni = ei + width * 3;
                        errors[ni] += errR * 5 / 16;
                        errors[ni + 1] += errG * 5 / 16;
                        errors[ni + 2] += errB * 5 / 16;
                        if (x + 1 < width) {
                            const nni = ei + width * 3 + 3;
                            errors[nni] += errR * 1 / 16;
                            errors[nni + 1] += errG * 1 / 16;
                            errors[nni + 2] += errB * 1 / 16;
                        }
                    }
                }
            }
        }

        // Simple palette quantization (no dithering)
        function applyNoDither(imageData, palette) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] < 128) continue;
                const nearest = findNearestColor(data[i], data[i + 1], data[i + 2], palette);
                data[i] = nearest[0];
                data[i + 1] = nearest[1];
                data[i + 2] = nearest[2];
            }
        }

        function applyPixelifyEffect() {
            if (state.selectedBgLayer < 0) {
                showToast('Select a layer first');
                return;
            }

            const layer = state.backgrounds[state.selectedBgLayer];
            const { targetRes, customWidth, customHeight, paletteColors, ditherMode, ditherStrength } = state.pixelifySettings;

            // Step 1: Get target resolution
            let targetW, targetH;
            if (targetRes === 'custom') {
                targetW = customWidth;
                targetH = customHeight;
            } else {
                const preset = RESOLUTION_PRESETS[targetRes];
                targetW = preset.w;
                targetH = preset.h;
            }

            // Create source canvas from original image
            const srcCanvas = document.createElement('canvas');
            const srcCtx = srcCanvas.getContext('2d');
            srcCanvas.width = layer.image.width;
            srcCanvas.height = layer.image.height;
            srcCtx.drawImage(layer.image, 0, 0);

            // Store original for undo
            if (!layer.originalImageData) {
                layer.originalImageData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
            }

            // Step 2: Downscale to target resolution (bilinear for sampling)
            const smallCanvas = document.createElement('canvas');
            const smallCtx = smallCanvas.getContext('2d');
            smallCanvas.width = targetW;
            smallCanvas.height = targetH;
            smallCtx.imageSmoothingEnabled = true;
            smallCtx.imageSmoothingQuality = 'medium';
            smallCtx.drawImage(srcCanvas, 0, 0, targetW, targetH);

            // Step 3: Extract palette from downscaled image
            const smallImageData = smallCtx.getImageData(0, 0, targetW, targetH);
            const palette = extractPalette(smallImageData, paletteColors);

            // Step 4: Apply dithering with palette quantization
            if (ditherMode === 'none') {
                applyNoDither(smallImageData, palette);
            } else if (ditherMode === 'floyd') {
                applyFloydSteinberg(smallImageData, palette);
            } else {
                // Ordered dithering
                let matrix;
                if (ditherMode === 'bayer2') matrix = BAYER_2x2;
                else if (ditherMode === 'bayer8') matrix = BAYER_8x8;
                else matrix = BAYER_4x4;

                applyOrderedDither(smallImageData, palette, matrix, ditherStrength);
            }

            smallCtx.putImageData(smallImageData, 0, 0);

            // Step 5: Upscale back with nearest-neighbor (crisp pixels)
            const outputCanvas = document.createElement('canvas');
            const outputCtx = outputCanvas.getContext('2d');
            outputCanvas.width = srcCanvas.width;
            outputCanvas.height = srcCanvas.height;
            outputCtx.imageSmoothingEnabled = false;
            outputCtx.drawImage(smallCanvas, 0, 0, outputCanvas.width, outputCanvas.height);

            // Update layer image
            const newImg = new Image();
            newImg.onload = () => {
                layer.image = newImg;
                layer.pixelified = true;
                renderBackgroundPreview();
                showToast(`Retro effect applied (${targetW}${targetH}, ${paletteColors} colors)`);
            };
            newImg.src = outputCanvas.toDataURL();
        }

        function resetPixelify() {
            if (state.selectedBgLayer < 0) return;

            const layer = state.backgrounds[state.selectedBgLayer];
            if (!layer.originalImageData) {
                showToast('No original to restore');
                return;
            }

            // Restore from original
            const canvas = document.createElement('canvas');
            canvas.width = layer.originalImageData.width;
            canvas.height = layer.originalImageData.height;
            const ctx = canvas.getContext('2d');
            ctx.putImageData(layer.originalImageData, 0, 0);

            const newImg = new Image();
            newImg.onload = () => {
                layer.image = newImg;
                layer.pixelified = false;
                renderBackgroundPreview();
                showToast('Reset to original');
            };
            newImg.src = canvas.toDataURL();
        }

        elements.applyPixelify.addEventListener('click', applyPixelifyEffect);
        elements.resetPixelify.addEventListener('click', resetPixelify);
        elements.pixelifyBtn.addEventListener('click', () => {
            // Just focus on the pixelify settings - they're already visible
            showToast('Adjust settings and click Apply');
        });

        // ==========================================
        // Tile Painter
        // ==========================================
        function initVisualTiles() {
            state.visualTiles = [];
            for (let y = 0; y < state.gridHeight; y++) {
                const row = [];
                for (let x = 0; x < state.gridWidth; x++) {
                    row.push(null);
                }
                state.visualTiles.push(row);
            }
        }

        async function loadSpriteIndex() {
            try {
                const response = await fetch('/assets/sprites/sprite-index.json');
                if (response.ok) {
                    const data = await response.json();
                    state.spriteSheets = data;
                }
            } catch (e) {
                console.warn('Could not load sprite index:', e);
            }
            populateSpriteSheetSelect();
        }

        async function loadMasterSheet(projectId) {
            if (!projectId) {
                state.masterTileSheetAtlas = null;
                state.masterTileSheetImage = null;
                state.masterSpriteSheetAtlas = null;
                state.masterSpriteSheetImage = null;
                state.tileGroups = [];
                state.currentProjectId = null;
                populateSpriteSheetSelect();
                return;
            }

            try {
                // Load both master sheets and groups in parallel
                const promises = [
                    crucibleClient.getTileGroups ? crucibleClient.getTileGroups(projectId) : Promise.resolve([])
                ];

                // Try new separate sheet methods first
                if (crucibleClient.getMasterTileSheet) {
                    promises.push(crucibleClient.getMasterTileSheet(projectId).catch(e => {
                        console.warn('Could not load master tile sheet:', e.message);
                        return { png: null, atlas: { sprites: {} } };
                    }));
                } else {
                    promises.push(Promise.resolve({ png: null, atlas: { sprites: {} } }));
                }

                promises.push(crucibleClient.getMasterSpriteSheet(projectId).catch(e => {
                    console.warn('Could not load master sprite sheet:', e.message);
                    return { png: null, atlas: { sprites: {} } };
                }));

                // Load master background sheet
                promises.push(crucibleClient.getMasterBackgroundSheet(projectId).catch(e => {
                    console.warn('Could not load master background sheet:', e.message);
                    return { png: null, atlas: { backgrounds: {} } };
                }));

                const [groups, masterTileSheet, masterSpriteSheet, masterBgSheet] = await Promise.all(promises);

                state.tileGroups = groups || [];
                state.currentProjectId = projectId;

                // Helper to load image from sheet data
                async function loadSheetImage(sheet) {
                    if (!sheet.png || !sheet.atlas || Object.keys(sheet.atlas.sprites || {}).length === 0) {
                        return { atlas: null, image: null };
                    }
                    const img = new Image();
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = reject;
                        img.src = sheet.png;
                    });
                    return { atlas: sheet.atlas, image: img };
                }

                // Load master tile sheet
                const tileResult = await loadSheetImage(masterTileSheet);
                state.masterTileSheetAtlas = tileResult.atlas;
                state.masterTileSheetImage = tileResult.image;

                // Load master sprite sheet
                const spriteResult = await loadSheetImage(masterSpriteSheet);
                state.masterSpriteSheetAtlas = spriteResult.atlas;
                state.masterSpriteSheetImage = spriteResult.image;

                // Load master background sheet
                if (masterBgSheet.png && masterBgSheet.atlas && Object.keys(masterBgSheet.atlas.backgrounds || {}).length > 0) {
                    state.bgLibrary = masterBgSheet.atlas.backgrounds;
                    const bgImg = new Image();
                    await new Promise((resolve, reject) => {
                        bgImg.onload = resolve;
                        bgImg.onerror = reject;
                        bgImg.src = masterBgSheet.png;
                    });
                    state.bgLibrarySheet = bgImg;
                } else {
                    state.bgLibrary = {};
                    state.bgLibrarySheet = null;
                }

                populateSpriteSheetSelect();

                // Auto-select master tiles if available
                if (state.masterTileSheetAtlas && Object.keys(state.masterTileSheetAtlas.sprites).length > 0) {
                    elements.spriteSheetSelect.value = '__master_tiles__';
                    loadSpriteSheet('__master_tiles__');
                } else if (state.masterSpriteSheetAtlas && Object.keys(state.masterSpriteSheetAtlas.sprites).length > 0) {
                    elements.spriteSheetSelect.value = '__master_sprites__';
                    loadSpriteSheet('__master_sprites__');
                }
            } catch (err) {
                console.error('Failed to load master sheets:', err);
                state.masterTileSheetAtlas = null;
                state.masterTileSheetImage = null;
                state.masterSpriteSheetAtlas = null;
                state.masterSpriteSheetImage = null;
                state.tileGroups = [];
                state.bgLibrary = {};
                state.bgLibrarySheet = null;
            }
        }

        function populateSpriteSheetSelect() {
            const sheetNames = Object.keys(state.spriteSheets);
            const hasMasterTileSheet = state.masterTileSheetAtlas &&
                Object.keys(state.masterTileSheetAtlas.sprites).length > 0;

            let options = '<option value="">-- Select Sheet --</option>';

            // Add master tile sheet option if available
            if (hasMasterTileSheet) {
                const tileCount = Object.keys(state.masterTileSheetAtlas.sprites).length;
                options += `<option value="__master_tiles__">Master Tiles (${tileCount})</option>`;
            }

            // Add other sheets
            options += sheetNames.map(name => `<option value="${name}">${name}</option>`).join('');

            if (!hasMasterTileSheet && sheetNames.length === 0) {
                options = '<option value="">No sheets available - publish tiles in Tilesmith</option>';
            }

            elements.spriteSheetSelect.innerHTML = options;
        }

        async function loadSpriteSheet(sheetName) {
            if (!sheetName) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Select a tile sheet to load tiles</div>';
                return;
            }

            // Handle master tile sheet
            if (sheetName === '__master_tiles__') {
                if (!state.masterTileSheetAtlas || !state.masterTileSheetImage) {
                    elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Master tile sheet not loaded</div>';
                    return;
                }
                state.selectedSpriteSheet = '__master_tiles__';
                renderSpritePalette();
                return;
            }

            // Handle master sprite sheet
            if (sheetName === '__master_sprites__') {
                if (!state.masterSpriteSheetAtlas || !state.masterSpriteSheetImage) {
                    elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Master sprite sheet not loaded</div>';
                    return;
                }
                state.selectedSpriteSheet = '__master_sprites__';
                renderSpritePalette();
                return;
            }

            // Handle regular sprite sheets
            if (!state.spriteSheets[sheetName]) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Select a sprite sheet to load sprites</div>';
                return;
            }

            const sheetData = state.spriteSheets[sheetName];

            // Load image if not already loaded
            if (!state.spriteImages[sheetName]) {
                const img = new Image();
                img.src = sheetData.path || `/assets/sprites/${sheetName}.png`;
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => {
                        console.warn('Could not load sprite sheet:', sheetName);
                        reject();
                    };
                }).catch(() => {
                    elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Could not load sprite sheet image</div>';
                    return;
                });
                state.spriteImages[sheetName] = img;
            }

            state.selectedSpriteSheet = sheetName;
            renderSpritePalette();
        }

        function renderSpritePalette() {
            const sheetName = state.selectedSpriteSheet;

            // Handle master tile sheet
            if (sheetName === '__master_tiles__') {
                renderMasterSheetPalette(state.masterTileSheetAtlas, state.masterTileSheetImage, true);
                return;
            }

            // Handle master sprite sheet
            if (sheetName === '__master_sprites__') {
                renderMasterSheetPalette(state.masterSpriteSheetAtlas, state.masterSpriteSheetImage, false);
                return;
            }

            if (!sheetName || !state.spriteSheets[sheetName]) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">Select a sprite sheet</div>';
                return;
            }

            const sheetData = state.spriteSheets[sheetName];
            const sheetImage = state.spriteImages[sheetName];
            const sprites = sheetData.sprites || [];

            if (sprites.length === 0) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">No sprites in this sheet</div>';
                return;
            }

            elements.paletteGrid.innerHTML = sprites.map((sprite, index) => {
                const isSelected = state.selectedSprite &&
                    state.selectedSprite.sheetName === sheetName &&
                    state.selectedSprite.name === sprite.name;
                return `<div class="palette-sprite ${isSelected ? 'selected' : ''}"
                            data-sheet="${sheetName}"
                            data-sprite="${sprite.name}"
                            data-index="${index}"
                            title="${sprite.name}"></div>`;
            }).join('');

            // Draw sprite thumbnails
            elements.paletteGrid.querySelectorAll('.palette-sprite').forEach((el, index) => {
                const sprite = sprites[index];
                const canvas = document.createElement('canvas');
                const size = 36;
                const scale = Math.min(size / sprite.width, size / sprite.height, 2);
                canvas.width = Math.floor(sprite.width * scale);
                canvas.height = Math.floor(sprite.height * scale);

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                    sheetImage,
                    sprite.x, sprite.y, sprite.width, sprite.height,
                    0, 0, canvas.width, canvas.height
                );

                const img = document.createElement('img');
                img.src = canvas.toDataURL();
                el.appendChild(img);

                el.addEventListener('click', () => selectSprite(sheetName, sprite));
            });
        }

        function renderMasterSheetPalette(atlas, image, showGroups = true) {
            if (!atlas || !image) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">No sheet loaded</div>';
                return;
            }

            const sprites = atlas.sprites;
            const spriteNames = Object.keys(sprites);

            if (spriteNames.length === 0 && (!showGroups || state.tileGroups.length === 0)) {
                elements.paletteGrid.innerHTML = '<div class="no-sprites-message">No tiles in this sheet</div>';
                return;
            }

            let html = '';

            // Render groups section only if showGroups is true and we have groups
            if (showGroups && state.tileGroups.length > 0) {
                html += '<div class="palette-section-header">Groups</div>';
                html += '<div class="palette-groups">';
                html += state.tileGroups.map(group => {
                    const isSelected = state.selectedGroup && state.selectedGroup.id === group.id;
                    return `<div class="palette-group ${isSelected ? 'selected' : ''}"
                                data-group-id="${group.id}"
                                title="${group.name} (${group.cols}${group.rows})">
                                <canvas class="group-preview"></canvas>
                                <span class="group-name">${group.name}</span>
                            </div>`;
                }).join('');
                html += '</div>';
            }

            // Render tiles/sprites section
            if (spriteNames.length > 0) {
                const sectionTitle = showGroups ? 'Tiles' : 'Sprites';
                html += `<div class="palette-section-header">${sectionTitle}</div>`;
                html += '<div class="palette-tiles">';
                html += spriteNames.map(name => {
                    const sprite = sprites[name];
                    const currentSheet = state.selectedSpriteSheet;
                    const isSelected = state.selectedSprite &&
                        state.selectedSprite.sheetName === currentSheet &&
                        state.selectedSprite.name === name &&
                        !state.selectedGroup;
                    return `<div class="palette-sprite ${isSelected ? 'selected' : ''}"
                                data-sheet="${state.selectedSpriteSheet}"
                                data-sprite="${name}"
                                title="${name}"></div>`;
                }).join('');
                html += '</div>';
            }

            elements.paletteGrid.innerHTML = html;

            // Draw group previews (only for tile sheets)
            if (showGroups) {
                elements.paletteGrid.querySelectorAll('.palette-group').forEach((el) => {
                    const groupId = el.dataset.groupId;
                    const group = state.tileGroups.find(g => g.id === groupId);
                    if (!group) return;

                    const canvas = el.querySelector('canvas');
                    const tileSize = 16;
                    canvas.width = group.cols * tileSize;
                    canvas.height = group.rows * tileSize;

                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    // Render group preview using master tile sheet (groups reference tiles)
                    const arrangement = group.arrangement || [];
                    const tileSheetAtlas = state.masterTileSheetAtlas;
                    const tileSheetImage = state.masterTileSheetImage;
                    const tileSprites = tileSheetAtlas?.sprites || sprites;

                    for (let row = 0; row < group.rows; row++) {
                        for (let col = 0; col < group.cols; col++) {
                            const tileName = arrangement[row]?.[col];
                            if (tileName && tileSprites[tileName]) {
                                const spriteDef = tileSprites[tileName];
                                ctx.drawImage(
                                    tileSheetImage || sheetImage,
                                    spriteDef.x, spriteDef.y, spriteDef.w, spriteDef.h,
                                    col * tileSize, row * tileSize, tileSize, tileSize
                                );
                            }
                        }
                    }

                    el.addEventListener('click', () => selectGroup(group));
                });
            }

            // Draw tile/sprite thumbnails
            // For tiles, explicitly use the tile sheet image from state (same as group preview)
            const thumbnailImage = showGroups
                ? (state.masterTileSheetImage || sheetImage)
                : sheetImage;

            elements.paletteGrid.querySelectorAll('.palette-sprite').forEach((el) => {
                const spriteName = el.dataset.sprite;
                const spriteDef = sprites[spriteName];
                if (!spriteDef || !thumbnailImage) return;

                // Render at original size for crisp pixelated scaling
                const canvas = document.createElement('canvas');
                canvas.width = spriteDef.w;
                canvas.height = spriteDef.h;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(
                    thumbnailImage,
                    spriteDef.x, spriteDef.y, spriteDef.w, spriteDef.h,
                    0, 0, spriteDef.w, spriteDef.h
                );

                const img = document.createElement('img');
                img.src = canvas.toDataURL();
                el.appendChild(img);

                // Convert sprite format to standard format for selection
                const currentSheet = state.selectedSpriteSheet;
                el.addEventListener('click', () => selectSprite(currentSheet, {
                    name: spriteName,
                    x: spriteDef.x,
                    y: spriteDef.y,
                    width: spriteDef.w,
                    height: spriteDef.h,
                    source: spriteDef.source
                }));
            });
        }

        function selectGroup(group) {
            state.selectedGroup = group;
            state.selectedSprite = null;

            // Update palette selection
            elements.paletteGrid.querySelectorAll('.palette-group').forEach(el => {
                el.classList.toggle('selected', el.dataset.groupId === group.id);
            });
            elements.paletteGrid.querySelectorAll('.palette-sprite').forEach(el => {
                el.classList.remove('selected');
            });

            // Update preview with group
            renderSelectedGroupPreview();
            elements.selectedSpriteName.value = group.name;
        }

        function renderSelectedGroupPreview() {
            if (!state.selectedGroup) return;

            const group = state.selectedGroup;
            const sprites = state.masterTileSheetAtlas?.sprites || {};
            const arrangement = group.arrangement || [];

            const tileSize = 16;
            const canvas = document.createElement('canvas');
            canvas.width = group.cols * tileSize;
            canvas.height = group.rows * tileSize;

            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            for (let row = 0; row < group.rows; row++) {
                for (let col = 0; col < group.cols; col++) {
                    const tileName = arrangement[row]?.[col];
                    if (tileName && sprites[tileName]) {
                        const spriteDef = sprites[tileName];
                        ctx.drawImage(
                            state.masterTileSheetImage,
                            spriteDef.x, spriteDef.y, spriteDef.w, spriteDef.h,
                            col * tileSize, row * tileSize, tileSize, tileSize
                        );
                    }
                }
            }

            const img = document.createElement('img');
            img.src = canvas.toDataURL();
            img.style.imageRendering = 'pixelated';
            img.style.maxWidth = '64px';
            img.style.maxHeight = '64px';

            elements.selectedSpritePreview.innerHTML = '';
            elements.selectedSpritePreview.appendChild(img);
        }

        function selectSprite(sheetName, sprite) {
            state.selectedSprite = { sheetName, ...sprite };
            state.selectedGroup = null;  // Clear group selection when selecting a sprite

            // Update palette selection
            elements.paletteGrid.querySelectorAll('.palette-sprite').forEach(el => {
                el.classList.toggle('selected',
                    el.dataset.sheet === sheetName && el.dataset.sprite === sprite.name);
            });
            // Clear group selection styling
            elements.paletteGrid.querySelectorAll('.palette-group').forEach(el => {
                el.classList.remove('selected');
            });

            // Update preview
            renderSelectedSpritePreview();
            elements.selectedSpriteName.value = sprite.name;
        }

        function renderSelectedSpritePreview() {
            if (!state.selectedSprite) {
                elements.selectedSpritePreview.innerHTML = '<span class="no-sprites-message">No tile selected</span>';
                return;
            }

            const sprite = state.selectedSprite;
            let sheetImage;
            if (sprite.sheetName === '__master_tiles__') {
                sheetImage = state.masterTileSheetImage;
            } else if (sprite.sheetName === '__master_sprites__') {
                sheetImage = state.masterSpriteSheetImage;
            } else {
                sheetImage = state.spriteImages[sprite.sheetName];
            }
            if (!sheetImage) return;

            const canvas = document.createElement('canvas');
            const maxSize = 64;
            const scale = Math.min(maxSize / sprite.width, maxSize / sprite.height, 4);
            canvas.width = Math.floor(sprite.width * scale);
            canvas.height = Math.floor(sprite.height * scale);

            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(
                sheetImage,
                sprite.x, sprite.y, sprite.width, sprite.height,
                0, 0, canvas.width, canvas.height
            );

            const img = document.createElement('img');
            img.src = canvas.toDataURL();
            elements.selectedSpritePreview.innerHTML = '';
            elements.selectedSpritePreview.appendChild(img);
        }

        function paintVisualTile(x, y) {
            // Handle group stamps
            if (state.selectedGroup) {
                paintGroupStamp(x, y);
                return;
            }

            if (!state.selectedSprite) return;
            if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;

            state.visualTiles[y][x] = {
                spriteSheet: state.selectedSprite.sheetName,
                spriteName: state.selectedSprite.name,
                x: state.selectedSprite.x,
                y: state.selectedSprite.y,
                width: state.selectedSprite.width,
                height: state.selectedSprite.height
            };

            renderTileCanvas();
            updateJsonOutput();
        }

        // Paint a group stamp (multiple tiles at once)
        function paintGroupStamp(startX, startY) {
            const tileAtlas = state.masterTileSheetAtlas;
            if (!state.selectedGroup || !tileAtlas) return;

            const group = state.selectedGroup;
            const arrangement = group.arrangement || [];
            const sprites = tileAtlas.sprites;

            // Place each tile in the group arrangement
            for (let row = 0; row < group.rows; row++) {
                for (let col = 0; col < group.cols; col++) {
                    const tileName = arrangement[row]?.[col];
                    if (!tileName) continue;

                    const spriteDef = sprites[tileName];
                    if (!spriteDef) continue;

                    const targetX = startX + col;
                    const targetY = startY + row;

                    // Skip if out of bounds
                    if (targetX < 0 || targetX >= state.gridWidth) continue;
                    if (targetY < 0 || targetY >= state.gridHeight) continue;

                    state.visualTiles[targetY][targetX] = {
                        spriteSheet: '__master_tiles__',
                        spriteName: tileName,
                        x: spriteDef.x,
                        y: spriteDef.y,
                        width: spriteDef.w,
                        height: spriteDef.h
                    };
                }
            }

            renderTileCanvas();
            updateJsonOutput();
        }

        function eraseVisualTile(x, y) {
            if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;
            state.visualTiles[y][x] = null;
            renderTileCanvas();
            updateJsonOutput();
        }

        function fillVisualTiles(startX, startY) {
            if (!state.selectedSprite) return;
            const originalTile = state.visualTiles[startY]?.[startX];
            const originalKey = originalTile ?
                `${originalTile.spriteSheet}:${originalTile.spriteName}` : null;

            const newKey = `${state.selectedSprite.sheetName}:${state.selectedSprite.name}`;
            if (originalKey === newKey) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) continue;

                const currentTile = state.visualTiles[y][x];
                const currentKey = currentTile ?
                    `${currentTile.spriteSheet}:${currentTile.spriteName}` : null;
                if (currentKey !== originalKey) continue;

                visited.add(key);
                paintVisualTile(x, y);

                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
        }

        function clearVisualTiles() {
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    state.visualTiles[y][x] = null;
                }
            }
            renderTileCanvas();
            updateJsonOutput();
            showToast('Visual tiles cleared');
        }

        function renderTileCanvas() {
            const canvas = elements.tileCanvas;
            const ctx = canvas.getContext('2d');
            const tileSize = state.tileSize;

            canvas.width = state.gridWidth * tileSize;
            canvas.height = state.gridHeight * tileSize;
            ctx.imageSmoothingEnabled = false;

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw collision grid as semi-transparent underlay
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = state.tiles[y]?.[x];
                    ctx.globalAlpha = 0.3;
                    if (tile === 'open') {
                        ctx.fillStyle = '#2a5a30';
                    } else if (tile === 'obstruction') {
                        ctx.fillStyle = '#6a2a2a';
                    } else if (tile === 'spawn') {
                        ctx.fillStyle = '#2a4a6a';
                    } else {
                        ctx.fillStyle = '#1a1a2e';
                    }
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            ctx.globalAlpha = 1;

            // Draw visual tiles
            for (let y = 0; y < state.gridHeight; y++) {
                for (let x = 0; x < state.gridWidth; x++) {
                    const tile = state.visualTiles[y]?.[x];
                    if (!tile) continue;

                    // Get the correct sheet image based on sheet type
                    let sheetImage;
                    if (tile.spriteSheet === '__master_tiles__') {
                        sheetImage = state.masterTileSheetImage;
                    } else if (tile.spriteSheet === '__master_sprites__') {
                        sheetImage = state.masterSpriteSheetImage;
                    } else {
                        sheetImage = state.spriteImages[tile.spriteSheet];
                    }
                    if (!sheetImage) continue;

                    ctx.drawImage(
                        sheetImage,
                        tile.x, tile.y, tile.width, tile.height,
                        x * tileSize, y * tileSize, tileSize, tileSize
                    );
                }
            }

            // Draw grid lines
            ctx.strokeStyle = 'rgba(106, 106, 142, 0.25)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= state.gridWidth; x++) {
                ctx.beginPath();
                ctx.moveTo(x * tileSize + 0.5, 0);
                ctx.lineTo(x * tileSize + 0.5, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= state.gridHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * tileSize + 0.5);
                ctx.lineTo(canvas.width, y * tileSize + 0.5);
                ctx.stroke();
            }
        }

        // Tile canvas mouse handlers
        function getTileFromCanvasEvent(e) {
            const canvas = elements.tileCanvas;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = Math.floor((e.clientX - rect.left) * scaleX / state.tileSize);
            const y = Math.floor((e.clientY - rect.top) * scaleY / state.tileSize);
            return { x, y };
        }

        elements.tileCanvas.addEventListener('mousedown', (e) => {
            state.tileMouseDown = true;
            const { x, y } = getTileFromCanvasEvent(e);

            if (state.currentTileTool === 'paint') {
                paintVisualTile(x, y);
            } else if (state.currentTileTool === 'erase') {
                eraseVisualTile(x, y);
            } else if (state.currentTileTool === 'fill') {
                fillVisualTiles(x, y);
            }
        });

        elements.tileCanvas.addEventListener('mousemove', (e) => {
            if (!state.tileMouseDown) return;
            const { x, y } = getTileFromCanvasEvent(e);

            if (state.currentTileTool === 'paint') {
                paintVisualTile(x, y);
            } else if (state.currentTileTool === 'erase') {
                eraseVisualTile(x, y);
            }
        });

        document.addEventListener('mouseup', () => {
            state.tileMouseDown = false;
        });

        // Tile tool buttons
        document.querySelectorAll('[data-tile-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                state.currentTileTool = btn.dataset.tileTool;
                document.querySelectorAll('[data-tile-tool]').forEach(b => {
                    b.classList.toggle('active', b.dataset.tileTool === state.currentTileTool);
                });
            });
        });

        elements.spriteSheetSelect.addEventListener('change', (e) => {
            loadSpriteSheet(e.target.value);
        });

        elements.clearTilesBtn.addEventListener('click', clearVisualTiles);

        // ==========================================
        // Project Selection (Header)
        // ==========================================
        let allProjects = [];
        let selectedProject = null;

        async function loadProjects() {
            try {
                const crucible = await getCrucible();
                if (!crucible.isConfigured()) {
                    console.warn('Crucible not configured');
                    return;
                }

                allProjects = await crucible.getProjects();

                elements.projectSelect.innerHTML = '<option value="">-- Select Project --</option>';
                allProjects.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = p.name;
                    elements.projectSelect.appendChild(opt);
                });

                // Restore last selected project
                const lastProject = localStorage.getItem('levelforge_project');
                if (lastProject && allProjects.find(p => p.id === lastProject)) {
                    elements.projectSelect.value = lastProject;
                    await selectProject(lastProject);
                }
            } catch (err) {
                console.error('Failed to load projects:', err);
            }
        }

        async function selectProject(projectId) {
            if (!projectId) {
                selectedProject = null;
                elements.sendToCrucibleBtn.disabled = true;
                state.currentProjectId = null;
                state.tileSize = 16;  // Reset to default
                populateSpriteSheetSelect();
                updateTileSizeDisplay();
                return;
            }

            selectedProject = allProjects.find(p => p.id === projectId);
            localStorage.setItem('levelforge_project', projectId);
            elements.sendToCrucibleBtn.disabled = false;

            // Load project settings to get tile size
            try {
                const crucible = await getCrucible();
                const settings = await crucible.getProjectSettings(projectId);
                state.tileSize = settings.tileDefaults?.size || 16;
                updateTileSizeDisplay();
            } catch (err) {
                console.warn('Could not load project settings:', err);
                state.tileSize = 16;
            }

            // Load master sheet for this project
            await loadMasterSheet(projectId);
        }

        elements.projectSelect.addEventListener('change', (e) => {
            selectProject(e.target.value);
        });

        // ==========================================
        // Crucible Integration (Send Modal)
        // ==========================================
        const crucibleElements = {
            modal: document.getElementById('crucibleModal'),
            projectName: document.getElementById('crucibleProjectName'),
            levelSelect: document.getElementById('crucibleLevelSelect'),
            status: document.getElementById('crucibleStatus'),
            confirmBtn: document.getElementById('confirmCrucibleBtn'),
            cancelBtn: document.getElementById('cancelCrucibleBtn')
        };

        let crucibleLevels = [];
        let selectedCrucibleLevel = null;

        async function openCrucibleModal() {
            if (!selectedProject) {
                showToast('Select a project first');
                return;
            }

            crucibleElements.modal.classList.add('active');
            crucibleElements.projectName.textContent = selectedProject.name;
            crucibleElements.status.textContent = 'Loading levels...';
            crucibleElements.confirmBtn.disabled = true;

            try {
                const crucible = await getCrucible();
                crucibleLevels = await crucible.getLevels(selectedProject.id);

                if (crucibleLevels.length === 0) {
                    crucibleElements.levelSelect.innerHTML = '<option value="">No levels - create one in Crucible first</option>';
                    crucibleElements.levelSelect.disabled = true;
                    crucibleElements.status.textContent = 'Create a level in Crucible first.';
                    return;
                }

                crucibleElements.levelSelect.disabled = false;
                crucibleElements.levelSelect.innerHTML = '<option value="">Select a level...</option>' +
                    crucibleLevels.map(l => `<option value="${l.id}">${l.name} (${l.width}x${l.height})</option>`).join('');

                // Check for saved context
                const ctx = crucible.getContext();
                if (ctx.projectId === selectedProject.id && ctx.levelSlug) {
                    const level = crucibleLevels.find(l => l.slug === ctx.levelSlug);
                    if (level) {
                        crucibleElements.levelSelect.value = level.id;
                        selectedCrucibleLevel = level;
                        crucibleElements.confirmBtn.disabled = false;
                    }
                }

                crucibleElements.status.textContent = '';
            } catch (err) {
                console.error('Failed to load Crucible data:', err);
                crucibleElements.status.textContent = 'Failed to load: ' + err.message;
            }
        }

        async function sendToCrucible() {
            if (!selectedProject || !selectedCrucibleLevel) return;

            crucibleElements.confirmBtn.disabled = true;
            crucibleElements.status.textContent = 'Sending data...';

            try {
                const crucible = await getCrucible();
                const levelId = selectedCrucibleLevel.id;

                // Generate level data (reuse existing function)
                const levelData = generateLevelData();

                // Save grid data
                await crucible.saveGridData(
                    levelId,
                    levelData.grid,
                    levelData.spawn,
                    levelData.walkable,
                    levelData.obstructions,
                    levelData.physics
                );

                // Save background layers
                const bgLayers = state.backgrounds.map(layer => ({
                    name: layer.name,
                    imageSrc: layer.imageSrc,
                    depth: layer.depth,
                    scrollRate: layer.scrollRate,
                    offsetX: layer.offsetX,
                    offsetY: layer.offsetY,
                    scale: layer.scale,
                    visible: layer.visible,
                    pixelifyConfig: layer.pixelified ? state.pixelifySettings : null
                }));
                await crucible.saveBackgroundLayers(levelId, bgLayers);

                // Save visual tiles
                await crucible.saveTileData(levelId, levelData.visualTiles);

                // Save spawns
                if (levelData.spawns && levelData.spawns.length > 0) {
                    await crucible.saveSpawns(levelId, levelData.spawns);
                }

                // Save exits (includes both exits and returns)
                if (levelData.exits && levelData.exits.length > 0) {
                    await crucible.saveExits(levelId, levelData.exits);
                }

                // Update context
                crucible.setContext(selectedProject.id, levelId, selectedCrucibleLevel.slug);

                crucibleElements.modal.classList.remove('active');
                showToast('Level data sent to Crucible!');
            } catch (err) {
                console.error('Failed to send to Crucible:', err);
                crucibleElements.status.textContent = 'Failed: ' + err.message;
                crucibleElements.confirmBtn.disabled = false;
            }
        }

        // Crucible modal event listeners
        elements.sendToCrucibleBtn.addEventListener('click', openCrucibleModal);

        crucibleElements.levelSelect.addEventListener('change', (e) => {
            selectedCrucibleLevel = crucibleLevels.find(l => l.id === e.target.value) || null;
            crucibleElements.confirmBtn.disabled = !selectedCrucibleLevel;
        });

        crucibleElements.confirmBtn.addEventListener('click', sendToCrucible);

        crucibleElements.cancelBtn.addEventListener('click', () => {
            crucibleElements.modal.classList.remove('active');
        });

        crucibleElements.modal.addEventListener('click', (e) => {
            if (e.target === crucibleElements.modal) {
                crucibleElements.modal.classList.remove('active');
            }
        });

        // ==========================================
        // Initialize
        // ==========================================
        (async function() {
            // Check if user has projects (displays gate if not)
            const hasProject = await checkProjectGate();
            if (!hasProject) return;

            // Initialize auth
            await crucibleClient.init();
            state.user = await crucibleClient.getUser();
            updateAuthIndicator();

            // Listen for auth changes
            crucibleClient.onAuthStateChange((event, session) => {
                state.user = session?.user || null;
                updateAuthIndicator();
            });

            initGrid();
            initVisualTiles();
            loadSpriteIndex();
            loadProjects();
            initGenerationQueue();
        })();

        // ==========================================
        // AI Generation Queue
        // ==========================================
        function initGenerationQueue() {
            if (typeof GenerationQueue !== 'undefined' && elements.generationQueuePanel) {
                state.generationQueue = new GenerationQueue(elements.generationQueuePanel, {
                    onImport: handleGeneratedTileset,
                    onError: (error) => showToast(error)
                });
            }

            // Generate tileset button
            if (elements.generateTilesetBtn) {
                elements.generateTilesetBtn.addEventListener('click', showTilesetGenerationInfo);
            }
        }

        function showTilesetGenerationInfo() {
            showToast('Tileset generation coming soon! Use Tilesmith for single tiles.');
        }

        async function handleGeneratedTileset(job) {
            if (!job.result_url) {
                showToast('No result URL available');
                return;
            }
            showToast('Tileset ready! Import via Sprite-Rite.');
        }

        // Initialize help drawer
        if (typeof HelpDrawer !== 'undefined' && typeof LEVEL_FORGE_DOCS !== 'undefined') {
            HelpDrawer.init({
                toolId: 'level-forge',
                toolName: 'Level Forge',
                toolIcon: '&#128293;',
                accentColor: '#e07020',
                docs: LEVEL_FORGE_DOCS
            });
        }
    </script>
</body>
</html>
