<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tilesmith | Game Wizard</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           TILESMITH - CSS
           ============================================ */

        :root {
            /* Backgrounds */
            --bg-deep: #0d0d14;
            --bg-mid: #1a1a2e;
            --bg-surface: #252542;

            /* Accents - forest green */
            --accent-green: #40d080;
            --accent-green-glow: #60f0a0;
            --accent-dark: #2a6a4a;

            /* Stone/neutral tones */
            --stone-dark: #3a3a5c;
            --stone-mid: #6a6a8e;
            --stone-light: #9a9abe;
            --stone-bright: #d0d0e8;

            /* Status colors */
            --success: #4ade80;
            --error: #f87171;
            --warning: #fbbf24;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--stone-light);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .home-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            font-size: 18px;
            text-decoration: none;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .home-btn:hover {
            background: var(--stone-dark);
            border-color: var(--accent-green);
        }

        .brand-icon {
            font-size: 20px;
        }

        .brand-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .brand-text span {
            color: var(--accent-green);
            text-shadow: 0 0 10px rgba(64, 208, 128, 0.5);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-select {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-light);
            cursor: pointer;
            min-width: 140px;
        }

        .header-select:focus {
            outline: none;
            border-color: var(--accent-green);
        }

        .auth-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .auth-indicator.logged-in {
            border-color: var(--accent-green);
            color: var(--stone-light);
        }

        .auth-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--stone-dark);
        }

        .auth-indicator.logged-in .auth-dot {
            background: var(--success);
        }

        .save-indicator {
            font-size: 10px;
            color: var(--stone-mid);
            min-width: 60px;
            text-align: right;
        }

        .save-indicator.saving { color: var(--warning); }
        .save-indicator.saved { color: var(--success); }
        .save-indicator.master { color: var(--fire-bright); }
        .save-indicator.draft { color: var(--water-bright, #6dc2ca); }

        /* Buttons */
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--stone-dark);
            border-color: var(--stone-mid);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--accent-green-glow);
            border-color: var(--accent-green-glow);
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 300px;
            height: calc(100vh - 53px);
        }

        /* Left Panel - Canvas */
        .left-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 16px;
            gap: 16px;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            min-height: 0;
        }

        .canvas-wrapper {
            position: relative;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            overflow: hidden;
        }

        #mainCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }

        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        .canvas-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .zoom-group {
            display: flex;
            gap: 2px;
        }

        .zoom-btn {
            padding: 6px 10px;
            font-size: 11px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            color: var(--stone-mid);
            cursor: pointer;
            transition: all 0.2s;
        }

        .zoom-btn:first-child { border-radius: 4px 0 0 4px; }
        .zoom-btn:last-child { border-radius: 0 4px 4px 0; }

        .zoom-btn:hover {
            background: var(--stone-dark);
            color: var(--stone-light);
        }

        .zoom-btn.active {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-deep);
        }

        .grid-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .grid-toggle input {
            accent-color: var(--accent-green);
        }

        /* Quick Palette Bar */
        .quick-palette-bar {
            display: none;
            padding: 8px 12px;
            background: var(--bg-mid);
            border-top: 1px solid var(--stone-dark);
            gap: 8px;
            align-items: center;
        }

        .quick-palette-bar.open {
            display: flex;
        }

        .quick-palette-current {
            width: 28px;
            height: 28px;
            border: 2px solid var(--stone-mid);
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .quick-palette-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            flex: 1;
        }

        .quick-palette-swatch {
            width: 20px;
            height: 20px;
            border: 1px solid var(--stone-dark);
            border-radius: 2px;
            cursor: pointer;
            transition: transform 0.15s;
        }

        .quick-palette-swatch:hover {
            transform: scale(1.15);
        }

        .quick-palette-swatch.active {
            border-color: var(--stone-bright);
            box-shadow: 0 0 0 1px var(--stone-bright);
        }

        .palette-toggle-btn {
            position: relative;
        }

        .palette-toggle-btn .color-dot {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid var(--bg-deep);
        }

        /* Tile Library */
        .tile-library {
            border-top: 1px solid var(--stone-dark);
            padding-top: 12px;
        }

        .library-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .section-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Sheet Switcher */
        .sheet-switcher {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .sheet-tab {
            flex: 1;
            padding: 6px 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 7px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-mid);
            cursor: pointer;
            transition: all 0.15s;
        }

        .sheet-tab:hover {
            border-color: var(--stone-mid);
            color: var(--stone-bright);
        }

        .sheet-tab.active {
            background: var(--fire-mid);
            border-color: var(--fire-bright);
            color: var(--fire-bright);
        }

        .sheet-tab .tab-count {
            opacity: 0.7;
            margin-left: 4px;
        }

        .library-actions {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .library-actions .btn {
            flex: 1;
            font-size: 7px;
            padding: 4px 6px;
        }

        .library-grid {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-height: 100px;
            overflow-y: auto;
        }

        .library-empty {
            width: 100%;
            padding: 16px;
            text-align: center;
            color: var(--stone-mid);
            font-size: 10px;
            font-style: italic;
        }

        /* Groups Section */
        .groups-section {
            margin-bottom: 12px;
            display: none;
        }

        .groups-section.visible {
            display: block;
        }

        .groups-header, .tiles-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .section-subheader {
            font-family: 'Press Start 2P', cursive;
            font-size: 7px;
            color: var(--stone-mid);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-tiny {
            font-family: 'Press Start 2P', cursive;
            font-size: 6px;
            padding: 3px 6px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 3px;
            color: var(--stone-mid);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-tiny:hover {
            border-color: var(--stone-mid);
            color: var(--stone-bright);
        }

        .groups-grid {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-height: 80px;
            overflow-y: auto;
            margin-bottom: 8px;
        }

        .group-tile {
            min-width: 56px;
            min-height: 56px;
            max-width: 80px;
            max-height: 80px;
            background: var(--bg-surface);
            border: 2px solid var(--fire-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4px;
            position: relative;
        }

        .group-tile:hover {
            border-color: var(--fire-mid);
            transform: scale(1.05);
        }

        .group-tile.active {
            border-color: var(--fire-bright);
            box-shadow: 0 0 8px var(--fire-mid);
        }

        .group-tile canvas {
            image-rendering: pixelated;
        }

        .group-tile-name {
            font-size: 6px;
            color: var(--stone-mid);
            margin-top: 2px;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .group-tile-delete {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--fire-dark);
            border: none;
            color: var(--stone-bright);
            font-size: 10px;
            line-height: 1;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .group-tile:hover .group-tile-delete {
            opacity: 1;
        }

        .group-tile-delete:hover {
            background: var(--fire-mid);
        }

        .groups-empty {
            width: 100%;
            padding: 8px;
            text-align: center;
            color: var(--stone-mid);
            font-size: 8px;
            font-style: italic;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            padding: 4px 0;
            min-width: 150px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .context-menu-item {
            padding: 8px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--stone-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s;
        }

        .context-menu-item:hover {
            background: var(--stone-dark);
        }

        .context-menu-item.danger {
            color: var(--fire-mid);
        }

        .context-menu-item.danger:hover {
            background: var(--fire-dark);
            color: var(--fire-bright);
        }

        .context-menu-separator {
            height: 1px;
            background: var(--stone-dark);
            margin: 4px 0;
        }

        .library-tile {
            width: 48px;
            height: 48px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .library-tile:hover {
            border-color: var(--stone-mid);
        }

        .library-tile.active {
            border-color: var(--accent-green);
        }

        .library-tile canvas {
            image-rendering: pixelated;
        }

        .library-tile-new {
            font-size: 20px;
            color: var(--stone-mid);
        }

        .library-tile-delete {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: var(--error);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 10px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .library-tile:hover .library-tile-delete {
            display: flex;
        }

        /* Right Panel - Tools & Settings */
        .right-panel {
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border-left: 1px solid var(--stone-dark);
            overflow-y: auto;
        }

        .panel-section {
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .section-header {
            margin-bottom: 12px;
        }

        /* Toolbar (Level Forge style) */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-label {
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-right: 8px;
            font-weight: 500;
        }

        .toolbar-divider {
            width: 1px;
            height: 28px;
            background: var(--stone-dark);
        }

        .tool-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            padding: 0;
            border-radius: 4px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.15s;
        }

        .tool-btn:hover {
            border-color: var(--stone-mid);
            background: var(--stone-dark);
        }

        .tool-btn.active {
            border-color: var(--accent-green);
            background: var(--accent-dark);
            color: var(--accent-green);
        }

        /* Tileset controls */
        .tileset-input {
            width: 40px;
            padding: 6px 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-align: center;
            background: var(--bg-deep);
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .tileset-input:focus {
            outline: none;
            border-color: var(--accent-green);
        }

        .tileset-x {
            color: var(--stone-mid);
            font-size: 12px;
            margin: 0 2px;
        }

        /* Tile selector grid */
        .tile-selector {
            display: grid;
            gap: 2px;
            background: var(--stone-dark);
            padding: 2px;
            border-radius: 4px;
        }

        .tile-selector-cell {
            width: 24px;
            height: 24px;
            background: var(--bg-surface);
            border: 2px solid transparent;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--stone-mid);
        }

        .tile-selector-cell:hover {
            background: var(--stone-dark);
        }

        .tile-selector-cell.active {
            border-color: var(--accent-green);
            background: var(--accent-dark);
            color: var(--accent-green);
        }

        /* Palette */
        .current-color {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .current-color-swatch {
            width: 48px;
            height: 48px;
            border: 2px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
        }

        .current-color-info {
            flex: 1;
        }

        .current-color-hex {
            font-size: 13px;
            color: var(--stone-bright);
            font-weight: 600;
            font-family: monospace;
        }

        .current-color-family {
            font-size: 10px;
            color: var(--stone-mid);
            margin-top: 1px;
        }

        .current-color-name {
            font-size: 12px;
            color: var(--emerald);
            font-weight: 600;
            margin-top: 2px;
        }

        .current-color-desc {
            font-size: 10px;
            color: var(--stone-mid);
            font-style: italic;
        }

        /* Color tooltip for hover info */
        .color-tooltip {
            position: fixed;
            background: var(--stone-dark);
            border: 1px solid var(--stone-mid);
            border-radius: 4px;
            padding: 8px 10px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.15s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            min-width: 120px;
        }

        .color-tooltip.visible {
            opacity: 1;
        }

        .color-tooltip-swatch {
            width: 100%;
            height: 20px;
            border-radius: 2px;
            margin-bottom: 6px;
            border: 1px solid var(--stone-mid);
        }

        .color-tooltip-hex {
            font-size: 11px;
            font-family: monospace;
            color: var(--stone-bright);
            font-weight: 600;
        }

        .color-tooltip-family {
            font-size: 9px;
            color: var(--stone-mid);
            margin-top: 2px;
        }

        .color-tooltip-name {
            font-size: 11px;
            color: var(--emerald);
            font-weight: 600;
            margin-top: 3px;
        }

        .color-tooltip-desc {
            font-size: 9px;
            color: var(--stone-mid);
            font-style: italic;
            margin-top: 1px;
        }

        .palette-presets {
            margin-bottom: 12px;
        }

        .palette-presets select {
            width: 100%;
            padding: 8px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-light);
            font-family: inherit;
            font-size: 11px;
        }

        .palette-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }

        .palette-swatch {
            aspect-ratio: 1;
            border: 1px solid var(--stone-dark);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .palette-swatch:hover {
            transform: scale(1.1);
        }

        .palette-swatch.active {
            border-color: white;
            box-shadow: 0 0 4px white;
        }

        .palette-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        /* Tile Settings */
        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-green);
        }

        .form-row {
            display: flex;
            gap: 8px;
        }

        .form-row .form-group {
            flex: 1;
        }

        /* AI Assistant */
        .ai-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }

        .ai-generate-btn {
            width: 100%;
            margin-bottom: 12px;
        }

        .ai-spec-preview {
            flex: 1;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            padding: 12px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.5;
            min-height: 0;
        }

        .ai-spec-preview.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--stone-mid);
            text-align: center;
        }

        .ai-spec-name {
            color: var(--accent-green);
            font-weight: 600;
            margin-bottom: 8px;
        }

        .ai-spec-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 8px 0;
        }

        .ai-spec-color {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            border: 1px solid var(--stone-dark);
        }

        .ai-spec-apply {
            margin-top: 8px;
        }

        /* Export */
        .export-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-mid);
            border: 2px solid var(--stone-dark);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .modal-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--accent-green);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--stone-mid);
            font-size: 20px;
            cursor: pointer;
        }

        .modal-close:hover {
            color: var(--stone-light);
        }

        .modal-body {
            padding: 16px;
        }

        .modal-footer {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            padding: 16px;
            border-top: 1px solid var(--stone-dark);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 20px;
            background: var(--bg-surface);
            border: 1px solid var(--accent-green);
            border-radius: 4px;
            font-size: 12px;
            color: var(--stone-bright);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.error {
            border-color: var(--error);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-deep);
        }

        /* Generation Queue Panel */
        .generation-queue-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 1500;
            display: none;
        }

        .generation-queue-panel.visible {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="brand">
            <a href="/game-wizard/" class="home-btn" title="Back to Game Wizard">&#128302;</a>
            <span class="brand-icon">&#129513;</span>
            <span class="brand-text">GAME WIZARD / <span>TILESMITH</span></span>
        </div>
        <div class="header-actions">
            <select class="header-select" id="projectSelect">
                <option value="">-- Select Project --</option>
            </select>
            <span class="save-indicator" id="saveIndicator"></span>
            <div class="auth-indicator" id="authIndicator">
                <span class="auth-dot"></span>
                <span class="auth-text">Guest</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Left Panel - Canvas -->
        <div class="left-panel">
            <!-- Toolbar (Zoom & Grid) -->
            <div class="toolbar">
                <div class="toolbar-group">
                    <span class="toolbar-label">Zoom</span>
                    <div class="zoom-group">
                        <button class="zoom-btn" data-zoom="1">1x</button>
                        <button class="zoom-btn" data-zoom="2">2x</button>
                        <button class="zoom-btn" data-zoom="4">4x</button>
                        <button class="zoom-btn" data-zoom="8">8x</button>
                        <button class="zoom-btn active" data-zoom="16">16x</button>
                    </div>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <span class="toolbar-label">Grid</span>
                    <input type="number" class="tileset-input" id="gridCols" value="1" min="1" max="8" title="Columns">
                    <span class="tileset-x">&times;</span>
                    <input type="number" class="tileset-input" id="gridRows" value="1" min="1" max="8" title="Rows">
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <span class="toolbar-label">Tile</span>
                    <div class="tile-selector" id="tileSelector">
                        <!-- Dynamically populated -->
                    </div>
                </div>

                <div class="toolbar-divider"></div>

                <div class="toolbar-group">
                    <label class="grid-toggle">
                        <input type="checkbox" id="gridToggle" checked>
                        Show Grid
                    </label>
                    <label class="grid-toggle">
                        <input type="checkbox" id="tileBordersToggle" checked>
                        Tile Borders
                    </label>
                </div>
            </div>

            <div class="canvas-area">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="mainCanvas"></canvas>
                    <canvas id="gridCanvas"></canvas>
                </div>
                <div class="canvas-controls">
                    <div class="toolbar-group">
                        <button class="tool-btn" id="undoBtn" title="Undo (Ctrl+Z)" disabled>&#8630;</button>
                        <button class="tool-btn" id="redoBtn" title="Redo (Ctrl+Shift+Z)" disabled>&#8631;</button>
                    </div>
                    <div class="toolbar-group">
                        <button class="tool-btn active" data-tool="pencil" title="Pencil (P)">&#9998;</button>
                        <button class="tool-btn" data-tool="eraser" title="Eraser (E)">&#9003;</button>
                        <button class="tool-btn" data-tool="fill" title="Fill (F)">&#9699;</button>
                        <button class="tool-btn" data-tool="picker" title="Color Picker (I) - Hold Option/Alt to preview">&#128371;</button>
                        <button class="tool-btn" data-tool="line" title="Line (L)">&#9585;</button>
                        <button class="tool-btn" data-tool="rect" title="Rectangle (R)">&#9634;</button>
                    </div>
                    <div class="toolbar-group">
                        <button class="tool-btn" data-tool="clear" title="Clear Current Tile">&#128465;</button>
                        <button class="tool-btn palette-toggle-btn" id="paletteToggleBtn" title="Toggle Palette (C)">
                            &#127912;
                            <span class="color-dot" id="colorDot" style="background: #40d080;"></span>
                        </button>
                    </div>
                </div>
                <div class="quick-palette-bar" id="quickPaletteBar">
                    <input type="color" class="quick-palette-current" id="quickColorPicker" value="#40d080" title="Pick Color">
                    <div class="quick-palette-grid" id="quickPaletteGrid">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Tile Library -->
            <div class="tile-library">
                <div class="library-header">
                    <span class="section-header">Tile Library</span>
                    <button class="btn btn-small" id="newTileBtn">+ New</button>
                </div>
                <div class="sheet-switcher">
                    <button class="sheet-tab active" id="draftTab" data-sheet="draft">Draft <span class="tab-count" id="draftCount">(0)</span></button>
                    <button class="sheet-tab" id="masterTab" data-sheet="master">Master <span class="tab-count" id="masterCount">(0)</span></button>
                </div>
                <div class="library-actions" id="libraryActions">
                    <button class="btn btn-small" id="publishTileBtn" title="Publish selected tile to Master Sheet">Publish</button>
                    <button class="btn btn-small" id="publishAllBtn" title="Publish all drafts to Master Sheet">Publish All</button>
                </div>

                <!-- Groups Section (only shown on Master view) -->
                <div class="groups-section" id="groupsSection">
                    <div class="groups-header">
                        <span class="section-subheader">Groups</span>
                        <button class="btn btn-tiny" id="newGroupBtn" title="Create new tile group">+ Group</button>
                    </div>
                    <div class="groups-grid" id="groupsGrid">
                        <!-- Groups populated by JS -->
                    </div>
                </div>

                <!-- Tiles Section -->
                <div class="tiles-section">
                    <div class="tiles-header">
                        <span class="section-subheader">Tiles</span>
                    </div>
                    <div class="library-grid" id="libraryGrid">
                        <!-- Tiles populated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">

            <!-- Palette -->
            <div class="panel-section">
                <div class="section-header">Palette</div>
                <div class="current-color">
                    <input type="color" id="colorPicker" class="current-color-swatch" value="#40d080">
                    <div class="current-color-info">
                        <div class="current-color-hex" id="currentHex">#40D080</div>
                        <div class="current-color-family" id="currentColorFamily">Green › Emerald</div>
                        <div class="current-color-name" id="currentColorName">Seafoam</div>
                        <div class="current-color-desc" id="currentColorDesc">Vivid, medium</div>
                    </div>
                </div>
                <div class="palette-presets">
                    <select id="palettePreset">
                        <option value="custom">Custom Palette</option>
                        <option value="gameboy">Game Boy (4)</option>
                        <option value="nes">NES (16)</option>
                        <option value="pico8">PICO-8 (16)</option>
                        <option value="lospec16">Lospec 16</option>
                        <option value="endesga32">ENDESGA 32</option>
                    </select>
                </div>
                <div class="palette-grid" id="paletteGrid">
                    <!-- Colors populated by JS -->
                </div>
                <div class="palette-actions">
                    <button class="btn btn-small" id="addColorBtn">+ Add</button>
                    <button class="btn btn-small" id="removeColorBtn">- Remove</button>
                </div>
            </div>

            <!-- Tile Settings -->
            <div class="panel-section">
                <div class="section-header">Tile Settings</div>
                <div class="form-group">
                    <label class="form-label">Name</label>
                    <input type="text" class="form-input" id="tileName" placeholder="grass_tile_01">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Width</label>
                        <input type="number" class="form-input" id="tileWidth" value="16" min="8" max="64">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Height</label>
                        <input type="number" class="form-input" id="tileHeight" value="16" min="8" max="64">
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Type</label>
                    <select class="form-input" id="tileType">
                        <option value="">-- Select --</option>
                        <option value="terrain">Terrain</option>
                        <option value="structure">Structure</option>
                        <option value="vegetation">Vegetation</option>
                        <option value="water">Water</option>
                        <option value="path">Path</option>
                        <option value="decoration">Decoration</option>
                    </select>
                </div>
            </div>

            <!-- AI Assistant -->
            <div class="panel-section ai-section">
                <div class="section-header">AI Generator</div>
                <button class="btn btn-primary ai-generate-btn" id="aiGenerateBtn">
                    &#10024; Generate Tile
                </button>
                <div class="ai-spec-preview empty" id="aiSpecPreview">
                    <div>
                        <div style="font-size: 24px; margin-bottom: 8px;">&#129302;</div>
                        Click "Generate Tile" to create AI-generated pixel art
                    </div>
                </div>
            </div>

            <!-- Export -->
            <div class="panel-section">
                <div class="section-header">Export</div>
                <div class="export-actions">
                    <button class="btn" id="saveTileBtn">Save Tile</button>
                    <button class="btn" id="downloadPngBtn">Download PNG</button>
                    <button class="btn btn-primary" id="publishMasterBtn" title="Add to project's master spritesheet">
                        Publish to Master
                    </button>
                </div>
                <div class="master-sheet-status" id="masterSheetStatus" style="margin-top: 8px; font-size: 10px; color: var(--stone-mid);"></div>
            </div>
        </div>
    </main>

    <!-- AI Generation Modal -->
    <div class="modal-overlay" id="aiModal">
        <div class="modal" style="max-width: 480px;">
            <div class="modal-header">
                <span class="modal-title">AI Tile Generator</span>
                <button class="modal-close" id="aiModalClose">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Generation Type Selector -->
                <div class="form-group">
                    <label class="form-label">Generation Type</label>
                    <div style="display: flex; gap: 8px;">
                        <label style="flex: 1; display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: var(--stone-darker); border-radius: 4px; cursor: pointer; border: 2px solid var(--accent);" id="genTypeSingle">
                            <input type="radio" name="genType" value="single" checked style="accent-color: var(--accent);">
                            <span>Single Tile</span>
                        </label>
                        <label style="flex: 1; display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: var(--stone-darker); border-radius: 4px; cursor: pointer; border: 2px solid transparent;" id="genTypeTileset">
                            <input type="radio" name="genType" value="tileset" style="accent-color: var(--accent);">
                            <span>Wang Tileset</span>
                        </label>
                    </div>
                </div>

                <!-- Single Tile Form -->
                <div id="singleTileForm">
                    <div class="form-group">
                        <label class="form-label">Description *</label>
                        <textarea class="form-input" id="aiDescription" rows="2" placeholder="e.g., mossy stone brick, wooden treasure chest, glowing crystal"></textarea>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Perspective</label>
                            <select class="form-input" id="aiPerspective">
                                <option value="high top-down">High Top-Down</option>
                                <option value="low top-down" selected>Low Top-Down</option>
                                <option value="side">Side View</option>
                                <option value="isometric">Isometric</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Isometric Shape</label>
                            <select class="form-input" id="aiIsoShape" disabled>
                                <option value="thin">Thin</option>
                                <option value="thick">Thick</option>
                                <option value="block" selected>Block</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Tileset Form -->
                <div id="tilesetForm" style="display: none;">
                    <div class="form-group">
                        <label class="form-label">Tileset Type</label>
                        <select class="form-input" id="aiTilesetType">
                            <option value="topdown" selected>Top-Down Terrain</option>
                            <option value="sidescroller">Sidescroller Platform</option>
                        </select>
                    </div>
                    <div class="form-group" id="lowerDescGroup">
                        <label class="form-label" id="lowerDescLabel">Lower Material *</label>
                        <input type="text" class="form-input" id="aiLowerDesc" placeholder="e.g., grass, water, stone">
                    </div>
                    <div class="form-group" id="upperDescGroup">
                        <label class="form-label">Upper Material *</label>
                        <input type="text" class="form-input" id="aiUpperDesc" placeholder="e.g., dirt path, sand, snow">
                    </div>
                    <div class="form-group" id="transitionDescGroup" style="display: none;">
                        <label class="form-label">Surface Decoration</label>
                        <input type="text" class="form-input" id="aiTransitionDesc" placeholder="e.g., mossy, cracked, rusted (optional)">
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label">Transition Size</label>
                            <select class="form-input" id="aiTransitionSize">
                                <option value="0.1">Sharp</option>
                                <option value="0.25" selected>Medium</option>
                                <option value="0.5">Wide</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">View</label>
                            <select class="form-input" id="aiTilesetView">
                                <option value="high top-down">High Top-Down</option>
                                <option value="low top-down" selected>Low Top-Down</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Project Style (inherited from Crucible) -->
                <div id="projectStyleInfo" style="display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: var(--stone-darker); border-radius: 4px; border: 1px solid var(--stone-dark); margin-bottom: 8px;">
                    <span style="color: var(--stone-mid); font-size: 11px;">Project Style:</span>
                    <span id="projectStyleText" style="color: var(--stone-light); font-size: 11px; font-weight: 500;">Loading...</span>
                </div>
                <p style="font-size: 11px; color: var(--stone-mid); margin-top: 8px;">
                    Generation takes 2-5 minutes. Track progress in the queue panel.
                    <span id="tilesetNote" style="display: none;"><br>Tilesets generate 16 Wang tiles in a 4×4 grid.</span>
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn" id="aiModalCancel">Cancel</button>
                <button class="btn btn-primary" id="aiModalGenerate">Generate Tile</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Generation Queue Panel -->
    <div class="generation-queue-panel" id="generationQueuePanel"></div>

    <script src="../shared/supabase-client.js"></script>
    <script src="../shared/project-gate.js"></script>
    <script src="../shared/master-sheet.js"></script>
    <script src="../shared/pixellab-client.js"></script>
    <script src="../shared/generation-queue.js"></script>
    <script>
        /* ============================================
           TILESMITH - JavaScript
           ============================================ */

        // ==========================================
        // PALETTE PRESETS
        // ==========================================
        const PALETTES = {
            gameboy: ['#0f380f', '#306230', '#8bac0f', '#9bbc0f'],
            nes: [
                '#000000', '#fcfcfc', '#f8f8f8', '#bcbcbc',
                '#7c7c7c', '#a4e4fc', '#3cbcfc', '#0078f8',
                '#0000fc', '#b8b8f8', '#6888fc', '#0058f8',
                '#0000bc', '#d8b8f8', '#9878f8', '#6844fc'
            ],
            pico8: [
                '#000000', '#1d2b53', '#7e2553', '#008751',
                '#ab5236', '#5f574f', '#c2c3c7', '#fff1e8',
                '#ff004d', '#ffa300', '#ffec27', '#00e436',
                '#29adff', '#83769c', '#ff77a8', '#ffccaa'
            ],
            lospec16: [
                '#140c1c', '#442434', '#30346d', '#4e4a4e',
                '#854c30', '#346524', '#d04648', '#757161',
                '#597dce', '#d27d2c', '#8595a1', '#6daa2c',
                '#d2aa99', '#6dc2ca', '#dad45e', '#deeed6'
            ],
            endesga32: [
                '#be4a2f', '#d77643', '#ead4aa', '#e4a672',
                '#b86f50', '#733e39', '#3e2731', '#a22633',
                '#e43b44', '#f77622', '#feae34', '#fee761',
                '#63c74d', '#3e8948', '#265c42', '#193c3e',
                '#124e89', '#0099db', '#2ce8f5', '#ffffff',
                '#c0cbdc', '#8b9bb4', '#5a6988', '#3a4466',
                '#262b44', '#181425', '#ff0044', '#68386c',
                '#b55088', '#f6757a', '#e8b796', '#c28569'
            ]
        };

        // ==========================================
        // STATE
        // ==========================================
        const state = {
            user: null,
            projectId: null,
            tiles: [],
            currentTileId: null,
            currentTileName: null,      // Name of currently loaded tile
            currentTileSource: null,    // 'draft', 'master', or 'new'

            // Sheet data
            libraryView: 'draft',       // 'draft' or 'master'
            draftSheet: { png: null, atlas: { size: { w: 0, h: 0 }, sprites: {} } },
            masterSheet: { png: null, atlas: { size: { w: 0, h: 0 }, sprites: {} } },
            draftTiles: [],             // Array of tile objects from draft

            // Tile groups
            tileGroups: [],             // Array of tile groups from DB
            currentGroupId: null,       // Currently selected group (if any)
            masterTiles: [],            // Array of tile objects from master

            // Canvas - single tile dimensions
            width: 16,
            height: 16,
            zoom: 16,
            showGrid: true,
            showTileBorders: true,

            // Tileset grid (multiple tiles)
            gridCols: 1,
            gridRows: 1,
            selectedTileX: 0,
            selectedTileY: 0,

            // Drawing
            tool: 'pencil',
            previousTool: null,      // For temporary picker mode
            tempPickerActive: false, // Alt-held temporary picker
            currentColor: '#40d080',
            palette: [...PALETTES.pico8],
            pixels: null, // ImageData for entire tileset

            // Drawing state
            isDrawing: false,
            lastX: -1,
            lastY: -1,
            startX: -1,
            startY: -1,

            // Undo
            undoStack: [],
            redoStack: [],

            // AI spec
            currentSpec: null,

            // Save
            saveTimeout: null,
            isDirty: false,

            // Generation queue
            generationQueue: null
        };

        // ==========================================
        // DOM ELEMENTS
        // ==========================================
        const elements = {
            projectSelect: document.getElementById('projectSelect'),
            saveIndicator: document.getElementById('saveIndicator'),
            authIndicator: document.getElementById('authIndicator'),
            mainCanvas: document.getElementById('mainCanvas'),
            gridCanvas: document.getElementById('gridCanvas'),
            canvasWrapper: document.getElementById('canvasWrapper'),
            gridToggle: document.getElementById('gridToggle'),
            tileBordersToggle: document.getElementById('tileBordersToggle'),
            gridCols: document.getElementById('gridCols'),
            gridRows: document.getElementById('gridRows'),
            tileSelector: document.getElementById('tileSelector'),
            libraryGrid: document.getElementById('libraryGrid'),
            newTileBtn: document.getElementById('newTileBtn'),
            draftTab: document.getElementById('draftTab'),
            masterTab: document.getElementById('masterTab'),
            draftCount: document.getElementById('draftCount'),
            masterCount: document.getElementById('masterCount'),
            libraryActions: document.getElementById('libraryActions'),
            publishTileBtn: document.getElementById('publishTileBtn'),
            publishAllBtn: document.getElementById('publishAllBtn'),
            groupsSection: document.getElementById('groupsSection'),
            groupsGrid: document.getElementById('groupsGrid'),
            newGroupBtn: document.getElementById('newGroupBtn'),
            colorPicker: document.getElementById('colorPicker'),
            currentHex: document.getElementById('currentHex'),
            currentColorFamily: document.getElementById('currentColorFamily'),
            currentColorName: document.getElementById('currentColorName'),
            currentColorDesc: document.getElementById('currentColorDesc'),
            colorTooltip: document.getElementById('colorTooltip'),
            palettePreset: document.getElementById('palettePreset'),
            paletteGrid: document.getElementById('paletteGrid'),
            paletteToggleBtn: document.getElementById('paletteToggleBtn'),
            quickPaletteBar: document.getElementById('quickPaletteBar'),
            quickPaletteGrid: document.getElementById('quickPaletteGrid'),
            quickColorPicker: document.getElementById('quickColorPicker'),
            colorDot: document.getElementById('colorDot'),
            addColorBtn: document.getElementById('addColorBtn'),
            removeColorBtn: document.getElementById('removeColorBtn'),
            tileName: document.getElementById('tileName'),
            tileWidth: document.getElementById('tileWidth'),
            tileHeight: document.getElementById('tileHeight'),
            tileType: document.getElementById('tileType'),
            aiGenerateBtn: document.getElementById('aiGenerateBtn'),
            aiSpecPreview: document.getElementById('aiSpecPreview'),
            aiModal: document.getElementById('aiModal'),
            aiModalClose: document.getElementById('aiModalClose'),
            aiModalCancel: document.getElementById('aiModalCancel'),
            aiModalGenerate: document.getElementById('aiModalGenerate'),
            saveTileBtn: document.getElementById('saveTileBtn'),
            downloadPngBtn: document.getElementById('downloadPngBtn'),
            publishMasterBtn: document.getElementById('publishMasterBtn'),
            masterSheetStatus: document.getElementById('masterSheetStatus'),
            toast: document.getElementById('toast'),
            generationQueuePanel: document.getElementById('generationQueuePanel')
        };

        const ctx = elements.mainCanvas.getContext('2d');
        const gridCtx = elements.gridCanvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        gridCtx.imageSmoothingEnabled = false;

        // ==========================================
        // INITIALIZATION
        // ==========================================
        async function init() {
            // Check if user has projects (displays gate if not)
            const hasProject = await checkProjectGate();
            if (!hasProject) return;

            await crucibleClient.init();
            state.user = await crucibleClient.getUser();
            updateAuthIndicator();

            renderTileSelector();
            initializeCanvas();
            renderPalette();
            selectColor(state.currentColor); // Initialize color info display
            setupEventListeners();

            if (state.user) {
                await loadProjects();
            }

            // Initialize generation queue for cross-tool visibility
            initGenerationQueue();
        }

        function initGenerationQueue() {
            if (typeof GenerationQueue !== 'undefined' && elements.generationQueuePanel) {
                state.generationQueue = new GenerationQueue(elements.generationQueuePanel, {
                    onImport: async (job) => {
                        // Handle tile imports - download image and apply to canvas
                        if (job.jobType === 'isometric_tile' || job.jobType === 'map_object') {
                            await importGeneratedTile(job);
                        } else if (job.jobType === 'tileset_topdown' || job.jobType === 'tileset_sidescroller') {
                            await importGeneratedTileset(job);
                        } else {
                            showToast('Import this asset in Sprite-Rite');
                        }
                    },
                    onError: (error) => showToast(error, true)
                });
            }
        }

        async function importGeneratedTile(job) {
            if (!job.resultUrl) {
                showToast('No image URL available', true);
                return;
            }

            try {
                showToast('Importing tile...');

                // Download the image
                const response = await fetch(job.resultUrl);
                if (!response.ok) throw new Error('Failed to download image');

                const blob = await response.blob();
                const img = new Image();

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });

                // Get the image dimensions
                const imgWidth = img.width;
                const imgHeight = img.height;

                // Update tile size if needed
                if (imgWidth !== state.width || imgHeight !== state.height) {
                    state.width = imgWidth;
                    state.height = imgHeight;
                    elements.tileWidth.value = imgWidth;
                    elements.tileHeight.value = imgHeight;

                    // Recreate pixel data with new dimensions
                    const totalWidth = state.width * state.gridCols;
                    const totalHeight = state.height * state.gridRows;
                    state.pixels = ctx.createImageData(totalWidth, totalHeight);
                    updateCanvasSize();
                }

                // Draw image to temp canvas to get pixel data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = imgWidth;
                tempCanvas.height = imgHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, imgWidth, imgHeight);

                // Save undo state
                saveUndoState();

                // Calculate offset for selected tile
                const offsetX = state.selectedTileX * state.width;
                const offsetY = state.selectedTileY * state.height;

                // Apply pixels to the selected tile position
                for (let y = 0; y < imgHeight; y++) {
                    for (let x = 0; x < imgWidth; x++) {
                        const srcIdx = (y * imgWidth + x) * 4;
                        const r = imageData.data[srcIdx];
                        const g = imageData.data[srcIdx + 1];
                        const b = imageData.data[srcIdx + 2];
                        const a = imageData.data[srcIdx + 3];

                        const hex = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                        setPixel(offsetX + x, offsetY + y, hex, a);
                    }
                }

                // Clean up
                URL.revokeObjectURL(img.src);

                render();
                markDirty();
                showToast('Tile imported to canvas!');
            } catch (err) {
                console.error('Failed to import tile:', err);
                showToast('Failed to import tile: ' + err.message, true);
            }
        }

        async function importGeneratedTileset(job) {
            if (!job.resultUrl) {
                showToast('No tileset URL available', true);
                return;
            }

            try {
                showToast('Importing tileset...');

                // Download the tileset image
                const response = await fetch(job.resultUrl);
                if (!response.ok) throw new Error('Failed to download tileset');

                const blob = await response.blob();
                const img = new Image();

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = URL.createObjectURL(blob);
                });

                // Wang tilesets are 4x4 = 16 tiles
                const gridCols = 4;
                const gridRows = 4;
                const tileWidth = img.width / gridCols;
                const tileHeight = img.height / gridRows;

                // Update tile size and grid dimensions
                state.width = tileWidth;
                state.height = tileHeight;
                state.gridCols = gridCols;
                state.gridRows = gridRows;
                elements.tileWidth.value = tileWidth;
                elements.tileHeight.value = tileHeight;
                elements.gridCols.value = gridCols;
                elements.gridRows.value = gridRows;

                // Create new pixel data for the entire tileset
                const totalWidth = tileWidth * gridCols;
                const totalHeight = tileHeight * gridRows;
                state.pixels = ctx.createImageData(totalWidth, totalHeight);

                // Draw entire tileset image to temp canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, img.width, img.height);

                // Copy all pixels to state
                for (let y = 0; y < img.height; y++) {
                    for (let x = 0; x < img.width; x++) {
                        const srcIdx = (y * img.width + x) * 4;
                        const r = imageData.data[srcIdx];
                        const g = imageData.data[srcIdx + 1];
                        const b = imageData.data[srcIdx + 2];
                        const a = imageData.data[srcIdx + 3];

                        const dstIdx = (y * totalWidth + x) * 4;
                        state.pixels.data[dstIdx] = r;
                        state.pixels.data[dstIdx + 1] = g;
                        state.pixels.data[dstIdx + 2] = b;
                        state.pixels.data[dstIdx + 3] = a;
                    }
                }

                // Clean up
                URL.revokeObjectURL(img.src);

                // Reset selected tile to first position
                state.selectedTileX = 0;
                state.selectedTileY = 0;

                // Update UI
                renderTileSelector();
                updateCanvasSize();
                markDirty();
                showToast(`Tileset imported! ${gridCols}×${gridRows} grid with ${tileWidth}×${tileHeight}px tiles.`);
            } catch (err) {
                console.error('Failed to import tileset:', err);
                showToast('Failed to import tileset: ' + err.message, true);
            }
        }

        // ==========================================
        // TILE SELECTOR
        // ==========================================
        function renderTileSelector() {
            const selector = elements.tileSelector;
            selector.innerHTML = '';
            selector.style.gridTemplateColumns = `repeat(${state.gridCols}, 1fr)`;

            for (let y = 0; y < state.gridRows; y++) {
                for (let x = 0; x < state.gridCols; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'tile-selector-cell';
                    if (x === state.selectedTileX && y === state.selectedTileY) {
                        cell.classList.add('active');
                    }
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.textContent = y * state.gridCols + x + 1;
                    cell.addEventListener('click', () => selectTile(x, y));
                    selector.appendChild(cell);
                }
            }
        }

        function selectTile(x, y) {
            state.selectedTileX = x;
            state.selectedTileY = y;
            renderTileSelector();
            renderGrid(); // Re-render to highlight selected tile
        }

        function updateTilesetGrid() {
            const oldCols = state.gridCols;
            const oldRows = state.gridRows;
            const newCols = parseInt(elements.gridCols.value) || 1;
            const newRows = parseInt(elements.gridRows.value) || 1;

            if (newCols === oldCols && newRows === oldRows) return;

            // Save old pixel data
            const oldPixels = state.pixels ? new Uint8ClampedArray(state.pixels.data) : null;
            const oldTotalWidth = state.width * oldCols;
            const oldTotalHeight = state.height * oldRows;

            // Update grid dimensions
            state.gridCols = newCols;
            state.gridRows = newRows;

            // Ensure selected tile is within bounds
            if (state.selectedTileX >= newCols) state.selectedTileX = newCols - 1;
            if (state.selectedTileY >= newRows) state.selectedTileY = newRows - 1;

            // Create new pixel data for entire tileset
            const totalWidth = state.width * newCols;
            const totalHeight = state.height * newRows;
            state.pixels = ctx.createImageData(totalWidth, totalHeight);

            // Copy old data if exists
            if (oldPixels) {
                for (let y = 0; y < Math.min(oldTotalHeight, totalHeight); y++) {
                    for (let x = 0; x < Math.min(oldTotalWidth, totalWidth); x++) {
                        const oldIdx = (y * oldTotalWidth + x) * 4;
                        const newIdx = (y * totalWidth + x) * 4;
                        state.pixels.data[newIdx] = oldPixels[oldIdx];
                        state.pixels.data[newIdx + 1] = oldPixels[oldIdx + 1];
                        state.pixels.data[newIdx + 2] = oldPixels[oldIdx + 2];
                        state.pixels.data[newIdx + 3] = oldPixels[oldIdx + 3];
                    }
                }
            }

            renderTileSelector();
            updateCanvasSize();
            markDirty();
        }

        function updateAuthIndicator() {
            const indicator = elements.authIndicator;
            const textEl = indicator.querySelector('.auth-text');

            if (state.user) {
                indicator.classList.add('logged-in');
                const name = state.user.user_metadata?.display_name || state.user.email?.split('@')[0] || 'User';
                textEl.textContent = name;
            } else {
                indicator.classList.remove('logged-in');
                textEl.textContent = 'Guest';
            }
        }

        // ==========================================
        // CANVAS
        // ==========================================
        function getTotalWidth() {
            return state.width * state.gridCols;
        }

        function getTotalHeight() {
            return state.height * state.gridRows;
        }

        function initializeCanvas() {
            state.width = parseInt(elements.tileWidth.value) || 16;
            state.height = parseInt(elements.tileHeight.value) || 16;

            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();

            // Create pixel data for entire tileset
            state.pixels = ctx.createImageData(totalWidth, totalHeight);

            // Fill with transparent
            for (let i = 0; i < state.pixels.data.length; i += 4) {
                state.pixels.data[i] = 0;
                state.pixels.data[i + 1] = 0;
                state.pixels.data[i + 2] = 0;
                state.pixels.data[i + 3] = 0;
            }

            updateCanvasSize();
            render();
        }

        function updateCanvasSize() {
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();
            const displayWidth = totalWidth * state.zoom;
            const displayHeight = totalHeight * state.zoom;

            elements.mainCanvas.width = displayWidth;
            elements.mainCanvas.height = displayHeight;
            elements.gridCanvas.width = displayWidth;
            elements.gridCanvas.height = displayHeight;

            elements.canvasWrapper.style.width = displayWidth + 'px';
            elements.canvasWrapper.style.height = displayHeight + 'px';

            render();
        }

        function render() {
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();

            // Clear
            ctx.clearRect(0, 0, elements.mainCanvas.width, elements.mainCanvas.height);

            // Draw pixels scaled up
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = totalWidth;
            tempCanvas.height = totalHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(state.pixels, 0, 0);

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(tempCanvas, 0, 0, totalWidth * state.zoom, totalHeight * state.zoom);

            renderGrid();
        }

        function renderGrid() {
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();

            gridCtx.clearRect(0, 0, elements.gridCanvas.width, elements.gridCanvas.height);

            // Draw pixel grid
            if (state.showGrid) {
                gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                gridCtx.lineWidth = 1;

                // Vertical pixel lines
                for (let x = 0; x <= totalWidth; x++) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(x * state.zoom + 0.5, 0);
                    gridCtx.lineTo(x * state.zoom + 0.5, totalHeight * state.zoom);
                    gridCtx.stroke();
                }

                // Horizontal pixel lines
                for (let y = 0; y <= totalHeight; y++) {
                    gridCtx.beginPath();
                    gridCtx.moveTo(0, y * state.zoom + 0.5);
                    gridCtx.lineTo(totalWidth * state.zoom, y * state.zoom + 0.5);
                    gridCtx.stroke();
                }
            }

            // Draw tile boundaries (thicker lines)
            if (state.showTileBorders && (state.gridCols > 1 || state.gridRows > 1)) {
                gridCtx.strokeStyle = 'rgba(255, 165, 0, 0.6)'; // Orange for tile borders
                gridCtx.lineWidth = 2;

                // Vertical tile boundaries
                for (let col = 0; col <= state.gridCols; col++) {
                    const x = col * state.width * state.zoom;
                    gridCtx.beginPath();
                    gridCtx.moveTo(x, 0);
                    gridCtx.lineTo(x, totalHeight * state.zoom);
                    gridCtx.stroke();
                }

                // Horizontal tile boundaries
                for (let row = 0; row <= state.gridRows; row++) {
                    const y = row * state.height * state.zoom;
                    gridCtx.beginPath();
                    gridCtx.moveTo(0, y);
                    gridCtx.lineTo(totalWidth * state.zoom, y);
                    gridCtx.stroke();
                }
            }

            // Highlight selected tile
            if (state.gridCols > 1 || state.gridRows > 1) {
                const tileX = state.selectedTileX * state.width * state.zoom;
                const tileY = state.selectedTileY * state.height * state.zoom;
                const tileW = state.width * state.zoom;
                const tileH = state.height * state.zoom;

                gridCtx.strokeStyle = 'rgba(64, 208, 128, 0.9)'; // Green for selected
                gridCtx.lineWidth = 3;
                gridCtx.strokeRect(tileX + 1.5, tileY + 1.5, tileW - 3, tileH - 3);
            }
        }

        // ==========================================
        // DRAWING
        // ==========================================
        function getPixelPos(e) {
            const rect = elements.mainCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / state.zoom);
            const y = Math.floor((e.clientY - rect.top) / state.zoom);
            return { x, y };
        }

        function getPixelIndex(x, y) {
            const totalWidth = getTotalWidth();
            return (y * totalWidth + x) * 4;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        function setPixel(x, y, color, alpha = 255) {
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();
            if (x < 0 || x >= totalWidth || y < 0 || y >= totalHeight) return;

            const idx = getPixelIndex(x, y);
            const rgb = hexToRgb(color);

            state.pixels.data[idx] = rgb.r;
            state.pixels.data[idx + 1] = rgb.g;
            state.pixels.data[idx + 2] = rgb.b;
            state.pixels.data[idx + 3] = alpha;
        }

        function getPixel(x, y) {
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();
            if (x < 0 || x >= totalWidth || y < 0 || y >= totalHeight) return null;

            const idx = getPixelIndex(x, y);
            return {
                r: state.pixels.data[idx],
                g: state.pixels.data[idx + 1],
                b: state.pixels.data[idx + 2],
                a: state.pixels.data[idx + 3]
            };
        }

        function saveUndoState() {
            const data = new Uint8ClampedArray(state.pixels.data);
            state.undoStack.push(data);
            if (state.undoStack.length > 50) state.undoStack.shift();
            state.redoStack = [];
            updateUndoRedoButtons();
        }

        function undo() {
            if (state.undoStack.length === 0) return;

            const current = new Uint8ClampedArray(state.pixels.data);
            state.redoStack.push(current);

            const previous = state.undoStack.pop();
            state.pixels.data.set(previous);
            render();
            markDirty();
            updateUndoRedoButtons();
        }

        function redo() {
            if (state.redoStack.length === 0) return;

            const current = new Uint8ClampedArray(state.pixels.data);
            state.undoStack.push(current);

            const next = state.redoStack.pop();
            state.pixels.data.set(next);
            render();
            markDirty();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = state.undoStack.length === 0;
            if (redoBtn) redoBtn.disabled = state.redoStack.length === 0;
        }

        function drawLine(x0, y0, x1, y1, color) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx - dy;

            while (true) {
                setPixel(x0, y0, color);

                if (x0 === x1 && y0 === y1) break;

                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        function floodFill(startX, startY, fillColor) {
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();

            const targetPixel = getPixel(startX, startY);
            if (!targetPixel) return;

            const targetColor = rgbToHex(targetPixel.r, targetPixel.g, targetPixel.b);
            const targetAlpha = targetPixel.a;

            if (targetColor.toLowerCase() === fillColor.toLowerCase() && targetAlpha === 255) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= totalWidth || y < 0 || y >= totalHeight) continue;

                const pixel = getPixel(x, y);
                const pixelColor = rgbToHex(pixel.r, pixel.g, pixel.b);

                if (pixelColor.toLowerCase() !== targetColor.toLowerCase() || pixel.a !== targetAlpha) continue;

                visited.add(key);
                setPixel(x, y, fillColor);

                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
        }

        function clearCanvas() {
            // Clear only the selected tile
            saveUndoState();

            const startX = state.selectedTileX * state.width;
            const startY = state.selectedTileY * state.height;

            for (let y = startY; y < startY + state.height; y++) {
                for (let x = startX; x < startX + state.width; x++) {
                    setPixel(x, y, '#000000', 0);
                }
            }

            render();
            markDirty();
        }

        function clearAllTiles() {
            saveUndoState();
            for (let i = 0; i < state.pixels.data.length; i += 4) {
                state.pixels.data[i] = 0;
                state.pixels.data[i + 1] = 0;
                state.pixels.data[i + 2] = 0;
                state.pixels.data[i + 3] = 0;
            }
            render();
            markDirty();
        }

        // ==========================================
        // PALETTE
        // ==========================================
        function renderPalette() {
            elements.paletteGrid.innerHTML = '';

            state.palette.forEach((color, idx) => {
                const swatch = document.createElement('div');
                swatch.className = 'palette-swatch';
                if (color.toLowerCase() === state.currentColor.toLowerCase()) {
                    swatch.classList.add('active');
                }
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => selectColor(color));
                swatch.addEventListener('mouseenter', (e) => showColorTooltip(color, e.clientX, e.clientY));
                swatch.addEventListener('mousemove', (e) => showColorTooltip(color, e.clientX, e.clientY));
                swatch.addEventListener('mouseleave', hideColorTooltip);
                elements.paletteGrid.appendChild(swatch);
            });

            renderQuickPalette();
        }

        function renderQuickPalette() {
            elements.quickPaletteGrid.innerHTML = '';

            state.palette.forEach((color) => {
                const swatch = document.createElement('div');
                swatch.className = 'quick-palette-swatch';
                if (color.toLowerCase() === state.currentColor.toLowerCase()) {
                    swatch.classList.add('active');
                }
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => selectColor(color));
                swatch.addEventListener('mouseenter', (e) => showColorTooltip(color, e.clientX, e.clientY));
                swatch.addEventListener('mousemove', (e) => showColorTooltip(color, e.clientX, e.clientY));
                swatch.addEventListener('mouseleave', hideColorTooltip);
                elements.quickPaletteGrid.appendChild(swatch);
            });
        }

        // Color accessibility - comprehensive color info from hex
        // Returns: { hex, color (family), hue (specific), commonName (lightness-aware), descriptor }
        function getColorInfo(hex) {
            // Normalize hex
            hex = hex.toUpperCase();
            if (hex.length === 4) {
                hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
            }

            // Convert hex to RGB
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;

            // Convert RGB to HSL
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic (gray)
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            const hueDeg = h * 360;
            const sat = s * 100;
            const light = l * 100;

            // Determine if achromatic
            const isGray = sat < 12;

            // Color family (broad category)
            let color;
            if (isGray) {
                color = 'Gray';
            } else if (hueDeg < 15 || hueDeg >= 345) {
                color = 'Red';
            } else if (hueDeg < 45) {
                color = 'Orange';
            } else if (hueDeg < 75) {
                color = 'Yellow';
            } else if (hueDeg < 165) {
                color = 'Green';
            } else if (hueDeg < 195) {
                color = 'Cyan';
            } else if (hueDeg < 265) {
                color = 'Blue';
            } else if (hueDeg < 290) {
                color = 'Purple';
            } else {
                color = 'Pink';
            }

            // Specific hue name (more granular)
            let hue;
            if (isGray) {
                if (light < 10) hue = 'Black';
                else if (light < 25) hue = 'Charcoal';
                else if (light < 40) hue = 'Dark Gray';
                else if (light < 60) hue = 'Gray';
                else if (light < 75) hue = 'Silver';
                else if (light < 90) hue = 'Light Gray';
                else hue = 'White';
            } else if (hueDeg < 10 || hueDeg >= 350) {
                hue = 'Red';
            } else if (hueDeg < 20) {
                hue = 'Scarlet';
            } else if (hueDeg < 35) {
                hue = 'Vermilion';
            } else if (hueDeg < 45) {
                hue = 'Orange';
            } else if (hueDeg < 55) {
                hue = 'Amber';
            } else if (hueDeg < 65) {
                hue = 'Gold';
            } else if (hueDeg < 75) {
                hue = 'Yellow';
            } else if (hueDeg < 85) {
                hue = 'Lime';
            } else if (hueDeg < 100) {
                hue = 'Chartreuse';
            } else if (hueDeg < 140) {
                hue = 'Green';
            } else if (hueDeg < 165) {
                hue = 'Emerald';
            } else if (hueDeg < 180) {
                hue = 'Teal';
            } else if (hueDeg < 195) {
                hue = 'Cyan';
            } else if (hueDeg < 210) {
                hue = 'Sky';
            } else if (hueDeg < 230) {
                hue = 'Azure';
            } else if (hueDeg < 250) {
                hue = 'Blue';
            } else if (hueDeg < 265) {
                hue = 'Indigo';
            } else if (hueDeg < 280) {
                hue = 'Violet';
            } else if (hueDeg < 295) {
                hue = 'Purple';
            } else if (hueDeg < 320) {
                hue = 'Magenta';
            } else if (hueDeg < 335) {
                hue = 'Pink';
            } else if (hueDeg < 350) {
                hue = 'Rose';
            } else {
                hue = 'Red';
            }

            // Common name (lightness and saturation aware - familiar names)
            let commonName;
            if (isGray) {
                commonName = hue; // Use hue name for grays
            } else {
                // Special common names based on hue + lightness + saturation
                const isDark = light < 35;
                const isLight = light > 70;
                const isPale = isLight && sat < 50;
                const isMuted = sat < 35;

                if (color === 'Red') {
                    if (isDark) commonName = 'Maroon';
                    else if (isPale) commonName = 'Blush';
                    else if (isLight) commonName = 'Salmon';
                    else if (isMuted) commonName = 'Brick';
                    else commonName = hue;
                } else if (color === 'Orange') {
                    if (isDark) commonName = 'Brown';
                    else if (isPale) commonName = 'Peach';
                    else if (isLight) commonName = 'Apricot';
                    else if (isMuted) commonName = 'Rust';
                    else commonName = hue;
                } else if (color === 'Yellow') {
                    if (isDark) commonName = 'Olive';
                    else if (isPale) commonName = 'Cream';
                    else if (isLight) commonName = 'Lemon';
                    else if (isMuted) commonName = 'Khaki';
                    else commonName = hue;
                } else if (color === 'Green') {
                    if (isDark) commonName = 'Forest';
                    else if (isPale) commonName = 'Mint';
                    else if (isLight) commonName = 'Seafoam';
                    else if (isMuted) commonName = 'Sage';
                    else commonName = hue;
                } else if (color === 'Cyan') {
                    if (isDark) commonName = 'Petrol';
                    else if (isPale) commonName = 'Aqua';
                    else if (isLight) commonName = 'Ice';
                    else if (isMuted) commonName = 'Slate';
                    else commonName = hue;
                } else if (color === 'Blue') {
                    if (isDark) commonName = 'Navy';
                    else if (isPale) commonName = 'Powder';
                    else if (isLight) commonName = 'Sky';
                    else if (isMuted) commonName = 'Steel';
                    else commonName = hue;
                } else if (color === 'Purple') {
                    if (isDark) commonName = 'Plum';
                    else if (isPale) commonName = 'Lavender';
                    else if (isLight) commonName = 'Lilac';
                    else if (isMuted) commonName = 'Mauve';
                    else commonName = hue;
                } else if (color === 'Pink') {
                    if (isDark) commonName = 'Wine';
                    else if (isPale) commonName = 'Blush';
                    else if (isLight) commonName = 'Rose';
                    else if (isMuted) commonName = 'Dusty Rose';
                    else commonName = hue;
                } else {
                    commonName = hue;
                }
            }

            // Descriptor (saturation + lightness description)
            let lightDesc, satDesc;

            if (light < 20) lightDesc = 'very dark';
            else if (light < 35) lightDesc = 'dark';
            else if (light < 50) lightDesc = 'medium-dark';
            else if (light < 65) lightDesc = 'medium';
            else if (light < 80) lightDesc = 'light';
            else lightDesc = 'very light';

            if (sat < 15) satDesc = 'neutral';
            else if (sat < 30) satDesc = 'muted';
            else if (sat < 50) satDesc = 'soft';
            else if (sat < 70) satDesc = 'moderate';
            else if (sat < 85) satDesc = 'vivid';
            else satDesc = 'intense';

            // Build descriptor string
            let descriptor;
            if (isGray) {
                descriptor = `Neutral, ${lightDesc}`;
            } else {
                descriptor = `${satDesc.charAt(0).toUpperCase() + satDesc.slice(1)}, ${lightDesc}`;
            }

            return { hex, color, hue, commonName, descriptor };
        }

        // Format color info for tooltip display
        function formatColorTooltip(hex) {
            const info = getColorInfo(hex);
            return `${info.hex}\n${info.color} › ${info.hue}\n${info.commonName}\n${info.descriptor}`;
        }

        // Show color tooltip at position
        function showColorTooltip(hex, x, y) {
            const info = getColorInfo(hex);
            const tooltip = elements.colorTooltip;

            document.getElementById('tooltipSwatch').style.backgroundColor = hex;
            document.getElementById('tooltipHex').textContent = info.hex;
            document.getElementById('tooltipFamily').textContent = `${info.color} › ${info.hue}`;
            document.getElementById('tooltipName').textContent = info.commonName;
            document.getElementById('tooltipDesc').textContent = info.descriptor;

            // Position tooltip - offset from cursor, keep on screen
            const offsetX = 15;
            const offsetY = 15;
            let left = x + offsetX;
            let top = y + offsetY;

            // Prevent going off right edge
            if (left + 150 > window.innerWidth) {
                left = x - 150 - offsetX;
            }
            // Prevent going off bottom
            if (top + 100 > window.innerHeight) {
                top = y - 100 - offsetY;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.classList.add('visible');
        }

        // Hide color tooltip
        function hideColorTooltip() {
            elements.colorTooltip.classList.remove('visible');
        }

        function selectColor(color) {
            state.currentColor = color;
            elements.colorPicker.value = color;
            elements.quickColorPicker.value = color;
            elements.currentHex.textContent = color.toUpperCase();
            elements.colorDot.style.backgroundColor = color;

            // Update color info for accessibility
            const colorInfo = getColorInfo(color);
            elements.currentColorFamily.textContent = `${colorInfo.color} › ${colorInfo.hue}`;
            elements.currentColorName.textContent = colorInfo.commonName;
            elements.currentColorDesc.textContent = colorInfo.descriptor;

            renderPalette();
        }

        function addColorToPalette(color) {
            if (!state.palette.includes(color.toLowerCase())) {
                state.palette.push(color);
                renderPalette();
            }
        }

        function removeColorFromPalette() {
            const idx = state.palette.findIndex(c => c.toLowerCase() === state.currentColor.toLowerCase());
            if (idx !== -1 && state.palette.length > 1) {
                state.palette.splice(idx, 1);
                selectColor(state.palette[0]);
            }
        }

        function loadPalettePreset(presetName) {
            if (presetName === 'custom') return;

            if (PALETTES[presetName]) {
                state.palette = [...PALETTES[presetName]];
                selectColor(state.palette[0]);
            }
        }

        // ==========================================
        // PROJECTS & TILES
        // ==========================================
        async function loadProjects() {
            try {
                const projects = await crucibleClient.getProjects();

                elements.projectSelect.innerHTML = '<option value="">-- Select Project --</option>';
                projects.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = p.name;
                    elements.projectSelect.appendChild(opt);
                });

                const lastProject = localStorage.getItem('tilesmith_project');
                if (lastProject && projects.find(p => p.id === lastProject)) {
                    elements.projectSelect.value = lastProject;
                    await selectProject(lastProject);
                }
            } catch (err) {
                console.error('Failed to load projects:', err);
                showToast('Failed to load projects', true);
            }
        }

        // Migrate legacy tiles from tiles table to master sheet
        async function migrateLegacyTiles(projectId) {
            try {
                // Check if getTiles exists (for legacy support)
                if (!crucibleClient.getTiles) return;

                // Get legacy tiles from tiles table
                const legacyTiles = await crucibleClient.getTiles(projectId);
                if (!legacyTiles || legacyTiles.length === 0) return;

                // Check if master tile sheet already has sprites (already migrated)
                let masterTileSheet = { atlas: { sprites: {} } };
                try {
                    if (crucibleClient.getMasterTileSheet) {
                        masterTileSheet = await crucibleClient.getMasterTileSheet(projectId);
                    }
                } catch (e) {
                    // Master tile sheet columns may not exist yet
                }

                if (masterTileSheet.atlas?.sprites && Object.keys(masterTileSheet.atlas.sprites).length > 0) {
                    // Already migrated - skip
                    return;
                }

                // Migrate each tile to master tile sheet
                console.log(`Migrating ${legacyTiles.length} legacy tiles to master tile sheet...`);
                showToast(`Migrating ${legacyTiles.length} tiles to new system...`);

                for (const tile of legacyTiles) {
                    if (tile.pixel_data) {
                        try {
                            if (crucibleClient.publishToMasterTileSheet) {
                                await crucibleClient.publishToMasterTileSheet(
                                    projectId,
                                    tile.name,
                                    tile.pixel_data,
                                    tile.width,
                                    tile.height
                                );
                            }
                        } catch (err) {
                            console.warn(`Failed to migrate tile "${tile.name}":`, err);
                        }
                    }
                }

                showToast(`Migrated ${legacyTiles.length} tiles to Master Tile Sheet`);
                console.log('Legacy tile migration complete');
            } catch (err) {
                console.warn('Legacy tile migration check failed:', err);
                // Non-fatal - continue loading
            }
        }

        async function selectProject(projectId) {
            state.projectId = projectId;
            state.tiles = [];
            state.currentTileId = null;
            state.currentTileName = null;
            state.currentTileSource = null;
            state.draftTiles = [];
            state.masterTiles = [];
            state.draftSheet = { png: null, atlas: { size: { w: 0, h: 0 }, sprites: {} } };
            state.masterSheet = { png: null, atlas: { size: { w: 0, h: 0 }, sprites: {} } };

            localStorage.setItem('tilesmith_project', projectId);

            if (!projectId) {
                updateSheetCounts();
                renderTileLibrary();
                return;
            }

            try {
                // Initialize defaults
                let draftResult = { png: null, atlas: { size: { w: 0, h: 0 }, sprites: {} } };
                let masterResult = { png: null, atlas: { size: { w: 0, h: 0 }, sprites: {} } };
                let groups = [];

                // Try to load draft tile sheet (may fail if migration not run)
                try {
                    if (crucibleClient.getDraftTileSheet) {
                        draftResult = await crucibleClient.getDraftTileSheet(projectId);
                    } else if (crucibleClient.getDraftSheet) {
                        // Fallback to old method name
                        draftResult = await crucibleClient.getDraftSheet(projectId);
                    }
                } catch (draftErr) {
                    console.warn('Could not load draft tile sheet (columns may not exist):', draftErr.message);
                }

                // Load master tile sheet
                try {
                    if (crucibleClient.getMasterTileSheet) {
                        masterResult = await crucibleClient.getMasterTileSheet(projectId);
                    } else if (crucibleClient.getMasterSheet) {
                        // Fallback to old unified master sheet
                        masterResult = await crucibleClient.getMasterSheet(projectId);
                    }
                } catch (masterErr) {
                    console.warn('Could not load master tile sheet:', masterErr.message);
                }

                // Check for legacy tiles that need migration (only if master tile sheet is empty)
                if (!masterResult.atlas?.sprites || Object.keys(masterResult.atlas.sprites).length === 0) {
                    await migrateLegacyTiles(projectId);
                    // Reload master tile sheet after migration
                    try {
                        if (crucibleClient.getMasterTileSheet) {
                            masterResult = await crucibleClient.getMasterTileSheet(projectId);
                        }
                    } catch (e) {
                        console.warn('Could not reload master tile sheet after migration');
                    }
                }

                // Try to load groups (may fail if table doesn't exist yet)
                try {
                    if (crucibleClient.getTileGroups) {
                        groups = await crucibleClient.getTileGroups(projectId);
                    }
                } catch (groupErr) {
                    console.warn('Could not load tile groups (table may not exist):', groupErr.message);
                }

                // Store sheet data
                state.draftSheet = {
                    png: draftResult?.png || null,
                    atlas: draftResult?.atlas || { size: { w: 0, h: 0 }, sprites: {} }
                };
                state.masterSheet = {
                    png: masterResult?.png || null,
                    atlas: masterResult?.atlas || { size: { w: 0, h: 0 }, sprites: {} }
                };
                state.tileGroups = groups || [];

                // Convert atlas sprites to tile arrays for display
                state.draftTiles = atlasToTileArray(state.draftSheet.atlas, state.draftSheet.png);
                state.masterTiles = atlasToTileArray(state.masterSheet.atlas, state.masterSheet.png);

                updateSheetCounts();
                renderTileLibrary();
                renderTileGroups();
            } catch (err) {
                console.error('Failed to load sheets:', err);
                showToast('Failed to load tiles', true);
            }
        }

        // Convert atlas sprites object to array for rendering
        function atlasToTileArray(atlas, sheetPng) {
            if (!atlas?.sprites) return [];

            return Object.entries(atlas.sprites).map(([name, sprite]) => ({
                name,
                width: sprite.w,
                height: sprite.h,
                x: sprite.x,
                y: sprite.y,
                sheetPng,
                metadata: sprite.metadata || {}
            }));
        }

        function updateSheetCounts() {
            elements.draftCount.textContent = `(${state.draftTiles.length})`;
            elements.masterCount.textContent = `(${state.masterTiles.length})`;

            // Show/hide publish buttons based on view and content
            const showPublish = state.libraryView === 'draft' && state.draftTiles.length > 0;
            elements.libraryActions.style.display = showPublish ? 'flex' : 'none';

            // Show groups section only on master view
            const showGroups = state.libraryView === 'master';
            elements.groupsSection.classList.toggle('visible', showGroups);
        }

        function switchSheetView(view) {
            state.libraryView = view;

            // Update tab styles
            elements.draftTab.classList.toggle('active', view === 'draft');
            elements.masterTab.classList.toggle('active', view === 'master');

            updateSheetCounts();
            renderTileLibrary();
            renderTileGroups();
        }

        // Render tile groups (assembled previews)
        function renderTileGroups() {
            elements.groupsGrid.innerHTML = '';

            // Only show groups on master view
            if (state.libraryView !== 'master') return;

            if (state.tileGroups.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'groups-empty';
                emptyMsg.textContent = 'No groups yet. Create one to combine tiles.';
                elements.groupsGrid.appendChild(emptyMsg);
                return;
            }

            // Need the master sheet image to render group previews
            if (!state.masterSheet.png) return;

            const sheetImg = new Image();
            sheetImg.src = state.masterSheet.png;
            sheetImg.onload = () => {
                state.tileGroups.forEach(group => {
                    const groupEl = document.createElement('div');
                    groupEl.className = 'group-tile';
                    if (group.id === state.currentGroupId) {
                        groupEl.classList.add('active');
                    }

                    // Create assembled preview canvas
                    const canvas = document.createElement('canvas');
                    const tileSize = 16; // Base tile size (will be scaled)
                    canvas.width = group.cols * tileSize;
                    canvas.height = group.rows * tileSize;
                    const gCtx = canvas.getContext('2d');
                    gCtx.imageSmoothingEnabled = false;

                    // Render each tile in the arrangement
                    const arrangement = group.arrangement || [];
                    for (let row = 0; row < group.rows; row++) {
                        for (let col = 0; col < group.cols; col++) {
                            const tileName = arrangement[row]?.[col];
                            if (tileName) {
                                const tile = state.masterTiles.find(t => t.name === tileName);
                                if (tile) {
                                    gCtx.drawImage(
                                        sheetImg,
                                        tile.x, tile.y, tile.width, tile.height,
                                        col * tileSize, row * tileSize, tileSize, tileSize
                                    );
                                }
                            }
                        }
                    }

                    groupEl.appendChild(canvas);

                    // Group name label
                    const nameEl = document.createElement('div');
                    nameEl.className = 'group-tile-name';
                    nameEl.textContent = group.name;
                    groupEl.appendChild(nameEl);

                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'group-tile-delete';
                    deleteBtn.textContent = '×';
                    deleteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await handleGroupDelete(group);
                    });
                    groupEl.appendChild(deleteBtn);

                    groupEl.title = `${group.name} (${group.cols}×${group.rows})\nRight-click for options`;
                    groupEl.addEventListener('click', () => loadGroup(group));
                    groupEl.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        showGroupContextMenu(group, e.clientX, e.clientY);
                    });

                    elements.groupsGrid.appendChild(groupEl);
                });
            };
        }

        // Handle group deletion
        async function handleGroupDelete(group) {
            if (!confirm(`Delete group "${group.name}"?\n\nTiles will not be deleted, only the group arrangement.`)) {
                return;
            }

            try {
                await crucibleClient.deleteTileGroup(group.id);
                state.tileGroups = state.tileGroups.filter(g => g.id !== group.id);

                if (state.currentGroupId === group.id) {
                    state.currentGroupId = null;
                    newTile();
                }

                renderTileGroups();
                showToast(`Deleted group "${group.name}"`);
            } catch (err) {
                console.error('Failed to delete group:', err);
                showToast('Failed to delete group', true);
            }
        }

        // Show context menu for a group
        function showGroupContextMenu(group, x, y) {
            hideContextMenu();

            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.id = 'groupContextMenu';

            // Edit option
            const editItem = document.createElement('div');
            editItem.className = 'context-menu-item';
            editItem.innerHTML = '✏️ Edit Group';
            editItem.addEventListener('click', () => {
                hideContextMenu();
                loadGroup(group);
            });
            menu.appendChild(editItem);

            // Create variation option
            const variationItem = document.createElement('div');
            variationItem.className = 'context-menu-item';
            variationItem.innerHTML = '📋 Create Variation';
            variationItem.addEventListener('click', () => {
                hideContextMenu();
                createGroupVariation(group);
            });
            menu.appendChild(variationItem);

            // Separator
            const sep = document.createElement('div');
            sep.className = 'context-menu-separator';
            menu.appendChild(sep);

            // Delete option
            const deleteItem = document.createElement('div');
            deleteItem.className = 'context-menu-item danger';
            deleteItem.innerHTML = '🗑️ Delete Group';
            deleteItem.addEventListener('click', () => {
                hideContextMenu();
                handleGroupDelete(group);
            });
            menu.appendChild(deleteItem);

            // Position menu
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;

            document.body.appendChild(menu);

            // Adjust position if off-screen
            const rect = menu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                menu.style.left = `${x - rect.width}px`;
            }
            if (rect.bottom > window.innerHeight) {
                menu.style.top = `${y - rect.height}px`;
            }

            // Close menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
                document.addEventListener('contextmenu', hideContextMenu, { once: true });
            }, 0);
        }

        function hideContextMenu() {
            const existingMenu = document.getElementById('groupContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
        }

        // Create a variation of an existing group
        async function createGroupVariation(sourceGroup) {
            const newName = prompt(
                `Create variation of "${sourceGroup.name}".\n\nEnter a name for the new group:`,
                `${sourceGroup.name}_v2`
            );
            if (!newName || newName.trim() === '') return;

            try {
                // Use the API method to duplicate the group
                const newGroup = await crucibleClient.duplicateTileGroup(sourceGroup.id, newName.trim());

                // Refresh groups
                state.tileGroups = await crucibleClient.getTileGroups(state.projectId);
                renderTileGroups();

                // Load the new group
                await loadGroup(newGroup);

                showToast(`Created variation "${newName.trim()}"`);
            } catch (err) {
                console.error('Failed to create variation:', err);
                showToast('Failed to create variation', true);
            }
        }

        // Load a group into the canvas for editing
        async function loadGroup(group) {
            state.currentGroupId = group.id;
            state.currentTileName = null;
            state.currentTileSource = 'group';

            // Set canvas to group dimensions
            state.gridCols = group.cols;
            state.gridRows = group.rows;
            state.selectedTileX = 0;
            state.selectedTileY = 0;

            elements.tileName.value = group.name;
            elements.gridCols.value = group.cols;
            elements.gridRows.value = group.rows;

            // Determine tile size from first tile in arrangement
            const arrangement = group.arrangement || [];
            let tileWidth = 16, tileHeight = 16;
            for (const row of arrangement) {
                for (const tileName of row) {
                    if (tileName) {
                        const tile = state.masterTiles.find(t => t.name === tileName);
                        if (tile) {
                            tileWidth = tile.width;
                            tileHeight = tile.height;
                            break;
                        }
                    }
                }
            }
            state.width = tileWidth;
            state.height = tileHeight;
            elements.tileWidth.value = tileWidth;
            elements.tileHeight.value = tileHeight;

            // Create pixel data for the full group
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();
            state.pixels = ctx.createImageData(totalWidth, totalHeight);

            // Load each tile from the master sheet
            if (state.masterSheet.png) {
                try {
                    const sheetImg = new Image();
                    await new Promise((resolve, reject) => {
                        sheetImg.onload = resolve;
                        sheetImg.onerror = reject;
                        sheetImg.src = state.masterSheet.png;
                    });

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = totalWidth;
                    tempCanvas.height = totalHeight;
                    const tempCtx = tempCanvas.getContext('2d');

                    for (let row = 0; row < group.rows; row++) {
                        for (let col = 0; col < group.cols; col++) {
                            const tileName = arrangement[row]?.[col];
                            if (tileName) {
                                const tile = state.masterTiles.find(t => t.name === tileName);
                                if (tile) {
                                    tempCtx.drawImage(
                                        sheetImg,
                                        tile.x, tile.y, tile.width, tile.height,
                                        col * tileWidth, row * tileHeight, tileWidth, tileHeight
                                    );
                                }
                            }
                        }
                    }

                    const imgData = tempCtx.getImageData(0, 0, totalWidth, totalHeight);
                    state.pixels.data.set(imgData.data);
                } catch (e) {
                    console.warn('Failed to load group tiles:', e);
                }
            }

            renderTileSelector();
            updateCanvasSize();
            renderTileGroups();
            renderTileLibrary();
            state.undoStack = [];
            state.redoStack = [];
            updateUndoRedoButtons();
            state.isDirty = false;
            elements.saveIndicator.textContent = 'Group';
            elements.saveIndicator.className = 'save-indicator master';
        }

        function renderTileLibrary() {
            elements.libraryGrid.innerHTML = '';

            const tiles = state.libraryView === 'draft' ? state.draftTiles : state.masterTiles;
            const sheetPng = state.libraryView === 'draft' ? state.draftSheet.png : state.masterSheet.png;

            if (tiles.length === 0 || !sheetPng) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'library-empty';
                emptyMsg.textContent = state.libraryView === 'draft'
                    ? 'No drafts yet. Save a tile to get started.'
                    : 'No tiles on master sheet.';
                elements.libraryGrid.appendChild(emptyMsg);
                return;
            }

            // Load the sheet image once for all tiles
            const sheetImg = new Image();
            sheetImg.onerror = () => {
                console.warn('Failed to load sheet image');
                const errorMsg = document.createElement('div');
                errorMsg.className = 'library-empty';
                errorMsg.textContent = 'Failed to load tile sheet.';
                elements.libraryGrid.appendChild(errorMsg);
            };
            sheetImg.src = sheetPng;
            sheetImg.onload = () => {
                tiles.forEach(tile => {
                    const tileEl = document.createElement('div');
                    tileEl.className = 'library-tile';
                    if (tile.name === state.currentTileName && state.currentTileSource === state.libraryView) {
                        tileEl.classList.add('active');
                    }

                    // Render thumbnail by extracting from sheet
                    const canvas = document.createElement('canvas');
                    const thumbSize = 40;
                    const scale = Math.min(thumbSize / tile.width, thumbSize / tile.height);
                    canvas.width = Math.floor(tile.width * scale);
                    canvas.height = Math.floor(tile.height * scale);

                    const tCtx = canvas.getContext('2d');
                    tCtx.imageSmoothingEnabled = false;
                    tCtx.drawImage(
                        sheetImg,
                        tile.x, tile.y, tile.width, tile.height,
                        0, 0, canvas.width, canvas.height
                    );

                    tileEl.appendChild(canvas);
                    tileEl.title = tile.name;

                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'library-tile-delete';
                    deleteBtn.textContent = '×';
                    deleteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await handleTileDelete(tile.name, state.libraryView);
                    });
                    tileEl.appendChild(deleteBtn);

                    tileEl.addEventListener('click', () => loadTileFromSheet(tile, state.libraryView));

                    elements.libraryGrid.appendChild(tileEl);
                });
            };
        }

        // Handle tile deletion with usage check for master tiles
        async function handleTileDelete(tileName, source) {
            if (source === 'master') {
                // Check usage before deleting from master
                try {
                    const usage = await crucibleClient.getTileUsage(state.projectId, tileName);
                    const usedIn = [];
                    if (usage.groups.length > 0) {
                        usedIn.push(`${usage.groups.length} group(s)`);
                    }
                    if (usage.levels.length > 0) {
                        usedIn.push(`${usage.levels.length} level(s)`);
                    }

                    if (usedIn.length > 0) {
                        const proceed = confirm(
                            `"${tileName}" is used in ${usedIn.join(' and ')}.\n\n` +
                            `Deleting will remove it from all uses. Continue?`
                        );
                        if (!proceed) return;
                    } else if (!confirm(`Delete "${tileName}" from Master Sheet?`)) {
                        return;
                    }

                    await crucibleClient.deleteTileFromMaster(state.projectId, tileName);
                    showToast(`Deleted "${tileName}" from master`);
                } catch (err) {
                    console.error('Failed to delete tile:', err);
                    showToast('Failed to delete tile', true);
                    return;
                }
            } else {
                // Draft tiles can be deleted without warning
                if (!confirm(`Delete "${tileName}" from drafts?`)) return;

                try {
                    await crucibleClient.removeFromDraft(state.projectId, tileName);
                    showToast(`Deleted "${tileName}" from drafts`);
                } catch (err) {
                    console.error('Failed to delete draft tile:', err);
                    showToast('Failed to delete tile', true);
                    return;
                }
            }

            // Clear current tile if it was the deleted one
            if (state.currentTileName === tileName && state.currentTileSource === source) {
                newTile();
            }

            // Refresh the library
            await selectProject(state.projectId);
        }

        // Load tile from sheet (draft or master) with edit protection for MTS
        async function loadTileFromSheet(tile, source) {
            // Edit protection for Master tiles
            if (source === 'master') {
                const choice = await showEditProtectionDialog(tile.name);
                if (choice === 'cancel') return;
                if (choice === 'copy') {
                    // Create a copy - prompt for new name and load as draft
                    const newName = prompt(`Enter name for the copy:`, `${tile.name}_copy`);
                    if (!newName || newName.trim() === '') return;

                    try {
                        // Duplicate from master to draft
                        await crucibleClient.duplicateTileOnMaster(state.projectId, tile.name, newName.trim());
                        // Now move that copy to draft and load it
                        // Actually we need to extract and save to draft
                        const sheetPng = state.masterSheet.png;
                        const sheetImg = new Image();
                        await new Promise((resolve, reject) => {
                            sheetImg.onload = resolve;
                            sheetImg.onerror = reject;
                            sheetImg.src = sheetPng;
                        });

                        // Extract tile from master sheet
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = tile.width;
                        tempCanvas.height = tile.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(
                            sheetImg,
                            tile.x, tile.y, tile.width, tile.height,
                            0, 0, tile.width, tile.height
                        );
                        const imageData = tempCanvas.toDataURL('image/png');

                        // Save to draft
                        await crucibleClient.saveToDraft(state.projectId, newName.trim(), imageData, tile.width, tile.height);

                        // Reload sheets and switch to draft view
                        await selectProject(state.projectId);
                        switchSheetView('draft');

                        // Load the new draft tile
                        const newDraftTile = state.draftTiles.find(t => t.name === newName.trim());
                        if (newDraftTile) {
                            await loadTileFromSheetInternal(newDraftTile, 'draft');
                        }
                        showToast(`Created copy "${newName.trim()}" in drafts`);
                        return;
                    } catch (err) {
                        console.error('Failed to create copy:', err);
                        showToast('Failed to create copy', true);
                        return;
                    }
                }
                // choice === 'edit' - proceed with loading the master tile (read-only warning acknowledged)
            }

            await loadTileFromSheetInternal(tile, source);
        }

        // Internal function to load tile without protection checks
        async function loadTileFromSheetInternal(tile, source) {
            state.currentTileId = null; // Sheet tiles don't have IDs
            state.currentTileName = tile.name;
            state.currentTileSource = source;

            // Load tileset metadata if available
            const meta = tile.metadata || {};
            if (meta.tileWidth && meta.tileHeight && meta.gridCols && meta.gridRows) {
                state.width = meta.tileWidth;
                state.height = meta.tileHeight;
                state.gridCols = meta.gridCols;
                state.gridRows = meta.gridRows;
            } else {
                // Fallback: treat as single tile
                state.width = tile.width;
                state.height = tile.height;
                state.gridCols = 1;
                state.gridRows = 1;
            }

            state.selectedTileX = 0;
            state.selectedTileY = 0;

            elements.tileName.value = tile.name;
            elements.tileWidth.value = state.width;
            elements.tileHeight.value = state.height;
            elements.gridCols.value = state.gridCols;
            elements.gridRows.value = state.gridRows;
            elements.tileType.value = meta.tileType || '';

            if (meta.palette && meta.palette.length > 0) {
                state.palette = meta.palette.map(p => p.hex || p);
                elements.palettePreset.value = 'custom';
                renderPalette();
            }

            // Create new pixel data
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();
            state.pixels = ctx.createImageData(totalWidth, totalHeight);

            // Extract tile from sheet
            const sheetPng = source === 'draft' ? state.draftSheet.png : state.masterSheet.png;
            if (sheetPng) {
                try {
                    const sheetImg = new Image();
                    await new Promise((resolve, reject) => {
                        sheetImg.onload = resolve;
                        sheetImg.onerror = reject;
                        sheetImg.src = sheetPng;
                    });

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = tile.width;
                    tempCanvas.height = tile.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(
                        sheetImg,
                        tile.x, tile.y, tile.width, tile.height,
                        0, 0, tile.width, tile.height
                    );

                    const imgData = tempCtx.getImageData(0, 0, tile.width, tile.height);
                    state.pixels.data.set(imgData.data);
                } catch (e) {
                    console.warn('Failed to load tile from sheet:', e);
                }
            }

            renderTileSelector();
            updateCanvasSize();
            renderTileLibrary();
            state.undoStack = [];
            state.redoStack = [];
            updateUndoRedoButtons();
            state.isDirty = false;
            elements.saveIndicator.textContent = source === 'master' ? 'Master' : 'Draft';
            elements.saveIndicator.className = `save-indicator ${source}`;
        }

        // Show edit protection dialog for MTS tiles
        function showEditProtectionDialog(tileName) {
            return new Promise((resolve) => {
                const result = confirm(
                    `"${tileName}" is on the Master Sheet.\n\n` +
                    `Changes will affect everywhere this tile is used.\n\n` +
                    `Click OK to edit the original, or Cancel to make a copy instead.`
                );

                if (result) {
                    resolve('edit');
                } else {
                    // Ask if they want to make a copy
                    const makeCopy = confirm('Would you like to make a copy to edit instead?');
                    resolve(makeCopy ? 'copy' : 'cancel');
                }
            });
        }

        // Legacy loadTile for backwards compatibility (if needed)
        async function loadTile(tile) {
            // Convert old-style tile to sheet format and load
            const sheetTile = {
                name: tile.name,
                width: tile.width,
                height: tile.height,
                x: 0,
                y: 0,
                metadata: tile.metadata || {}
            };

            // For legacy tiles, treat as draft
            state.currentTileName = tile.name;
            state.currentTileSource = 'draft';
            await loadTileFromSheetInternal(sheetTile, 'draft');
        }

        function newTile() {
            state.currentTileId = null;
            state.currentTileName = null;
            state.currentTileSource = 'new';
            state.currentGroupId = null;
            state.width = parseInt(elements.tileWidth.value) || 16;
            state.height = parseInt(elements.tileHeight.value) || 16;

            // Reset grid to 1x1
            state.gridCols = 1;
            state.gridRows = 1;
            state.selectedTileX = 0;
            state.selectedTileY = 0;
            elements.gridCols.value = 1;
            elements.gridRows.value = 1;

            elements.tileName.value = '';
            elements.tileType.value = '';

            renderTileSelector();
            initializeCanvas();
            renderTileLibrary();
            renderTileGroups();
            state.undoStack = [];
            state.redoStack = [];
            updateUndoRedoButtons();
            state.isDirty = false;
            elements.saveIndicator.textContent = 'New';
            elements.saveIndicator.className = 'save-indicator';
        }

        // Create a new tile group from canvas contents
        async function createNewGroup() {
            // Must be on master view to create groups
            if (state.libraryView !== 'master') {
                switchSheetView('master');
            }

            // Must have multiple tiles to create a group
            if (state.gridCols === 1 && state.gridRows === 1) {
                showToast('Expand the grid to create a multi-tile group', true);
                return;
            }

            const groupName = prompt('Enter a name for this group:', '');
            if (!groupName || groupName.trim() === '') return;

            // Build arrangement from current grid
            // For now, auto-generate tile names based on group name
            const arrangement = [];
            const tilesToSave = [];

            for (let row = 0; row < state.gridRows; row++) {
                const rowArr = [];
                for (let col = 0; col < state.gridCols; col++) {
                    const tileName = `${groupName.trim()}_${row}_${col}`;
                    rowArr.push(tileName);

                    // Extract tile pixel data
                    const tileCanvas = document.createElement('canvas');
                    tileCanvas.width = state.width;
                    tileCanvas.height = state.height;
                    const tileCtx = tileCanvas.getContext('2d');

                    // Copy from state.pixels
                    const tileData = tileCtx.createImageData(state.width, state.height);
                    const srcX = col * state.width;
                    const srcY = row * state.height;
                    const totalWidth = getTotalWidth();

                    for (let y = 0; y < state.height; y++) {
                        for (let x = 0; x < state.width; x++) {
                            const srcIdx = ((srcY + y) * totalWidth + (srcX + x)) * 4;
                            const dstIdx = (y * state.width + x) * 4;
                            tileData.data[dstIdx] = state.pixels.data[srcIdx];
                            tileData.data[dstIdx + 1] = state.pixels.data[srcIdx + 1];
                            tileData.data[dstIdx + 2] = state.pixels.data[srcIdx + 2];
                            tileData.data[dstIdx + 3] = state.pixels.data[srcIdx + 3];
                        }
                    }

                    tileCtx.putImageData(tileData, 0, 0);
                    const imageData = tileCanvas.toDataURL('image/png');

                    tilesToSave.push({
                        name: tileName,
                        imageData,
                        width: state.width,
                        height: state.height
                    });
                }
                arrangement.push(rowArr);
            }

            elements.saveIndicator.textContent = 'Saving...';
            elements.saveIndicator.className = 'save-indicator saving';

            try {
                // Save all tiles to master tile sheet
                for (const tile of tilesToSave) {
                    if (crucibleClient.publishToMasterTileSheet) {
                        await crucibleClient.publishToMasterTileSheet(
                            state.projectId,
                            tile.name,
                            tile.imageData,
                            tile.width,
                            tile.height
                        );
                    }
                }

                // Create the group record
                await crucibleClient.createTileGroup(
                    state.projectId,
                    groupName.trim(),
                    state.gridCols,
                    state.gridRows,
                    arrangement
                );

                // Refresh
                await selectProject(state.projectId);
                switchSheetView('master');

                elements.saveIndicator.textContent = 'Group Created';
                elements.saveIndicator.className = 'save-indicator saved';
                showToast(`Created group "${groupName.trim()}" with ${tilesToSave.length} tiles`);
            } catch (err) {
                console.error('Failed to create group:', err);
                elements.saveIndicator.textContent = 'Save failed';
                elements.saveIndicator.className = 'save-indicator';
                showToast('Failed to create group', true);
            }
        }

        async function saveTile() {
            if (!state.user) {
                showToast('Sign in to save tiles', true);
                return;
            }

            if (!state.projectId) {
                showToast('Select a project first', true);
                return;
            }

            const name = elements.tileName.value.trim();
            if (!name) {
                showToast('Enter a tile name', true);
                return;
            }

            // Convert pixels to data URL (full tileset)
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = totalWidth;
            tempCanvas.height = totalHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(state.pixels, 0, 0);
            const pixelData = tempCanvas.toDataURL('image/png');

            elements.saveIndicator.textContent = 'Saving...';
            elements.saveIndicator.className = 'save-indicator saving';

            try {
                // Determine where to save based on current tile source
                if (state.currentTileSource === 'master') {
                    // Saving changes to a master tile - update master tile sheet
                    // First remove old version if name changed
                    if (state.currentTileName && state.currentTileName !== name) {
                        if (crucibleClient.removeFromMasterTileSheet) {
                            await crucibleClient.removeFromMasterTileSheet(state.projectId, state.currentTileName);
                        }
                    } else if (state.currentTileName) {
                        // Remove old version with same name (we're replacing it)
                        if (crucibleClient.removeFromMasterTileSheet) {
                            await crucibleClient.removeFromMasterTileSheet(state.projectId, state.currentTileName);
                        }
                    }

                    // Add updated tile to master tile sheet
                    if (crucibleClient.publishToMasterTileSheet) {
                        await crucibleClient.publishToMasterTileSheet(state.projectId, name, pixelData, totalWidth, totalHeight);
                    }
                    state.currentTileName = name;

                    elements.saveIndicator.textContent = 'Master';
                    elements.saveIndicator.className = 'save-indicator saved master';
                    showToast('Tile saved to Master Tile Sheet');
                } else {
                    // New tile or draft tile - save to draft sheet
                    // If editing existing draft, remove old version first
                    if (state.currentTileSource === 'draft' && state.currentTileName) {
                        if (state.currentTileName !== name) {
                            // Name changed - remove old
                            await crucibleClient.removeFromDraft(state.projectId, state.currentTileName);
                        } else {
                            // Same name - remove to replace
                            await crucibleClient.removeFromDraft(state.projectId, state.currentTileName);
                        }
                    }

                    // Save to draft
                    await crucibleClient.saveToDraft(state.projectId, name, pixelData, totalWidth, totalHeight);

                    state.currentTileName = name;
                    state.currentTileSource = 'draft';

                    elements.saveIndicator.textContent = 'Draft';
                    elements.saveIndicator.className = 'save-indicator saved draft';
                    showToast('Tile saved to Draft Sheet');
                }

                // Refresh sheets
                await selectProject(state.projectId);

                // If we saved to draft, switch to draft view
                if (state.currentTileSource === 'draft') {
                    switchSheetView('draft');
                }

                state.isDirty = false;

            } catch (err) {
                console.error('Failed to save tile:', err);
                elements.saveIndicator.textContent = 'Save failed';
                elements.saveIndicator.className = 'save-indicator';
                showToast('Failed to save tile', true);
            }
        }

        // Publish tile from draft to master
        async function publishTile(tileName) {
            if (!tileName) {
                // If no name provided, use currently loaded tile
                tileName = state.currentTileName;
            }

            if (!tileName || state.currentTileSource !== 'draft') {
                showToast('Select a draft tile to publish', true);
                return;
            }

            try {
                if (crucibleClient.publishDraftToMasterTileSheet) {
                    await crucibleClient.publishDraftToMasterTileSheet(state.projectId, tileName);
                } else {
                    // Fallback to old method
                    await crucibleClient.publishDraftToMaster(state.projectId, tileName);
                }
                showToast(`Published "${tileName}" to Master Tile Sheet`);

                // Refresh and switch to master view
                await selectProject(state.projectId);
                switchSheetView('master');

                // Clear current tile since it's no longer in draft
                if (state.currentTileName === tileName) {
                    newTile();
                }
            } catch (err) {
                console.error('Failed to publish tile:', err);
                showToast('Failed to publish tile', true);
            }
        }

        // Publish all drafts to master
        async function publishAllDrafts() {
            if (state.draftTiles.length === 0) {
                showToast('No drafts to publish', true);
                return;
            }

            if (!confirm(`Publish all ${state.draftTiles.length} draft tiles to Master Sheet?`)) {
                return;
            }

            try {
                const result = await crucibleClient.publishAllDraftsToMaster(state.projectId);
                showToast(`Published ${result.published} tiles to Master Sheet`);

                // Refresh and switch to master view
                await selectProject(state.projectId);
                switchSheetView('master');
                newTile();
            } catch (err) {
                console.error('Failed to publish all drafts:', err);
                showToast('Failed to publish drafts', true);
            }
        }

        // Legacy deleteTile for backwards compatibility
        async function deleteTile(tileId) {
            // This function is deprecated - use handleTileDelete instead
            console.warn('deleteTile is deprecated, use handleTileDelete');
            try {
                await crucibleClient.deleteTile(tileId);
                state.tiles = state.tiles.filter(t => t.id !== tileId);

                if (state.currentTileId === tileId) {
                    newTile();
                }

                renderTileLibrary();
                showToast('Tile deleted');
            } catch (err) {
                console.error('Failed to delete tile:', err);
                showToast('Failed to delete tile', true);
            }
        }

        function markDirty() {
            state.isDirty = true;
            elements.saveIndicator.textContent = 'Modified';
            elements.saveIndicator.className = 'save-indicator';
        }

        // ==========================================
        // AI GENERATION
        // ==========================================
        async function openAiModal() {
            // Load and store project settings
            const styleInfoEl = document.getElementById('projectStyleText');

            // Default values
            state.projectStyle = {
                outline: 'single color black outline',
                shading: 'basic shading',
                detail: 'medium detail',
                size: 16
            };

            if (state.projectId) {
                try {
                    const settings = await crucibleClient.getProjectSettings(state.projectId);
                    const style = settings.pixellab?.tileStyle || {};
                    const tileDefaults = settings.pixellab?.tileDefaults || {};

                    // Store style settings (these are now inherited, not editable)
                    if (style.outline) state.projectStyle.outline = style.outline;
                    if (style.shading) state.projectStyle.shading = style.shading;
                    if (style.detail) state.projectStyle.detail = style.detail;
                    if (tileDefaults.size) state.projectStyle.size = parseInt(tileDefaults.size);

                    // Pre-fill view/perspective (still editable)
                    if (style.view) {
                        const perspectiveEl = document.getElementById('aiPerspective');
                        const tilesetViewEl = document.getElementById('aiTilesetView');
                        if (style.view.includes('top_down')) {
                            perspectiveEl.value = style.view === 'high_top_down' ? 'high top-down' : 'low top-down';
                            if (tilesetViewEl) tilesetViewEl.value = style.view.replace('_', ' ');
                        } else if (style.view === 'side') {
                            perspectiveEl.value = 'side';
                        } else if (style.view.includes('isometric')) {
                            perspectiveEl.value = 'isometric';
                        }
                    }

                    // Pre-fill transition size for tilesets (still editable)
                    const transitionEl = document.getElementById('aiTransitionSize');
                    if (transitionEl && tileDefaults.transitionSize) {
                        const transitionMap = { 'sharp': 0.1, 'medium': 0.25, 'wide': 0.5 };
                        transitionEl.value = transitionMap[tileDefaults.transitionSize] || 0.25;
                    }
                } catch (err) {
                    console.warn('Could not load project settings:', err);
                }
            }

            // Display project style info
            const outlineLabel = state.projectStyle.outline === 'none' ? 'No Outline' :
                                 state.projectStyle.outline.includes('black') ? 'Black Outline' : 'Colored Outline';
            const shadingLabel = state.projectStyle.shading.includes('flat') ? 'Flat' :
                                 state.projectStyle.shading.includes('detailed') ? 'Detailed' : 'Basic';
            const detailLabel = state.projectStyle.detail.includes('low') ? 'Low Detail' :
                                state.projectStyle.detail.includes('high') ? 'High Detail' : 'Medium Detail';

            styleInfoEl.textContent = `${state.projectStyle.size}px • ${shadingLabel} • ${detailLabel} • ${outlineLabel}`;

            elements.aiModal.classList.add('active');
        }

        function closeAiModal() {
            elements.aiModal.classList.remove('active');
        }

        async function generateTileWithPixelLab() {
            const genType = document.querySelector('input[name="genType"]:checked').value;

            // Use inherited project style settings
            const outline = state.projectStyle.outline;
            const shading = state.projectStyle.shading;
            const detail = state.projectStyle.detail;
            const size = state.projectStyle.size;

            const style = {
                outline: outline === 'none' ? undefined : outline,
                shading: shading,
                detail: detail
            };

            elements.aiModalGenerate.disabled = true;
            elements.aiModalGenerate.textContent = 'Queueing...';

            try {
                const client = new PixelLabClient();
                let result;
                let jobType;
                let prompt;

                if (genType === 'tileset') {
                    // Tileset generation
                    const tilesetType = document.getElementById('aiTilesetType').value;
                    const lowerDesc = document.getElementById('aiLowerDesc').value.trim();
                    const upperDesc = document.getElementById('aiUpperDesc').value.trim();
                    const transitionDesc = document.getElementById('aiTransitionDesc').value.trim();
                    const transitionSize = parseFloat(document.getElementById('aiTransitionSize').value);
                    const view = document.getElementById('aiTilesetView').value;

                    if (tilesetType === 'topdown') {
                        if (!lowerDesc || !upperDesc) {
                            showToast('Enter both lower and upper material descriptions', true);
                            elements.aiModalGenerate.disabled = false;
                            elements.aiModalGenerate.textContent = 'Generate Tile';
                            return;
                        }
                        result = await client.createTopdownTileset({
                            lowerDescription: lowerDesc,
                            upperDescription: upperDesc,
                            transitionSize,
                            tileSize: size,
                            view,
                            style
                        });
                        jobType = 'tileset_topdown';
                        prompt = `${lowerDesc} → ${upperDesc}`;
                    } else {
                        if (!lowerDesc) {
                            showToast('Enter a material description', true);
                            elements.aiModalGenerate.disabled = false;
                            elements.aiModalGenerate.textContent = 'Generate Tile';
                            return;
                        }
                        result = await client.createSidescrollerTileset({
                            lowerDescription: lowerDesc,
                            transitionDescription: transitionDesc || undefined,
                            transitionSize,
                            tileSize: size,
                            style
                        });
                        jobType = 'tileset_sidescroller';
                        prompt = transitionDesc ? `${lowerDesc} (${transitionDesc})` : lowerDesc;
                    }
                } else {
                    // Single tile generation
                    const description = document.getElementById('aiDescription').value.trim();
                    const perspective = document.getElementById('aiPerspective').value;
                    const isoShape = document.getElementById('aiIsoShape').value;

                    if (!description) {
                        showToast('Enter a tile description', true);
                        elements.aiModalGenerate.disabled = false;
                        elements.aiModalGenerate.textContent = 'Generate Tile';
                        return;
                    }

                    prompt = description;

                    if (perspective === 'isometric') {
                        result = await client.createIsometricTile({
                            description,
                            size,
                            tileShape: isoShape,
                            style
                        });
                        jobType = 'isometric_tile';
                    } else {
                        result = await client.createMapObject({
                            description,
                            width: size,
                            height: size,
                            view: perspective,
                            style
                        });
                        jobType = 'map_object';
                    }
                }

                if (result.job_id) {
                    if (state.generationQueue) {
                        await state.generationQueue.addJob({
                            pixellab_job_id: result.job_id,
                            job_type: jobType,
                            prompt: prompt,
                            parameters: { genType, size, style },
                            project_id: state.projectId,
                            user_id: state.user?.id
                        });
                    }

                    closeAiModal();
                    showToast('Generation queued! Track progress in the queue panel.');
                } else {
                    throw new Error('No job ID returned from PixelLab');
                }
            } catch (err) {
                console.error('Failed to queue generation:', err);
                showToast(err.message || 'Failed to queue generation', true);
            } finally {
                elements.aiModalGenerate.disabled = false;
                elements.aiModalGenerate.textContent = 'Generate Tile';
            }
        }

        function displaySpec(spec) {
            elements.aiSpecPreview.classList.remove('empty');

            let html = `<div class="ai-spec-name">${spec.tileName || 'Generated Tile'}</div>`;
            html += `<div>${spec.description || ''}</div>`;

            // Show palette colors
            if (spec.palette && spec.palette.length > 0) {
                html += `<div class="ai-spec-colors">`;
                spec.palette.forEach(hex => {
                    html += `<div class="ai-spec-color" style="background:${hex}" title="${hex}"></div>`;
                });
                html += `</div>`;
                html += `<button class="btn btn-small ai-spec-apply" onclick="applySpecPalette()">Apply Palette</button>`;
            }

            // Show preview canvas if pixels are available
            if (spec.pixels && Array.isArray(spec.pixels)) {
                html += `<div style="margin-top: 12px;">`;
                html += `<strong style="font-size: 10px; color: var(--stone-mid);">Preview:</strong>`;
                html += `<div style="margin-top: 8px; display: flex; justify-content: center;">`;
                html += `<canvas id="specPreviewCanvas" style="image-rendering: pixelated; border: 1px solid var(--stone-dark);"></canvas>`;
                html += `</div>`;
                html += `<button class="btn btn-primary" style="width: 100%; margin-top: 12px;" onclick="applyGeneratedPixels()">Apply to Canvas</button>`;
                html += `</div>`;
            }

            elements.aiSpecPreview.innerHTML = html;

            // Render preview if pixels available
            if (spec.pixels && Array.isArray(spec.pixels)) {
                renderSpecPreview(spec.pixels);
            }
        }

        function renderSpecPreview(pixels) {
            const canvas = document.getElementById('specPreviewCanvas');
            if (!canvas) return;

            const height = pixels.length;
            const width = pixels[0]?.length || 0;
            if (!width || !height) return;

            // Set canvas size with zoom for visibility
            const previewZoom = 4;
            canvas.width = width * previewZoom;
            canvas.height = height * previewZoom;

            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // Draw each pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const hex = pixels[y]?.[x];
                    if (hex && hex !== '#00000000') {
                        ctx.fillStyle = hex;
                        ctx.fillRect(x * previewZoom, y * previewZoom, previewZoom, previewZoom);
                    }
                }
            }
        }

        function applyGeneratedPixels() {
            if (!state.currentSpec || !state.currentSpec.pixels) {
                showToast('No pixel data to apply', true);
                return;
            }

            const pixels = state.currentSpec.pixels;
            const genHeight = pixels.length;
            const genWidth = pixels[0]?.length || 0;

            if (!genWidth || !genHeight) {
                showToast('Invalid pixel data', true);
                return;
            }

            // If generated size doesn't match tile size, update tile dimensions
            if (genWidth !== state.width || genHeight !== state.height) {
                state.width = genWidth;
                state.height = genHeight;
                elements.tileWidth.value = genWidth;
                elements.tileHeight.value = genHeight;

                // Recreate pixel data with new dimensions
                const totalWidth = state.width * state.gridCols;
                const totalHeight = state.height * state.gridRows;
                state.pixels = ctx.createImageData(totalWidth, totalHeight);
                updateCanvasSize();
            }

            // Save undo state
            saveUndoState();

            // Calculate offset for selected tile
            const offsetX = state.selectedTileX * state.width;
            const offsetY = state.selectedTileY * state.height;

            // Apply pixels to the selected tile position
            for (let y = 0; y < genHeight; y++) {
                for (let x = 0; x < genWidth; x++) {
                    const hex = pixels[y]?.[x];
                    if (hex === '#00000000' || !hex) {
                        setPixel(offsetX + x, offsetY + y, '#000000', 0); // Transparent
                    } else {
                        setPixel(offsetX + x, offsetY + y, hex, 255);
                    }
                }
            }

            render();
            markDirty();
            showToast('Tile applied to canvas!');
        }

        function applySpecPalette() {
            if (!state.currentSpec || !state.currentSpec.palette) return;

            state.palette = [...state.currentSpec.palette];
            elements.palettePreset.value = 'custom';
            selectColor(state.palette[0]);
            showToast('Palette applied from spec');
        }

        // ==========================================
        // EXPORT
        // ==========================================
        function downloadPng() {
            const totalWidth = getTotalWidth();
            const totalHeight = getTotalHeight();

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = totalWidth;
            tempCanvas.height = totalHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(state.pixels, 0, 0);

            const link = document.createElement('a');
            const name = elements.tileName.value || 'tileset';
            const suffix = (state.gridCols > 1 || state.gridRows > 1) ? `_${state.gridCols}x${state.gridRows}` : '';
            link.download = `${name}${suffix}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }

        async function publishToMaster() {
            if (!state.currentProjectId) {
                showToast('Please select a project first', true);
                return;
            }

            const tileName = elements.tileName.value.trim();
            if (!tileName) {
                showToast('Please enter a tile name', true);
                return;
            }

            // Check if crucibleClient has master tile sheet methods
            const publishMethod = crucibleClient.publishToMasterTileSheet || crucibleClient.publishToMasterSheet;
            if (!publishMethod) {
                showToast('Master tile sheet feature not available', true);
                return;
            }

            try {
                elements.masterSheetStatus.textContent = 'Publishing...';
                elements.publishMasterBtn.disabled = true;

                // Create image from current pixels
                const totalWidth = getTotalWidth();
                const totalHeight = getTotalHeight();

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = totalWidth;
                tempCanvas.height = totalHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(state.pixels, 0, 0);

                // If multi-tile, publish each tile separately
                if (state.gridCols > 1 || state.gridRows > 1) {
                    let publishedCount = 0;
                    for (let row = 0; row < state.gridRows; row++) {
                        for (let col = 0; col < state.gridCols; col++) {
                            const tileX = col * state.width;
                            const tileY = row * state.height;
                            const tileImageData = tempCtx.getImageData(tileX, tileY, state.width, state.height);

                            // Generate unique name for each tile in the set
                            const subName = `${tileName}_${row}_${col}`;

                            await publishMethod.call(
                                crucibleClient,
                                state.currentProjectId,
                                subName,
                                tileImageData,
                                state.width,
                                state.height,
                                'tilesmith'
                            );
                            publishedCount++;
                            elements.masterSheetStatus.textContent = `Publishing tile ${publishedCount}/${state.gridCols * state.gridRows}...`;
                        }
                    }
                    elements.masterSheetStatus.textContent = `Published ${publishedCount} tiles`;
                    showToast(`Published ${publishedCount} tiles to master tile sheet`);
                } else {
                    // Single tile
                    await publishMethod.call(
                        crucibleClient,
                        state.currentProjectId,
                        tileName,
                        state.pixels,
                        state.width,
                        state.height,
                        'tilesmith'
                    );
                    elements.masterSheetStatus.textContent = 'Published to master tile sheet';
                    showToast('Published to master tile sheet');
                }
            } catch (err) {
                console.error('Failed to publish to master tile sheet:', err);
                elements.masterSheetStatus.textContent = 'Failed to publish';
                showToast('Failed to publish: ' + err.message, true);
            } finally {
                elements.publishMasterBtn.disabled = false;
            }
        }

        // ==========================================
        // UTILITIES
        // ==========================================
        function showToast(message, isError = false) {
            elements.toast.textContent = message;
            elements.toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => elements.toast.classList.remove('show'), 2500);
        }

        // ==========================================
        // EVENT LISTENERS
        // ==========================================
        function setupEventListeners() {
            // Project select
            elements.projectSelect.addEventListener('change', (e) => {
                selectProject(e.target.value);
            });

            // Canvas mouse events
            elements.mainCanvas.addEventListener('mousedown', handleMouseDown);
            elements.mainCanvas.addEventListener('mousemove', handleMouseMove);
            elements.mainCanvas.addEventListener('mouseup', handleMouseUp);
            elements.mainCanvas.addEventListener('mouseleave', (e) => {
                handleMouseUp(e);
                hideColorTooltip();
            });
            elements.mainCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // Zoom buttons
            document.querySelectorAll('.zoom-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.zoom-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.zoom = parseInt(btn.dataset.zoom);
                    updateCanvasSize();
                });
            });

            // Grid toggle
            elements.gridToggle.addEventListener('change', (e) => {
                state.showGrid = e.target.checked;
                renderGrid();
            });

            // Tile borders toggle
            elements.tileBordersToggle.addEventListener('change', (e) => {
                state.showTileBorders = e.target.checked;
                renderGrid();
            });

            // Tileset grid controls
            elements.gridCols.addEventListener('change', updateTilesetGrid);
            elements.gridRows.addEventListener('change', updateTilesetGrid);

            // Tool buttons
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (btn.dataset.tool === 'clear') {
                        if (confirm('Clear current tile?')) clearCanvas();
                        return;
                    }
                    document.querySelectorAll('.tool-btn[data-tool]').forEach(b => {
                        if (b.dataset.tool !== 'clear') b.classList.remove('active');
                    });
                    btn.classList.add('active');
                    state.tool = btn.dataset.tool;
                });
            });

            // Undo/Redo buttons
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);

            // Color picker
            elements.colorPicker.addEventListener('input', (e) => {
                selectColor(e.target.value);
            });

            // Quick palette toggle
            elements.paletteToggleBtn.addEventListener('click', () => {
                elements.quickPaletteBar.classList.toggle('open');
                elements.paletteToggleBtn.classList.toggle('active');
            });

            // Quick color picker
            elements.quickColorPicker.addEventListener('input', (e) => {
                selectColor(e.target.value);
            });

            // Palette preset
            elements.palettePreset.addEventListener('change', (e) => {
                loadPalettePreset(e.target.value);
            });

            // Add/remove color
            elements.addColorBtn.addEventListener('click', () => {
                addColorToPalette(state.currentColor);
            });

            elements.removeColorBtn.addEventListener('click', removeColorFromPalette);

            // Tile size changes
            elements.tileWidth.addEventListener('change', () => {
                if (!state.currentTileId) {
                    state.width = parseInt(elements.tileWidth.value) || 16;
                    initializeCanvas();
                }
            });

            elements.tileHeight.addEventListener('change', () => {
                if (!state.currentTileId) {
                    state.height = parseInt(elements.tileHeight.value) || 16;
                    initializeCanvas();
                }
            });

            // New tile
            elements.newTileBtn.addEventListener('click', newTile);

            // Sheet tabs
            elements.draftTab.addEventListener('click', () => switchSheetView('draft'));
            elements.masterTab.addEventListener('click', () => switchSheetView('master'));

            // Publish buttons
            elements.publishTileBtn.addEventListener('click', () => publishTile());
            elements.publishAllBtn.addEventListener('click', () => publishAllDrafts());

            // New group button
            elements.newGroupBtn.addEventListener('click', () => createNewGroup());

            // AI modal
            elements.aiGenerateBtn.addEventListener('click', openAiModal);
            elements.aiModalClose.addEventListener('click', closeAiModal);
            elements.aiModalCancel.addEventListener('click', closeAiModal);
            elements.aiModalGenerate.addEventListener('click', generateTileWithPixelLab);

            // Toggle isometric shape selector based on perspective
            document.getElementById('aiPerspective').addEventListener('change', (e) => {
                const isoShape = document.getElementById('aiIsoShape');
                isoShape.disabled = e.target.value !== 'isometric';
            });

            // Toggle between single tile and tileset forms
            document.querySelectorAll('input[name="genType"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const isTileset = e.target.value === 'tileset';
                    document.getElementById('singleTileForm').style.display = isTileset ? 'none' : 'block';
                    document.getElementById('tilesetForm').style.display = isTileset ? 'block' : 'none';
                    document.getElementById('tilesetNote').style.display = isTileset ? 'inline' : 'none';
                    elements.aiModalGenerate.textContent = isTileset ? 'Generate Tileset' : 'Generate Tile';

                    // Update visual selection
                    document.getElementById('genTypeSingle').style.borderColor = isTileset ? 'transparent' : 'var(--accent)';
                    document.getElementById('genTypeTileset').style.borderColor = isTileset ? 'var(--accent)' : 'transparent';
                });
            });

            // Toggle tileset type (top-down vs sidescroller)
            document.getElementById('aiTilesetType').addEventListener('change', (e) => {
                const isTopdown = e.target.value === 'topdown';
                document.getElementById('upperDescGroup').style.display = isTopdown ? 'block' : 'none';
                document.getElementById('transitionDescGroup').style.display = isTopdown ? 'none' : 'block';
                document.getElementById('lowerDescLabel').textContent = isTopdown ? 'Lower Material *' : 'Platform Material *';
                document.getElementById('aiLowerDesc').placeholder = isTopdown ? 'e.g., grass, water, stone' : 'e.g., stone brick, wood plank, metal';
                // Hide view selector for sidescroller (it's always side view)
                document.getElementById('aiTilesetView').closest('.form-group').style.display = isTopdown ? 'block' : 'none';
            });

            // Export
            elements.saveTileBtn.addEventListener('click', saveTile);
            elements.downloadPngBtn.addEventListener('click', downloadPng);
            elements.publishMasterBtn.addEventListener('click', publishToMaster);

            // Keyboard shortcuts
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                // Alt key for temporary picker mode (hold to preview colors)
                if (e.key === 'Alt' && !state.tempPickerActive && state.tool !== 'picker') {
                    e.preventDefault();
                    state.tempPickerActive = true;
                    state.previousTool = state.tool;
                    selectTool('picker', true); // true = from temp picker
                    return;
                }

                if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    if (e.shiftKey) redo();
                    else undo();
                }

                if (e.key === 'p') selectTool('pencil');
                if (e.key === 'e') selectTool('eraser');
                if (e.key === 'f') selectTool('fill');
                if (e.key === 'i') {
                    // Pressing 'i' makes picker permanent (not temporary)
                    state.tempPickerActive = false;
                    state.previousTool = null;
                    selectTool('picker');
                }
                if (e.key === 'l') selectTool('line');
                if (e.key === 'r') selectTool(e.shiftKey ? 'rectfill' : 'rect');
                if (e.key === 'c') {
                    elements.quickPaletteBar.classList.toggle('open');
                    elements.paletteToggleBtn.classList.toggle('active');
                }
            });

            // Alt key release - restore previous tool
            window.addEventListener('keyup', (e) => {
                if (e.key === 'Alt' && state.tempPickerActive) {
                    state.tempPickerActive = false;
                    if (state.previousTool) {
                        selectTool(state.previousTool);
                        state.previousTool = null;
                    }
                    hideColorTooltip();
                }
            });
        }

        function selectTool(tool, fromTempPicker = false) {
            // If selecting a different tool while not in temp picker mode, clear temp state
            if (!fromTempPicker && tool !== 'picker') {
                state.tempPickerActive = false;
                state.previousTool = null;
            }

            state.tool = tool;
            document.querySelectorAll('.tool-btn[data-tool]').forEach(b => {
                if (b.dataset.tool !== 'clear') {
                    b.classList.toggle('active', b.dataset.tool === tool);
                }
            });

            // Hide color tooltip when switching away from picker
            if (tool !== 'picker') {
                hideColorTooltip();
            }
        }

        function handleMouseDown(e) {
            const { x, y } = getPixelPos(e);
            state.isDrawing = true;
            state.startX = x;
            state.startY = y;
            state.lastX = x;
            state.lastY = y;

            if (state.tool === 'picker') {
                const pixel = getPixel(x, y);
                if (pixel && pixel.a > 0) {
                    selectColor(rgbToHex(pixel.r, pixel.g, pixel.b));
                }
                return;
            }

            if (['pencil', 'eraser', 'fill'].includes(state.tool)) {
                saveUndoState();
            }

            if (state.tool === 'pencil') {
                setPixel(x, y, state.currentColor);
                render();
                markDirty();
            } else if (state.tool === 'eraser') {
                setPixel(x, y, '#000000', 0);
                render();
                markDirty();
            } else if (state.tool === 'fill') {
                floodFill(x, y, state.currentColor);
                render();
                markDirty();
            }
        }

        function handleMouseMove(e) {
            const { x, y } = getPixelPos(e);

            // Show color tooltip ONLY when picker tool is active (permanent or temporary)
            if (state.tool === 'picker') {
                if (x >= 0 && x < state.width && y >= 0 && y < state.height) {
                    const pixel = getPixel(x, y);
                    if (pixel && pixel.a > 0) {
                        const hex = rgbToHex(pixel.r, pixel.g, pixel.b);
                        showColorTooltip(hex, e.clientX, e.clientY);
                    } else {
                        hideColorTooltip();
                    }
                } else {
                    hideColorTooltip();
                }
            }

            if (!state.isDrawing) return;

            if (state.tool === 'pencil') {
                drawLine(state.lastX, state.lastY, x, y, state.currentColor);
                render();
                markDirty();
            } else if (state.tool === 'eraser') {
                drawLine(state.lastX, state.lastY, x, y, '#000000');
                // Set alpha to 0 for eraser
                let x0 = state.lastX, y0 = state.lastY;
                const dx = Math.abs(x - x0);
                const dy = Math.abs(y - y0);
                const sx = x0 < x ? 1 : -1;
                const sy = y0 < y ? 1 : -1;
                let err = dx - dy;

                while (true) {
                    setPixel(x0, y0, '#000000', 0);
                    if (x0 === x && y0 === y) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; x0 += sx; }
                    if (e2 < dx) { err += dx; y0 += sy; }
                }
                render();
                markDirty();
            }

            state.lastX = x;
            state.lastY = y;
        }

        function handleMouseUp(e) {
            if (!state.isDrawing) return;

            const { x, y } = getPixelPos(e);

            if (state.tool === 'line') {
                saveUndoState();
                drawLine(state.startX, state.startY, x, y, state.currentColor);
                render();
                markDirty();
            } else if (state.tool === 'rect' || state.tool === 'rectfill') {
                saveUndoState();
                const x0 = Math.min(state.startX, x);
                const y0 = Math.min(state.startY, y);
                const x1 = Math.max(state.startX, x);
                const y1 = Math.max(state.startY, y);

                if (state.tool === 'rectfill') {
                    for (let py = y0; py <= y1; py++) {
                        for (let px = x0; px <= x1; px++) {
                            setPixel(px, py, state.currentColor);
                        }
                    }
                } else {
                    for (let px = x0; px <= x1; px++) {
                        setPixel(px, y0, state.currentColor);
                        setPixel(px, y1, state.currentColor);
                    }
                    for (let py = y0; py <= y1; py++) {
                        setPixel(x0, py, state.currentColor);
                        setPixel(x1, py, state.currentColor);
                    }
                }

                render();
                markDirty();
            }

            state.isDrawing = false;
        }

        // ==========================================
        // Initialize
        // ==========================================
        init();
    </script>

    <!-- Color Tooltip -->
    <div class="color-tooltip" id="colorTooltip">
        <div class="color-tooltip-swatch" id="tooltipSwatch"></div>
        <div class="color-tooltip-hex" id="tooltipHex">#000000</div>
        <div class="color-tooltip-family" id="tooltipFamily">Gray › Black</div>
        <div class="color-tooltip-name" id="tooltipName">Black</div>
        <div class="color-tooltip-desc" id="tooltipDesc">Neutral, very dark</div>
    </div>

    <!-- Help Drawer -->
    <script src="../shared/help-drawer.js"></script>
    <script src="../shared/docs/tilesmith-docs.js"></script>
    <script>
        // Initialize help drawer with Tilesmith docs
        HelpDrawer.init({
            toolId: 'tilesmith',
            toolName: 'Tilesmith',
            toolIcon: '&#129513;',
            accentColor: '#40d080',
            docs: TILESMITH_DOCS
        });
    </script>
</body>
</html>
