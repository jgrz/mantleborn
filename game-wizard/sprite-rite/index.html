<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite-Rite | Mantleborn Dev Tools</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           MANTLEBORN SPRITE-RITE - CSS
           ============================================ */

        :root {
            /* Backgrounds */
            --bg-deep: #0d0d14;
            --bg-mid: #1a1a2e;
            --bg-surface: #252542;

            /* Accents - ember warmth */
            --accent-ember: #e07020;
            --accent-ember-glow: #ff9040;
            --accent-magma: #c04020;

            /* Stone/neutral tones */
            --stone-dark: #3a3a5c;
            --stone-mid: #6a6a8e;
            --stone-light: #9a9abe;
            --stone-bright: #d0d0e8;

            /* Purple undertones */
            --mystic-deep: #2a1a3e;
            --mystic-glow: #8060c0;

            /* Functional */
            --selection-fill: rgba(128, 96, 192, 0.3);
            --selection-border: #8060c0;
            --grid-line: rgba(106, 106, 142, 0.25);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--stone-light);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .home-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            font-size: 18px;
            text-decoration: none;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .home-btn:hover {
            background: var(--stone-dark);
            border-color: var(--accent-ember);
        }

        .brand-icon {
            font-size: 20px;
            animation: flicker 2s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            70% { opacity: 1; }
            75% { opacity: 0.7; }
            80% { opacity: 1; }
        }

        .brand-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .brand-text span {
            color: var(--accent-ember);
            text-shadow: 0 0 10px rgba(224, 112, 32, 0.5);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .sprite-select {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-light);
            cursor: pointer;
            min-width: 200px;
        }

        .sprite-select:hover {
            border-color: var(--stone-mid);
        }

        .sprite-select:focus {
            outline: none;
            border-color: var(--mystic-glow);
            box-shadow: 0 0 0 2px rgba(128, 96, 192, 0.2);
        }

        .sprite-select option {
            background: var(--bg-mid);
            color: var(--stone-light);
        }

        /* Buttons */
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--stone-dark);
            border-color: var(--stone-mid);
            box-shadow: inset 0 0 10px rgba(224, 112, 32, 0.2);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--mystic-glow);
        }

        .btn-primary {
            background: var(--accent-ember);
            border-color: var(--accent-ember);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--accent-ember-glow);
            border-color: var(--accent-ember-glow);
            box-shadow: 0 0 15px rgba(224, 112, 32, 0.4);
        }

        .btn-danger {
            color: var(--accent-magma);
        }

        .btn-danger:hover {
            background: var(--accent-magma);
            border-color: var(--accent-magma);
            color: var(--bg-deep);
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 300px;
            height: calc(100vh - 53px);
        }

        /* Canvas Area */
        .canvas-area {
            display: flex;
            flex-direction: column;
            background: var(--bg-deep);
            overflow: hidden;
        }

        .canvas-toolbar {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 10px 16px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toolbar-label {
            font-size: 11px;
            color: var(--stone-mid);
            text-transform: uppercase;
        }

        .zoom-buttons {
            display: flex;
            gap: 2px;
        }

        .zoom-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            padding: 4px 8px;
            border: 1px solid var(--stone-dark);
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.15s;
        }

        .zoom-btn:first-child {
            border-radius: 4px 0 0 4px;
        }

        .zoom-btn:last-child {
            border-radius: 0 4px 4px 0;
        }

        .zoom-btn:hover {
            background: var(--stone-dark);
        }

        .zoom-btn.active {
            background: var(--mystic-glow);
            border-color: var(--mystic-glow);
            color: var(--bg-deep);
        }

        .toggle-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 4px 10px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
        }

        .toggle-btn.active {
            background: var(--mystic-deep);
            border-color: var(--mystic-glow);
            color: var(--mystic-glow);
        }

        .tool-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 4px 10px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.15s;
        }

        .tool-btn:hover {
            border-color: var(--accent-ember);
            color: var(--accent-ember);
        }

        .tool-btn.active {
            background: var(--accent-ember);
            border-color: var(--accent-ember);
            color: var(--bg-deep);
        }

        .tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .selection-info {
            font-size: 12px;
            color: var(--stone-bright);
            font-family: 'JetBrains Mono', monospace;
        }

        .selection-info .coord {
            color: var(--accent-ember);
        }

        .image-info {
            margin-left: auto;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .canvas-wrapper {
            flex: 1;
            min-height: 0; /* Critical for flex scroll */
            position: relative;
            overflow: auto;
            background: var(--bg-deep);
        }

        .canvas-wrapper::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        .canvas-wrapper::-webkit-scrollbar-track {
            background: var(--bg-mid);
        }

        .canvas-wrapper::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 5px;
        }

        .canvas-wrapper::-webkit-scrollbar-thumb:hover {
            background: var(--accent-ember);
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            margin: 20px;
        }

        #mainCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }

        #gridCanvas, #selectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }

        #selectionCanvas {
            pointer-events: auto;
        }

        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-mid);
            border: 2px dashed var(--stone-dark);
            margin: 20px;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .drop-zone.drag-over {
            border-color: var(--accent-ember);
            background: var(--mystic-deep);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .drop-zone-text {
            font-size: 14px;
            color: var(--stone-mid);
            margin-bottom: 8px;
        }

        .drop-zone-hint {
            font-size: 11px;
            color: var(--stone-dark);
        }

        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border-left: 1px solid var(--stone-dark);
        }

        .sidebar-section {
            border-bottom: 1px solid var(--stone-dark);
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-surface);
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar-content {
            padding: 12px;
        }

        /* Create Sprite Panel */
        .create-sprite-panel {
            display: none;
        }

        .create-sprite-panel.active {
            display: block;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
            caret-color: var(--accent-ember);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-ember);
            box-shadow: 0 0 0 2px rgba(224, 112, 32, 0.3);
            background: var(--bg-mid);
        }

        .preview-container {
            display: flex;
            gap: 12px;
            margin: 12px 0;
        }

        .preview-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .preview-label {
            font-size: 9px;
            color: var(--stone-mid);
            margin-bottom: 6px;
            text-transform: uppercase;
        }

        .preview-canvas-wrapper {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            padding: 4px;
            min-width: 60px;
            min-height: 60px;
            max-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
        }

        .preview-canvas-wrapper canvas {
            display: block;
            flex-shrink: 0;
        }

        .preview-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .form-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .form-actions .btn {
            flex: 1;
        }

        /* Sprite Directory */
        .sprite-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .sprite-list::-webkit-scrollbar {
            width: 6px;
        }

        .sprite-list::-webkit-scrollbar-track {
            background: var(--bg-mid);
        }

        .sprite-list::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 3px;
        }

        .sprite-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .sprite-item:hover {
            background: var(--bg-surface);
            border-color: var(--stone-dark);
        }

        .sprite-item.selected {
            background: var(--mystic-deep);
            border-color: var(--mystic-glow);
        }

        .sprite-item.highlighted {
            animation: pulse-highlight 1s ease-out;
        }

        @keyframes pulse-highlight {
            0% { box-shadow: 0 0 0 0 var(--accent-ember); }
            50% { box-shadow: 0 0 10px 2px var(--accent-ember); }
            100% { box-shadow: 0 0 0 0 transparent; }
        }

        .sprite-thumb {
            width: 32px;
            height: 32px;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 8px 8px;
            border: 1px solid var(--stone-dark);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .sprite-thumb canvas {
            image-rendering: pixelated;
        }

        .sprite-info {
            flex: 1;
            min-width: 0;
        }

        .sprite-name {
            font-size: 11px;
            color: var(--stone-bright);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sprite-coords {
            font-size: 10px;
            color: var(--stone-mid);
        }

        .sprite-delete {
            opacity: 0;
            padding: 4px 6px;
            font-size: 10px;
            background: transparent;
            border: none;
            color: var(--accent-magma);
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .sprite-item:hover .sprite-delete {
            opacity: 1;
        }

        .sprite-delete:hover {
            color: var(--stone-bright);
        }

        .empty-state {
            text-align: center;
            padding: 20px;
            color: var(--stone-mid);
            font-size: 11px;
        }

        /* Export Section */
        .export-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .export-actions {
            display: flex;
            gap: 8px;
            padding: 12px;
        }

        .export-actions .btn {
            flex: 1;
            font-size: 11px;
            padding: 6px 10px;
        }

        .export-hint {
            padding: 8px 12px;
            font-size: 10px;
            color: var(--stone-mid);
            background: var(--bg-deep);
            border-bottom: 1px solid var(--stone-dark);
        }

        .export-hint code {
            color: var(--accent-ember);
            background: var(--bg-surface);
            padding: 2px 4px;
            border-radius: 2px;
        }

        .json-preview {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .json-preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-surface);
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            cursor: pointer;
        }

        .json-preview-header:hover {
            background: var(--stone-dark);
        }

        .json-preview-toggle {
            font-size: 8px;
        }

        .json-preview-content {
            flex: 1;
            overflow: auto;
            padding: 8px 12px;
            background: var(--bg-deep);
            font-size: 10px;
            line-height: 1.5;
            white-space: pre;
        }

        .json-preview-content::-webkit-scrollbar {
            width: 6px;
        }

        .json-preview-content::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 3px;
        }

        .json-preview.collapsed .json-preview-content {
            display: none;
        }

        /* Hidden file input */
        .hidden-input {
            display: none;
        }

        /* Project/Spritesheet Selectors */
        .selector-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .selector-label {
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
        }

        .upload-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            padding: 8px 12px;
        }

        .upload-btn::before {
            content: '+';
            font-size: 14px;
            font-weight: bold;
        }

        /* Auth indicator */
        .auth-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--stone-mid);
            padding: 4px 8px;
            background: var(--bg-deep);
            border-radius: 4px;
        }

        .auth-indicator.logged-in {
            color: var(--accent-ember);
        }

        .auth-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--stone-mid);
        }

        .auth-indicator.logged-in .auth-dot {
            background: var(--accent-ember);
        }

        /* Cloud save indicator */
        .save-indicator {
            font-size: 10px;
            color: var(--stone-mid);
            padding: 4px 8px;
        }

        .save-indicator.saving {
            color: var(--accent-ember);
        }

        .save-indicator.saved {
            color: #4ade80;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 20px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 12px;
            color: var(--stone-bright);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: var(--accent-ember);
        }

        .toast.error {
            border-color: var(--accent-magma);
            color: var(--accent-magma);
        }

        /* Confirm dialog */
        .dialog-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(13, 13, 20, 0.9);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .dialog-overlay.show {
            display: flex;
        }

        .dialog {
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            padding: 20px;
            max-width: 400px;
            text-align: center;
        }

        .dialog-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-bright);
            margin-bottom: 12px;
        }

        .dialog-message {
            font-size: 12px;
            color: var(--stone-light);
            margin-bottom: 20px;
        }

        .dialog-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        /* Sprite Direction Notice */
        .sprite-direction-dialog {
            max-width: 480px;
            text-align: left;
        }

        .sprite-direction-content {
            margin-bottom: 20px;
        }

        .direction-intro {
            font-size: 13px;
            color: var(--stone-light);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .direction-intro strong {
            color: var(--accent-ember);
        }

        .direction-visual {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 24px 0;
        }

        .direction-example {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px 24px;
            border-radius: 8px;
            background: var(--bg-surface);
        }

        .direction-example.correct {
            border: 2px solid #4ade80;
        }

        .direction-example.incorrect {
            border: 2px solid var(--accent-magma);
        }

        .direction-sprite {
            font-size: 48px;
            line-height: 1;
        }

        .direction-sprite.flipped {
            transform: scaleX(-1);
        }

        .direction-label {
            font-size: 11px;
            color: var(--stone-mid);
            text-transform: uppercase;
        }

        .direction-status {
            font-size: 20px;
        }

        .direction-example.correct .direction-status {
            color: #4ade80;
        }

        .direction-example.incorrect .direction-status {
            color: var(--accent-magma);
        }

        .direction-tip {
            font-size: 12px;
            color: var(--stone-mid);
            text-align: center;
            margin-top: 16px;
        }

        .direction-tip strong {
            color: var(--accent-ember);
        }

        .sprite-direction-dialog .dialog-actions {
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
        }

        .dont-show-again {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 11px;
            color: var(--stone-mid);
            cursor: pointer;
        }

        .dont-show-again input {
            cursor: pointer;
        }

        /* Master Sheet Section */
        .master-sheet-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .master-sheet-preview {
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .master-sheet-preview canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .master-sheet-empty {
            text-align: center;
            font-size: 11px;
            color: var(--stone-mid);
            padding: 20px;
        }

        .master-sheet-actions {
            display: flex;
            gap: 8px;
        }

        .master-sheet-actions .btn {
            flex: 1;
            font-size: 11px;
        }

        /* Saved sprite indicator in list */
        .sprite-item.saved-to-master .sprite-name::after {
            content: ' ✓';
            color: #4ade80;
            font-size: 10px;
        }

        /* AI Generate Dropdown */
        .dropdown-container {
            position: relative;
            display: inline-block;
        }

        .dropdown-btn {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dropdown-btn::after {
            content: '▼';
            font-size: 8px;
            opacity: 0.7;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            min-width: 180px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }

        .dropdown-menu.open {
            display: block;
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            font-size: 12px;
            color: var(--stone-light);
            cursor: pointer;
            transition: background 0.15s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-family: inherit;
        }

        .dropdown-item:hover {
            background: var(--stone-dark);
            color: var(--accent-ember);
        }

        .dropdown-item:first-child {
            border-radius: 4px 4px 0 0;
        }

        .dropdown-item:last-child {
            border-radius: 0 0 4px 4px;
        }

        .dropdown-divider {
            height: 1px;
            background: var(--stone-dark);
            margin: 4px 0;
        }

        /* AI Generation Modal */
        .ai-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(13, 13, 20, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .ai-modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .ai-modal {
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .ai-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: var(--bg-surface);
            border-bottom: 1px solid var(--stone-dark);
        }

        .ai-modal-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--accent-ember);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-modal-close {
            background: none;
            border: none;
            font-size: 20px;
            color: var(--stone-mid);
            cursor: pointer;
            padding: 4px;
        }

        .ai-modal-close:hover {
            color: var(--accent-ember);
        }

        .ai-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .ai-modal-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .ai-form-section {
            background: var(--bg-surface);
            border-radius: 6px;
            padding: 16px;
        }

        .ai-form-section h3 {
            font-size: 11px;
            font-weight: 600;
            color: var(--stone-bright);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ai-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .ai-form-group {
            margin-bottom: 12px;
        }

        .ai-form-group:last-child {
            margin-bottom: 0;
        }

        .ai-form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .ai-form-input,
        .ai-form-select,
        .ai-form-textarea {
            width: 100%;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .ai-form-textarea {
            resize: vertical;
            min-height: 80px;
        }

        .ai-form-input:focus,
        .ai-form-select:focus,
        .ai-form-textarea:focus {
            outline: none;
            border-color: var(--accent-ember);
            box-shadow: 0 0 0 2px rgba(224, 112, 32, 0.2);
        }

        .ai-skeleton-container {
            background: var(--bg-deep);
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
        }

        .ai-skeleton-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .ai-skeleton-preset {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            padding: 4px 10px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-light);
            cursor: pointer;
        }

        .ai-skeleton-preset:hover {
            border-color: var(--mystic-glow);
            color: var(--mystic-glow);
        }

        .ai-skeleton-preset.active {
            background: var(--mystic-glow);
            border-color: var(--mystic-glow);
            color: var(--bg-deep);
        }

        .ai-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 16px 20px;
            background: var(--bg-surface);
            border-top: 1px solid var(--stone-dark);
        }

        .ai-modal-footer .btn {
            min-width: 120px;
        }

        /* Generation Queue Panel */
        .generation-queue-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 1500;
            display: none;
        }

        .generation-queue-panel.visible {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="brand">
            <a href="/game-wizard/" class="home-btn" title="Back to Game Wizard">&#128302;</a>
            <span class="brand-icon">&#128293;</span>
            <span class="brand-text">GAME WIZARD / <span>SPRITE-RITE</span></span>
        </div>
        <div class="header-actions">
            <div class="selector-group">
                <span class="selector-label">Project</span>
                <select class="sprite-select" id="projectSelect">
                    <option value="">-- Select Project --</option>
                </select>
            </div>
            <div class="selector-group">
                <span class="selector-label">Sheet</span>
                <select class="sprite-select" id="spriteSheetSelect" disabled>
                    <option value="">-- Select Sheet --</option>
                </select>
            </div>
            <input type="file" id="uploadInput" class="hidden-input" accept="image/*">
            <button class="btn upload-btn" id="uploadBtn" disabled>Upload Sheet</button>
            <button class="btn btn-danger" id="deleteSheetBtn" disabled title="Delete the currently selected spritesheet">Delete Sheet</button>
            <input type="file" id="importInput" class="hidden-input" accept=".json">
            <button class="btn" id="importJsonBtn">Import JSON</button>
            <div class="dropdown-container">
                <button class="btn btn-primary dropdown-btn" id="generateDropdownBtn">Generate</button>
                <div class="dropdown-menu" id="generateDropdownMenu">
                    <button class="dropdown-item" id="generateCharacterBtn">
                        <span>&#129493;</span> Character
                    </button>
                    <button class="dropdown-item" id="generateMapObjectBtn">
                        <span>&#127795;</span> Map Object
                    </button>
                    <div class="dropdown-divider"></div>
                    <button class="dropdown-item" id="viewQueueBtn">
                        <span>&#128203;</span> View Queue
                    </button>
                </div>
            </div>
            <span class="save-indicator" id="saveIndicator"></span>
            <div class="auth-indicator" id="authIndicator">
                <span class="auth-dot"></span>
                <span>Guest</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Canvas Area -->
        <div class="canvas-area">
            <div class="canvas-toolbar">
                <div class="toolbar-group">
                    <span class="toolbar-label">Zoom</span>
                    <div class="zoom-buttons">
                        <button class="zoom-btn" data-zoom="1">1x</button>
                        <button class="zoom-btn" data-zoom="2">2x</button>
                        <button class="zoom-btn active" data-zoom="4">4x</button>
                        <button class="zoom-btn" data-zoom="8">8x</button>
                        <button class="zoom-btn" data-zoom="16">16x</button>
                    </div>
                </div>

                <div class="toolbar-group">
                    <button class="toggle-btn active" id="gridToggle">
                        <span>Grid</span>
                    </button>
                </div>

                <div class="toolbar-group">
                    <button class="tool-btn" id="removeBgBtn" title="Click to pick background color, then remove">
                        <span>Remove BG</span>
                    </button>
                    <button class="tool-btn" id="flipHorizontalBtn" title="Flip the entire spritesheet horizontally (mirror)">
                        <span>Flip H</span>
                    </button>
                    <button class="tool-btn" id="autoDetectBtn" title="Click on a sprite to auto-select its bounds">
                        <span>Auto-Detect</span>
                    </button>
                </div>

                <div class="toolbar-group">
                    <span class="selection-info" id="selectionInfo">
                        Selection: <span class="coord">none</span>
                    </span>
                </div>

                <span class="image-info" id="imageInfo">No image loaded</span>
            </div>

            <div class="canvas-wrapper" id="canvasWrapper">
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-icon">&#128444;</div>
                    <div class="drop-zone-text">Select a sprite sheet from the dropdown</div>
                    <div class="drop-zone-hint">Sprite sheets are loaded from /assets/sprites/</div>
                </div>

                <div class="canvas-container" id="canvasContainer" style="display: none;">
                    <canvas id="mainCanvas"></canvas>
                    <canvas id="gridCanvas"></canvas>
                    <canvas id="selectionCanvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Create Sprite Panel -->
            <div class="sidebar-section create-sprite-panel" id="createPanel">
                <div class="sidebar-header">
                    Create Sprite
                </div>
                <div class="sidebar-content">
                    <div class="form-group">
                        <label class="form-label">Sprite Name *</label>
                        <input type="text" class="form-input" id="spriteName" placeholder="hero_idle_01">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Description</label>
                        <input type="text" class="form-input" id="spriteDesc" placeholder="Optional description">
                    </div>

                    <div class="preview-container">
                        <div class="preview-box">
                            <span class="preview-label">1x</span>
                            <div class="preview-canvas-wrapper">
                                <canvas class="preview-canvas" id="preview1x"></canvas>
                            </div>
                        </div>
                        <div class="preview-box">
                            <span class="preview-label">4x</span>
                            <div class="preview-canvas-wrapper">
                                <canvas class="preview-canvas" id="preview4x"></canvas>
                            </div>
                        </div>
                    </div>

                    <div class="form-actions">
                        <button class="btn btn-primary" id="saveSprite">Save Sprite</button>
                        <button class="btn" id="cancelSprite">Cancel</button>
                    </div>
                </div>
            </div>

            <!-- Saved Sprites from this sheet -->
            <div class="sidebar-section">
                <div class="sidebar-header">
                    Saved Sprites
                    <span id="spriteCount">0</span>
                </div>
                <div class="sprite-list" id="spriteList">
                    <div class="empty-state">No sprites saved yet.<br>Select an area to save one.</div>
                </div>
            </div>

            <!-- Master Sheet Section -->
            <div class="sidebar-section master-sheet-section">
                <div class="sidebar-header">
                    Master Sheet
                    <span id="masterSheetCount">0</span>
                </div>
                <div class="sidebar-content">
                    <div class="master-sheet-preview">
                        <canvas id="masterSheetPreviewCanvas" class="preview-canvas" style="display: none;"></canvas>
                        <div class="master-sheet-empty" id="masterSheetEmpty">
                            No sprites on master sheet yet.<br>Save sprites to add them.
                        </div>
                    </div>
                    <div class="master-sheet-actions">
                        <button class="btn" id="copyMasterJson">Copy Atlas JSON</button>
                    </div>
                </div>
            </div>
        </aside>
    </main>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <!-- Confirm dialog -->
    <div class="dialog-overlay" id="confirmDialog">
        <div class="dialog">
            <div class="dialog-title" id="dialogTitle">Confirm</div>
            <div class="dialog-message" id="dialogMessage">Are you sure?</div>
            <div class="dialog-actions">
                <button class="btn btn-danger" id="dialogConfirm">Remove</button>
                <button class="btn" id="dialogCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Sprite Direction Educational Notice -->
    <div class="dialog-overlay" id="spriteDirectionNotice">
        <div class="dialog sprite-direction-dialog">
            <div class="dialog-title">Sprite Direction Convention</div>
            <div class="sprite-direction-content">
                <p class="direction-intro">
                    For consistent animations, <strong>all sprites should face right</strong>.
                    Games flip sprites horizontally at runtime to show left-facing movement.
                </p>
                <div class="direction-visual">
                    <div class="direction-example correct">
                        <div class="direction-sprite">&#129374;</div>
                        <div class="direction-label">Facing Right</div>
                        <div class="direction-status">&#10004;</div>
                    </div>
                    <div class="direction-example incorrect">
                        <div class="direction-sprite flipped">&#129374;</div>
                        <div class="direction-label">Facing Left</div>
                        <div class="direction-status">&#10008;</div>
                    </div>
                </div>
                <p class="direction-tip">
                    If your sprites face left, use the <strong>Flip H</strong> tool to mirror them.
                </p>
            </div>
            <div class="dialog-actions">
                <label class="dont-show-again">
                    <input type="checkbox" id="dontShowAgain"> Don't show this again
                </label>
                <button class="btn btn-primary" id="dismissNotice">Got it!</button>
            </div>
        </div>
    </div>

    <!-- AI Character Generation Modal -->
    <div class="ai-modal-overlay" id="characterModal">
        <div class="ai-modal">
            <div class="ai-modal-header">
                <div class="ai-modal-title">
                    <span>&#129493;</span> Generate Character
                </div>
                <button class="ai-modal-close" id="closeCharacterModal">&times;</button>
            </div>
            <div class="ai-modal-body">
                <div class="ai-modal-grid">
                    <!-- Left Column - Description & Settings -->
                    <div class="ai-form-column">
                        <div class="ai-form-section">
                            <h3>Description</h3>
                            <div class="ai-form-group">
                                <label class="ai-form-label">Character Description *</label>
                                <textarea class="ai-form-textarea" id="aiCharacterDesc" placeholder="A brave knight in silver armor with a red cape, holding a sword and shield"></textarea>
                            </div>
                            <div class="ai-form-group">
                                <label class="ai-form-label">Negative Prompt</label>
                                <input type="text" class="ai-form-input" id="aiNegativePrompt" placeholder="blurry, distorted, extra limbs">
                            </div>
                        </div>

                        <div class="ai-form-section">
                            <h3>Settings</h3>
                            <div class="ai-form-row">
                                <div class="ai-form-group">
                                    <label class="ai-form-label">Directions</label>
                                    <select class="ai-form-select" id="aiDirections">
                                        <option value="1">1 (Front only)</option>
                                        <option value="4">4 (Cardinal)</option>
                                        <option value="8" selected>8 (All directions)</option>
                                    </select>
                                </div>
                                <div class="ai-form-group">
                                    <label class="ai-form-label">Size</label>
                                    <select class="ai-form-select" id="aiSize">
                                        <option value="32">32x32</option>
                                        <option value="48" selected>48x48</option>
                                        <option value="64">64x64</option>
                                        <option value="96">96x96</option>
                                    </select>
                                </div>
                            </div>
                            <div class="ai-form-row">
                                <div class="ai-form-group">
                                    <label class="ai-form-label">Outline</label>
                                    <select class="ai-form-select" id="aiOutline">
                                        <option value="single_color_black_outline">Black Outline</option>
                                        <option value="single_color_outline">Single Color</option>
                                        <option value="colored_outline">Colored Outline</option>
                                        <option value="no_outline">No Outline</option>
                                    </select>
                                </div>
                                <div class="ai-form-group">
                                    <label class="ai-form-label">Shading</label>
                                    <select class="ai-form-select" id="aiShading">
                                        <option value="flat_shading">Flat</option>
                                        <option value="basic_shading" selected>Basic</option>
                                        <option value="detailed_shading">Detailed</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column - Skeleton Editor -->
                    <div class="ai-form-column">
                        <div class="ai-form-section">
                            <h3>Pose (Optional)</h3>
                            <p style="font-size: 11px; color: var(--stone-mid); margin-bottom: 12px;">
                                Drag joints to set the character's pose. Leave default for a standard idle pose.
                            </p>
                            <div class="ai-skeleton-container">
                                <div class="ai-skeleton-controls">
                                    <button class="ai-skeleton-preset active" data-pose="idle">Idle</button>
                                    <button class="ai-skeleton-preset" data-pose="walk1">Walk 1</button>
                                    <button class="ai-skeleton-preset" data-pose="walk2">Walk 2</button>
                                    <button class="ai-skeleton-preset" data-pose="attack">Attack</button>
                                    <button class="ai-skeleton-preset" data-pose="jump">Jump</button>
                                </div>
                                <div id="skeletonEditorContainer"></div>
                                <div class="ai-form-group" style="margin-top: 12px;">
                                    <label class="ai-form-label">Skeleton Guidance</label>
                                    <input type="range" class="ai-form-input" id="aiSkeletonGuidance" min="0" max="5" step="0.1" value="2">
                                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--stone-mid);">
                                        <span>None (0)</span>
                                        <span id="guidanceValue">2.0</span>
                                        <span>Strong (5)</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="ai-modal-footer">
                <button class="btn" id="cancelCharacterGen">Cancel</button>
                <button class="btn btn-primary" id="submitCharacterGen">Queue Generation</button>
            </div>
        </div>
    </div>

    <!-- AI Map Object Generation Modal -->
    <div class="ai-modal-overlay" id="mapObjectModal">
        <div class="ai-modal" style="max-width: 500px;">
            <div class="ai-modal-header">
                <div class="ai-modal-title">
                    <span>&#127795;</span> Generate Map Object
                </div>
                <button class="ai-modal-close" id="closeMapObjectModal">&times;</button>
            </div>
            <div class="ai-modal-body">
                <div class="ai-form-section">
                    <h3>Description</h3>
                    <div class="ai-form-group">
                        <label class="ai-form-label">Object Description *</label>
                        <textarea class="ai-form-textarea" id="aiMapObjectDesc" placeholder="A wooden treasure chest with gold trim and a large lock"></textarea>
                    </div>
                    <div class="ai-form-group">
                        <label class="ai-form-label">Negative Prompt</label>
                        <input type="text" class="ai-form-input" id="aiMapObjectNegative" placeholder="blurry, distorted">
                    </div>
                </div>

                <div class="ai-form-section">
                    <h3>Settings</h3>
                    <div class="ai-form-row">
                        <div class="ai-form-group">
                            <label class="ai-form-label">Width</label>
                            <select class="ai-form-select" id="aiMapObjectWidth">
                                <option value="16">16px</option>
                                <option value="32" selected>32px</option>
                                <option value="48">48px</option>
                                <option value="64">64px</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label class="ai-form-label">Height</label>
                            <select class="ai-form-select" id="aiMapObjectHeight">
                                <option value="16">16px</option>
                                <option value="32" selected>32px</option>
                                <option value="48">48px</option>
                                <option value="64">64px</option>
                            </select>
                        </div>
                    </div>
                    <div class="ai-form-row">
                        <div class="ai-form-group">
                            <label class="ai-form-label">Outline</label>
                            <select class="ai-form-select" id="aiMapObjectOutline">
                                <option value="single_color_black_outline">Black Outline</option>
                                <option value="single_color_outline">Single Color</option>
                                <option value="colored_outline">Colored Outline</option>
                                <option value="no_outline">No Outline</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label class="ai-form-label">View</label>
                            <select class="ai-form-select" id="aiMapObjectView">
                                <option value="high_top_down">High Top-Down</option>
                                <option value="low_top_down" selected>Low Top-Down</option>
                                <option value="side">Side View</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="ai-modal-footer">
                <button class="btn" id="cancelMapObjectGen">Cancel</button>
                <button class="btn btn-primary" id="submitMapObjectGen">Queue Generation</button>
            </div>
        </div>
    </div>

    <!-- Generation Queue Panel -->
    <div class="generation-queue-panel" id="generationQueuePanel"></div>

    <script src="../shared/supabase-client.js"></script>
    <script src="../shared/project-gate.js"></script>
    <script src="../shared/master-sheet.js"></script>
    <script src="../shared/pixellab-client.js"></script>
    <script src="../shared/skeleton-editor.js"></script>
    <script src="../shared/generation-queue.js"></script>
    <script>
        /* ============================================
           MANTLEBORN SPRITE-RITE - JavaScript
           ============================================ */

        // ==========================================
        // State Management
        // ==========================================
        const state = {
            // Auth & Cloud
            user: null,
            projectId: null,
            projectName: null,
            spritesheetId: null,
            spritesheetRecord: null,

            // Image
            image: null,
            imageName: '',
            imagePath: '',
            imageWidth: 0,
            imageHeight: 0,

            // Editor
            zoom: 4,
            showGrid: true,
            selection: null,
            sprites: [],
            selectedSpriteIndex: -1,
            editingSpriteIndex: -1,
            isDragging: false,
            dragStart: null,
            isResizing: false,
            resizeHandle: null,

            // Save state
            saveTimeout: null,
            hasUnsavedChanges: false,

            // Tool modes
            toolMode: null, // 'removeBg', 'autoDetect', or null
            imageData: null, // Cached pixel data for analysis
            islandMap: null, // Cached island labels for auto-detect

            // Master sheet
            masterSheetSprites: [], // Sprites already saved to master (from this spritesheet)
            masterSheetData: null,  // { png, atlas, spriteCount } for preview
            masterSheetImage: null, // Cached Image object for redrawing
            masterSheetScale: 1,    // Scale factor for preview canvas

            // AI Generation
            skeletonEditor: null,   // SkeletonEditor instance
            generationQueue: null   // GenerationQueue instance
        };

        // ==========================================
        // DOM Elements
        // ==========================================
        const elements = {
            // Project & Sprite sheet selection
            projectSelect: document.getElementById('projectSelect'),
            spriteSheetSelect: document.getElementById('spriteSheetSelect'),
            uploadInput: document.getElementById('uploadInput'),
            uploadBtn: document.getElementById('uploadBtn'),
            deleteSheetBtn: document.getElementById('deleteSheetBtn'),
            importInput: document.getElementById('importInput'),
            importJsonBtn: document.getElementById('importJsonBtn'),
            saveIndicator: document.getElementById('saveIndicator'),
            authIndicator: document.getElementById('authIndicator'),

            // Canvas elements
            canvasWrapper: document.getElementById('canvasWrapper'),
            canvasContainer: document.getElementById('canvasContainer'),
            mainCanvas: document.getElementById('mainCanvas'),
            gridCanvas: document.getElementById('gridCanvas'),
            selectionCanvas: document.getElementById('selectionCanvas'),
            dropZone: document.getElementById('dropZone'),

            // Toolbar
            zoomButtons: document.querySelectorAll('.zoom-btn'),
            gridToggle: document.getElementById('gridToggle'),
            removeBgBtn: document.getElementById('removeBgBtn'),
            flipHorizontalBtn: document.getElementById('flipHorizontalBtn'),
            autoDetectBtn: document.getElementById('autoDetectBtn'),
            selectionInfo: document.getElementById('selectionInfo'),
            imageInfo: document.getElementById('imageInfo'),

            // Create panel
            createPanel: document.getElementById('createPanel'),
            spriteName: document.getElementById('spriteName'),
            spriteDesc: document.getElementById('spriteDesc'),
            preview1x: document.getElementById('preview1x'),
            preview4x: document.getElementById('preview4x'),
            saveSprite: document.getElementById('saveSprite'),
            cancelSprite: document.getElementById('cancelSprite'),

            // Sprite list
            spriteList: document.getElementById('spriteList'),
            spriteCount: document.getElementById('spriteCount'),

            // Master Sheet
            masterSheetCount: document.getElementById('masterSheetCount'),
            masterSheetPreviewCanvas: document.getElementById('masterSheetPreviewCanvas'),
            masterSheetEmpty: document.getElementById('masterSheetEmpty'),
            copyMasterJson: document.getElementById('copyMasterJson'),

            // Toast & Dialog
            toast: document.getElementById('toast'),
            confirmDialog: document.getElementById('confirmDialog'),
            dialogTitle: document.getElementById('dialogTitle'),
            dialogMessage: document.getElementById('dialogMessage'),
            dialogConfirm: document.getElementById('dialogConfirm'),
            dialogCancel: document.getElementById('dialogCancel'),

            // Sprite Direction Notice
            spriteDirectionNotice: document.getElementById('spriteDirectionNotice'),
            dontShowAgain: document.getElementById('dontShowAgain'),
            dismissNotice: document.getElementById('dismissNotice'),

            // AI Generation
            generateDropdownBtn: document.getElementById('generateDropdownBtn'),
            generateDropdownMenu: document.getElementById('generateDropdownMenu'),
            generateCharacterBtn: document.getElementById('generateCharacterBtn'),
            generateMapObjectBtn: document.getElementById('generateMapObjectBtn'),
            viewQueueBtn: document.getElementById('viewQueueBtn'),

            // Character Modal
            characterModal: document.getElementById('characterModal'),
            closeCharacterModal: document.getElementById('closeCharacterModal'),
            aiCharacterDesc: document.getElementById('aiCharacterDesc'),
            aiNegativePrompt: document.getElementById('aiNegativePrompt'),
            aiDirections: document.getElementById('aiDirections'),
            aiSize: document.getElementById('aiSize'),
            aiOutline: document.getElementById('aiOutline'),
            aiShading: document.getElementById('aiShading'),
            skeletonEditorContainer: document.getElementById('skeletonEditorContainer'),
            aiSkeletonGuidance: document.getElementById('aiSkeletonGuidance'),
            guidanceValue: document.getElementById('guidanceValue'),
            cancelCharacterGen: document.getElementById('cancelCharacterGen'),
            submitCharacterGen: document.getElementById('submitCharacterGen'),

            // Map Object Modal
            mapObjectModal: document.getElementById('mapObjectModal'),
            closeMapObjectModal: document.getElementById('closeMapObjectModal'),
            aiMapObjectDesc: document.getElementById('aiMapObjectDesc'),
            aiMapObjectNegative: document.getElementById('aiMapObjectNegative'),
            aiMapObjectWidth: document.getElementById('aiMapObjectWidth'),
            aiMapObjectHeight: document.getElementById('aiMapObjectHeight'),
            aiMapObjectOutline: document.getElementById('aiMapObjectOutline'),
            aiMapObjectView: document.getElementById('aiMapObjectView'),
            cancelMapObjectGen: document.getElementById('cancelMapObjectGen'),
            submitMapObjectGen: document.getElementById('submitMapObjectGen'),

            // Generation Queue
            generationQueuePanel: document.getElementById('generationQueuePanel')
        };

        // ==========================================
        // Canvas Contexts
        // ==========================================
        const ctx = {
            main: elements.mainCanvas.getContext('2d'),
            grid: elements.gridCanvas.getContext('2d'),
            selection: elements.selectionCanvas.getContext('2d')
        };

        // Disable image smoothing for pixel-perfect rendering
        Object.values(ctx).forEach(c => {
            c.imageSmoothingEnabled = false;
        });

        // ==========================================
        // Utility Functions
        // ==========================================
        function showToast(message, type = 'success') {
            elements.toast.textContent = message;
            elements.toast.className = 'toast ' + type;
            setTimeout(() => elements.toast.classList.add('show'), 10);
            setTimeout(() => elements.toast.classList.remove('show'), 3000);
        }

        function screenToImage(screenX, screenY) {
            const rect = elements.selectionCanvas.getBoundingClientRect();
            const x = Math.floor((screenX - rect.left) / state.zoom);
            const y = Math.floor((screenY - rect.top) / state.zoom);
            return {
                x: Math.max(0, Math.min(x, state.imageWidth - 1)),
                y: Math.max(0, Math.min(y, state.imageHeight - 1))
            };
        }

        function validateSpriteName(name) {
            return /^[a-zA-Z][a-zA-Z0-9_]*$/.test(name);
        }

        function generateSpriteName() {
            if (!state.selection) return 'sprite_01';
            const { x, y, w, h } = state.selection;
            return `sprite_${x}_${y}_${w}x${h}`;
        }

        // ==========================================
        // Sprite Direction Notice
        // ==========================================
        function shouldShowSpriteDirectionNotice() {
            return localStorage.getItem('spriteRite_hideDirectionNotice') !== 'true';
        }

        function showSpriteDirectionNotice() {
            if (!shouldShowSpriteDirectionNotice()) return;
            elements.spriteDirectionNotice.classList.add('show');
        }

        function dismissSpriteDirectionNotice() {
            if (elements.dontShowAgain.checked) {
                localStorage.setItem('spriteRite_hideDirectionNotice', 'true');
            }
            elements.spriteDirectionNotice.classList.remove('show');
        }

        // ==========================================
        // Initialization & Auth
        // ==========================================
        async function init() {
            // Check if user has projects (displays gate if not)
            const hasProject = await checkProjectGate();
            if (!hasProject) return;

            await crucibleClient.init();

            // Check auth state
            state.user = await crucibleClient.getUser();
            updateAuthIndicator();

            // Listen for auth changes
            crucibleClient.onAuthStateChange((event, session) => {
                state.user = session?.user || null;
                updateAuthIndicator();
                if (state.user) {
                    loadProjects();
                }
            });

            // Load projects if logged in
            if (state.user) {
                await loadProjects();
            }

            // Check URL params for context
            const params = new URLSearchParams(window.location.search);
            const projectId = params.get('project');
            if (projectId && state.user) {
                elements.projectSelect.value = projectId;
                await selectProject(projectId);
            }

            // Initialize AI Generation components
            initAIGeneration();

            // Set initial button states
            updateToolButtonStates();
        }

        function updateAuthIndicator() {
            if (state.user) {
                const name = state.user.user_metadata?.display_name || state.user.email?.split('@')[0] || 'User';
                elements.authIndicator.innerHTML = `
                    <span class="auth-dot"></span>
                    <span>${name}</span>
                `;
                elements.authIndicator.classList.add('logged-in');
            } else {
                elements.authIndicator.innerHTML = `
                    <span class="auth-dot"></span>
                    <span>Guest</span>
                `;
                elements.authIndicator.classList.remove('logged-in');
            }
        }

        function updateSaveIndicator(status) {
            elements.saveIndicator.className = 'save-indicator ' + status;
            elements.saveIndicator.textContent = status === 'saving' ? 'Saving...' :
                                                  status === 'saved' ? 'Saved' : '';
        }

        // ==========================================
        // Project & Spritesheet Loading
        // ==========================================
        async function loadProjects() {
            if (!state.user) {
                elements.projectSelect.innerHTML = '<option value="">-- Login to access projects --</option>';
                elements.projectSelect.disabled = true;
                return;
            }

            try {
                const projects = await crucibleClient.getProjects();
                elements.projectSelect.innerHTML = '<option value="">-- Select Project --</option>';
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.id;
                    option.textContent = project.name;
                    elements.projectSelect.appendChild(option);
                });
                elements.projectSelect.disabled = false;
            } catch (error) {
                console.error('Failed to load projects:', error);
                showToast('Failed to load projects', 'error');
            }
        }

        async function selectProject(projectId) {
            state.projectId = projectId;
            state.spritesheetId = null;
            state.spritesheetRecord = null;

            // Clear current sheet
            clearCurrentSheet();

            if (!projectId) {
                elements.spriteSheetSelect.innerHTML = '<option value="">-- Select Sheet --</option>';
                elements.spriteSheetSelect.disabled = true;
                elements.uploadBtn.disabled = true;
                return;
            }

            // Enable upload
            elements.uploadBtn.disabled = false;

            // Load spritesheets for this project
            try {
                const sheets = await crucibleClient.getSpritesheets(projectId);
                elements.spriteSheetSelect.innerHTML = '<option value="">-- Select Sheet --</option>';
                sheets.forEach(sheet => {
                    const option = document.createElement('option');
                    option.value = sheet.id;
                    option.textContent = sheet.name;
                    option.dataset.url = sheet.publicUrl;
                    elements.spriteSheetSelect.appendChild(option);
                });
                elements.spriteSheetSelect.disabled = false;

                if (sheets.length === 0) {
                    showToast('No sprite sheets yet. Upload one!');
                }

                // Load master sheet preview
                updateMasterSheetPreview();
            } catch (error) {
                console.error('Failed to load spritesheets:', error);
                showToast('Failed to load sprite sheets', 'error');
            }
        }

        async function selectSpritesheet(spritesheetId) {
            if (!spritesheetId) {
                clearCurrentSheet();
                return;
            }

            try {
                const sheet = await crucibleClient.getSpritesheet(spritesheetId);
                state.spritesheetId = sheet.id;
                state.spritesheetRecord = sheet;

                // Load sprites already saved to master sheet from this spritesheet
                if (state.projectId) {
                    try {
                        state.masterSheetSprites = await crucibleClient.getMasterSheetSpritesFromSource(
                            state.projectId,
                            spritesheetId
                        );
                    } catch (e) {
                        console.warn('Could not load master sheet sprites:', e);
                        state.masterSheetSprites = [];
                    }
                } else {
                    state.masterSheetSprites = [];
                }

                // Load the image - use master sheet sprites instead of local sprites array
                loadSpriteSheetImage(sheet.name, sheet.publicUrl, state.masterSheetSprites);

                // Enable delete sheet button
                elements.deleteSheetBtn.disabled = false;
            } catch (error) {
                console.error('Failed to load spritesheet:', error);
                showToast('Failed to load sprite sheet', 'error');
            }
        }

        function clearCurrentSheet() {
            state.image = null;
            state.imageName = '';
            state.imagePath = '';
            state.spritesheetId = null;
            state.sprites = [];
            state.selection = null;
            state.selectedSpriteIndex = -1;
            state.editingSpriteIndex = -1;
            state.imageData = null;
            state.islandMap = null;
            state.toolMode = null;
            state.masterSheetSprites = [];
            hideCreatePanel();

            elements.dropZone.style.display = 'flex';
            elements.canvasContainer.style.display = 'none';
            elements.imageInfo.textContent = 'No image loaded';
            elements.deleteSheetBtn.disabled = true;
            updateSpriteList();
            updateJsonPreview();
        }

        // ==========================================
        // Image Loading
        // ==========================================
        function loadSpriteSheetImage(name, url, sprites = []) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                state.image = img;
                state.imageName = name;
                state.imagePath = url;
                state.imageWidth = img.width;
                state.imageHeight = img.height;
                state.imageData = null; // Clear cached pixel data
                state.islandMap = null; // Clear cached island map

                // Load sprites from record
                state.sprites = sprites.map(s => ({
                    name: s.name,
                    description: s.description || '',
                    x: s.x,
                    y: s.y,
                    width: s.width,
                    height: s.height
                }));

                state.selection = null;
                state.selectedSpriteIndex = -1;
                state.editingSpriteIndex = -1;
                hideCreatePanel();

                elements.dropZone.style.display = 'none';
                elements.canvasContainer.style.display = 'block';

                updateCanvasSize();
                render();

                elements.imageInfo.textContent = `${name} — ${img.width}×${img.height}px`;
                updateSpriteList();
                updateJsonPreview();

                if (sprites.length > 0) {
                    showToast(`Loaded ${sprites.length} sprites`);
                }
            };
            img.onerror = () => {
                showToast(`Failed to load ${name}`, 'error');
                elements.spriteSheetSelect.value = '';
            };
            img.src = url;
        }

        // ==========================================
        // Upload
        // ==========================================
        async function uploadSpriteSheet(file) {
            if (!state.projectId) {
                showToast('Please select a project first', 'error');
                return;
            }

            if (!state.user) {
                showToast('Please login to upload', 'error');
                return;
            }

            try {
                showToast('Uploading...');
                const sheet = await crucibleClient.uploadSpritesheet(state.projectId, file, {
                    name: file.name.replace(/\.[^/.]+$/, ''),
                    category: 'sprites'
                });

                // Add to dropdown and select
                const option = document.createElement('option');
                option.value = sheet.id;
                option.textContent = sheet.name;
                option.dataset.url = sheet.publicUrl;
                elements.spriteSheetSelect.appendChild(option);
                elements.spriteSheetSelect.value = sheet.id;

                // Load it
                await selectSpritesheet(sheet.id);
                showToast('Sprite sheet uploaded!');

                // Show educational notice about sprite direction
                showSpriteDirectionNotice();
            } catch (error) {
                console.error('Upload failed:', error);
                showToast('Upload failed: ' + error.message, 'error');
            }
        }

        // ==========================================
        // Auto-save to Cloud
        // ==========================================
        function scheduleAutoSave() {
            if (!state.user || !state.spritesheetId) {
                // Guest mode - save to localStorage only
                saveToLocalStorage();
                return;
            }

            state.hasUnsavedChanges = true;
            updateSaveIndicator('');

            // Debounce saves
            if (state.saveTimeout) {
                clearTimeout(state.saveTimeout);
            }

            state.saveTimeout = setTimeout(async () => {
                await saveToCloud();
            }, 1500);
        }

        async function saveToCloud() {
            if (!state.spritesheetId || !state.user) return;

            updateSaveIndicator('saving');

            try {
                await crucibleClient.updateSpritesheet(state.spritesheetId, {
                    sprites: state.sprites.map(s => ({
                        name: s.name,
                        description: s.description || '',
                        x: s.x,
                        y: s.y,
                        width: s.width,
                        height: s.height
                    }))
                });

                state.hasUnsavedChanges = false;
                updateSaveIndicator('saved');

                // Clear saved indicator after a moment
                setTimeout(() => {
                    if (!state.hasUnsavedChanges) {
                        updateSaveIndicator('');
                    }
                }, 2000);
            } catch (error) {
                console.error('Failed to save:', error);
                showToast('Failed to save to cloud', 'error');
                updateSaveIndicator('');
            }
        }

        // ==========================================
        // Canvas Rendering
        // ==========================================
        function updateCanvasSize() {
            const w = state.imageWidth * state.zoom;
            const h = state.imageHeight * state.zoom;

            [elements.mainCanvas, elements.gridCanvas, elements.selectionCanvas].forEach(canvas => {
                canvas.width = w;
                canvas.height = h;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
            });

            // Re-disable smoothing after resize
            Object.values(ctx).forEach(c => {
                c.imageSmoothingEnabled = false;
            });
        }

        function render() {
            renderMain();
            renderGrid();
            renderSelection();
        }

        function renderMain() {
            if (!state.image) return;

            ctx.main.clearRect(0, 0, elements.mainCanvas.width, elements.mainCanvas.height);
            ctx.main.drawImage(
                state.image,
                0, 0, state.imageWidth, state.imageHeight,
                0, 0, state.imageWidth * state.zoom, state.imageHeight * state.zoom
            );
        }

        function renderGrid() {
            ctx.grid.clearRect(0, 0, elements.gridCanvas.width, elements.gridCanvas.height);

            if (!state.showGrid || state.zoom < 2) return;

            ctx.grid.strokeStyle = 'rgba(106, 106, 142, 0.25)';
            ctx.grid.lineWidth = 1;

            // Vertical lines
            for (let x = 0; x <= state.imageWidth; x++) {
                ctx.grid.beginPath();
                ctx.grid.moveTo(x * state.zoom + 0.5, 0);
                ctx.grid.lineTo(x * state.zoom + 0.5, elements.gridCanvas.height);
                ctx.grid.stroke();
            }

            // Horizontal lines
            for (let y = 0; y <= state.imageHeight; y++) {
                ctx.grid.beginPath();
                ctx.grid.moveTo(0, y * state.zoom + 0.5);
                ctx.grid.lineTo(elements.gridCanvas.width, y * state.zoom + 0.5);
                ctx.grid.stroke();
            }
        }

        function renderSelection() {
            ctx.selection.clearRect(0, 0, elements.selectionCanvas.width, elements.selectionCanvas.height);

            // Draw saved sprites as solid green outlines (saved to master sheet)
            state.sprites.forEach((sprite, index) => {
                const isSelected = index === state.selectedSpriteIndex;
                // Saved sprites: solid green outline
                ctx.selection.strokeStyle = isSelected ? '#e07020' : '#4ade80';
                ctx.selection.lineWidth = isSelected ? 2 : 2;
                ctx.selection.strokeRect(
                    sprite.x * state.zoom + 0.5,
                    sprite.y * state.zoom + 0.5,
                    sprite.width * state.zoom - 1,
                    sprite.height * state.zoom - 1
                );

                // Add a small "saved" indicator
                if (!isSelected) {
                    ctx.selection.fillStyle = '#4ade80';
                    ctx.selection.font = '10px sans-serif';
                    ctx.selection.fillText('✓', sprite.x * state.zoom + 4, sprite.y * state.zoom + 12);
                }
            });

            // Draw current selection
            if (state.selection) {
                const { x, y, w, h } = state.selection;

                // Fill
                ctx.selection.fillStyle = 'rgba(128, 96, 192, 0.3)';
                ctx.selection.fillRect(
                    x * state.zoom,
                    y * state.zoom,
                    w * state.zoom,
                    h * state.zoom
                );

                // Border (dashed)
                ctx.selection.strokeStyle = '#8060c0';
                ctx.selection.lineWidth = 2;
                ctx.selection.setLineDash([4, 4]);
                ctx.selection.strokeRect(
                    x * state.zoom + 0.5,
                    y * state.zoom + 0.5,
                    w * state.zoom - 1,
                    h * state.zoom - 1
                );
                ctx.selection.setLineDash([]);

                // Resize handles
                const handleSize = 8;
                ctx.selection.fillStyle = '#8060c0';

                // Corner handles
                const corners = [
                    { x: x * state.zoom - handleSize/2, y: y * state.zoom - handleSize/2 },
                    { x: (x + w) * state.zoom - handleSize/2, y: y * state.zoom - handleSize/2 },
                    { x: x * state.zoom - handleSize/2, y: (y + h) * state.zoom - handleSize/2 },
                    { x: (x + w) * state.zoom - handleSize/2, y: (y + h) * state.zoom - handleSize/2 }
                ];

                corners.forEach(corner => {
                    ctx.selection.fillRect(corner.x, corner.y, handleSize, handleSize);
                });
            }
        }

        // ==========================================
        // Tool Functions (Background Removal & Auto-Detect)
        // ==========================================

        function getPixelData() {
            if (!state.image) return null;
            if (state.imageData) return state.imageData;

            // Draw image to temp canvas to get pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = state.imageWidth;
            tempCanvas.height = state.imageHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(state.image, 0, 0);
            state.imageData = tempCtx.getImageData(0, 0, state.imageWidth, state.imageHeight);
            return state.imageData;
        }

        function getPixelColor(imageData, x, y) {
            const idx = (y * imageData.width + x) * 4;
            return {
                r: imageData.data[idx],
                g: imageData.data[idx + 1],
                b: imageData.data[idx + 2],
                a: imageData.data[idx + 3]
            };
        }

        function colorsMatch(c1, c2, tolerance = 0) {
            return Math.abs(c1.r - c2.r) <= tolerance &&
                   Math.abs(c1.g - c2.g) <= tolerance &&
                   Math.abs(c1.b - c2.b) <= tolerance &&
                   Math.abs(c1.a - c2.a) <= tolerance;
        }

        function removeBackground() {
            const imageData = getPixelData();
            if (!imageData) return;

            // Detect background color from corners
            const corners = [
                getPixelColor(imageData, 0, 0),
                getPixelColor(imageData, state.imageWidth - 1, 0),
                getPixelColor(imageData, 0, state.imageHeight - 1),
                getPixelColor(imageData, state.imageWidth - 1, state.imageHeight - 1)
            ];

            // Find most common corner color (likely background)
            let targetColor = corners[0];
            let maxMatches = 0;
            for (const c of corners) {
                const matches = corners.filter(other => colorsMatch(c, other, 10)).length;
                if (matches > maxMatches) {
                    maxMatches = matches;
                    targetColor = c;
                }
            }

            // Don't remove if already transparent
            if (targetColor.a === 0) {
                showToast('Background already transparent.', 'error');
                return;
            }

            // Count pixels to remove
            let removeCount = 0;
            const newData = new Uint8ClampedArray(imageData.data);

            for (let y = 0; y < state.imageHeight; y++) {
                for (let x = 0; x < state.imageWidth; x++) {
                    const idx = (y * state.imageWidth + x) * 4;
                    const pixelColor = {
                        r: newData[idx],
                        g: newData[idx + 1],
                        b: newData[idx + 2],
                        a: newData[idx + 3]
                    };

                    if (colorsMatch(pixelColor, targetColor, 10)) {
                        newData[idx + 3] = 0; // Make transparent
                        removeCount++;
                    }
                }
            }

            if (removeCount === 0) {
                showToast('No background pixels found.', 'error');
                return;
            }

            // Update the image
            const newImageData = new ImageData(newData, state.imageWidth, state.imageHeight);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = state.imageWidth;
            tempCanvas.height = state.imageHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(newImageData, 0, 0);

            // Create new image from canvas
            const newImg = new Image();
            newImg.onload = async () => {
                state.image = newImg;
                state.imageData = null; // Clear cache
                state.islandMap = null; // Clear island cache
                render();

                // Save modified image to cloud if logged in
                if (state.spritesheetId && state.user) {
                    try {
                        showToast('Saving modified image...');
                        const blob = await new Promise(resolve => tempCanvas.toBlob(resolve, 'image/png'));
                        await crucibleClient.updateSpritesheetImage(state.spritesheetId, blob);
                        showToast(`Removed ${removeCount} pixels and saved.`);
                    } catch (error) {
                        console.error('Failed to save image:', error);
                        showToast(`Removed ${removeCount} pixels (save failed)`, 'error');
                    }
                } else {
                    showToast(`Removed ${removeCount} pixels.`);
                }
            };
            newImg.src = tempCanvas.toDataURL('image/png');
        }

        function flipHorizontal() {
            if (!state.image || !state.selection) {
                showToast('Select a sprite area first', 'error');
                return;
            }

            const { x, y, w, h } = state.selection;

            // Create a canvas with just the selected region
            const regionCanvas = document.createElement('canvas');
            regionCanvas.width = w;
            regionCanvas.height = h;
            const regionCtx = regionCanvas.getContext('2d');
            regionCtx.imageSmoothingEnabled = false;

            // Draw the selected region
            regionCtx.drawImage(state.image, x, y, w, h, 0, 0, w, h);

            // Create flipped canvas
            const flippedCanvas = document.createElement('canvas');
            flippedCanvas.width = w;
            flippedCanvas.height = h;
            const flippedCtx = flippedCanvas.getContext('2d');
            flippedCtx.imageSmoothingEnabled = false;

            // Flip horizontally
            flippedCtx.translate(w, 0);
            flippedCtx.scale(-1, 1);
            flippedCtx.drawImage(regionCanvas, 0, 0);

            // Draw the flipped region back onto the main image
            const mainCanvas = document.createElement('canvas');
            mainCanvas.width = state.imageWidth;
            mainCanvas.height = state.imageHeight;
            const mainCtx = mainCanvas.getContext('2d');
            mainCtx.imageSmoothingEnabled = false;

            // Draw original image
            mainCtx.drawImage(state.image, 0, 0);

            // Clear the selection area first (remove original pixels)
            mainCtx.clearRect(x, y, w, h);

            // Draw flipped selection into the cleared area
            mainCtx.drawImage(flippedCanvas, x, y);

            // Update the image
            const newImg = new Image();
            newImg.onload = async () => {
                state.image = newImg;
                state.imageData = null; // Clear cache
                state.islandMap = null; // Clear island cache

                render();
                updatePreviews();

                // Save modified image to cloud if logged in
                if (state.spritesheetId && state.user) {
                    try {
                        const blob = await new Promise(resolve => mainCanvas.toBlob(resolve, 'image/png'));
                        await crucibleClient.updateSpritesheetImage(state.spritesheetId, blob);
                        showToast('Selection flipped!');
                    } catch (error) {
                        console.error('Failed to save image:', error);
                        showToast('Flipped (save failed)', 'error');
                    }
                } else {
                    showToast('Selection flipped.');
                }
            };
            newImg.src = mainCanvas.toDataURL('image/png');
        }

        function buildIslandMap() {
            if (state.islandMap) return state.islandMap;

            const imageData = getPixelData();
            if (!imageData) return null;

            const w = state.imageWidth;
            const h = state.imageHeight;
            const labels = new Int32Array(w * h); // 0 = not labeled yet
            let currentLabel = 0;

            // Get background color from top-left corner
            const bgColor = getPixelColor(imageData, 0, 0);

            // Check if pixel is foreground (not background)
            function isForeground(x, y) {
                if (x < 0 || x >= w || y < 0 || y >= h) return false;
                const color = getPixelColor(imageData, x, y);
                // Consider transparent or matching background as background
                if (color.a < 128) return false;
                return !colorsMatch(color, bgColor, 10);
            }

            // Flood fill to label connected components
            function floodFill(startX, startY, label) {
                const stack = [[startX, startY]];

                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    const idx = y * w + x;

                    if (x < 0 || x >= w || y < 0 || y >= h) continue;
                    if (labels[idx] !== 0) continue;
                    if (!isForeground(x, y)) continue;

                    labels[idx] = label;

                    // 4-connected neighbors
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }

            // Scan and label all islands
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const idx = y * w + x;
                    if (labels[idx] === 0 && isForeground(x, y)) {
                        currentLabel++;
                        floodFill(x, y, currentLabel);
                    }
                }
            }

            state.islandMap = { labels, w, h, count: currentLabel };
            return state.islandMap;
        }

        function getIslandBounds(clickX, clickY) {
            const map = buildIslandMap();
            if (!map) return null;

            const idx = clickY * map.w + clickX;
            const label = map.labels[idx];

            if (label === 0) {
                // Clicked on background, no island
                return null;
            }

            // Find bounds of this label
            let minX = map.w, maxX = 0, minY = map.h, maxY = 0;

            for (let y = 0; y < map.h; y++) {
                for (let x = 0; x < map.w; x++) {
                    if (map.labels[y * map.w + x] === label) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            return {
                x: minX,
                y: minY,
                w: maxX - minX + 1,
                h: maxY - minY + 1
            };
        }

        function updateToolButtonStates() {
            // Flip H only available when there's a selection
            const hasSelection = !!state.selection;
            elements.flipHorizontalBtn.disabled = !hasSelection;
            elements.flipHorizontalBtn.style.opacity = hasSelection ? '1' : '0.5';
        }

        function setToolMode(mode) {
            // Toggle off if clicking same mode
            if (state.toolMode === mode) {
                state.toolMode = null;
            } else {
                state.toolMode = mode;
            }

            // Update button states
            elements.autoDetectBtn.classList.toggle('active', state.toolMode === 'autoDetect');

            // Update cursor and info
            if (state.toolMode === 'autoDetect') {
                elements.selectionCanvas.style.cursor = 'pointer';
                elements.selectionInfo.innerHTML = 'Click on a sprite to auto-select';
            } else {
                elements.selectionCanvas.style.cursor = 'crosshair';
                updateSelectionInfo();
            }
        }

        function handleToolClick(imgX, imgY) {
            if (state.toolMode === 'autoDetect') {
                const bounds = getIslandBounds(imgX, imgY);
                if (bounds) {
                    state.selection = bounds;
                    state.selectedSpriteIndex = -1;
                    state.editingSpriteIndex = -1;
                    updateSelectionInfo();
                    updatePreviews();
                    renderSelection();
                    showCreatePanel();
                    // Auto-focus sprite name for immediate typing
                    setTimeout(() => elements.spriteName.focus(), 50);
                } else {
                    showToast('No sprite detected. Click on a non-transparent pixel.', 'error');
                }
                setToolMode(null); // Exit mode after use
                return true;
            }
            return false;
        }

        // ==========================================
        // Selection Handling
        // ==========================================
        function updateSelectionInfo() {
            if (state.selection) {
                const { x, y, w, h } = state.selection;
                elements.selectionInfo.innerHTML = `Selection: <span class="coord">x:${x} y:${y} w:${w} h:${h}</span>`;
            } else {
                elements.selectionInfo.innerHTML = `Selection: <span class="coord">none</span>`;
            }
        }

        function getResizeHandle(imgX, imgY) {
            if (!state.selection) return null;

            const { x, y, w, h } = state.selection;
            const threshold = 3 / state.zoom; // pixels tolerance

            const nearLeft = Math.abs(imgX - x) < threshold;
            const nearRight = Math.abs(imgX - (x + w)) < threshold;
            const nearTop = Math.abs(imgY - y) < threshold;
            const nearBottom = Math.abs(imgY - (y + h)) < threshold;

            const inXRange = imgX >= x - threshold && imgX <= x + w + threshold;
            const inYRange = imgY >= y - threshold && imgY <= y + h + threshold;

            if (nearTop && nearLeft) return 'nw';
            if (nearTop && nearRight) return 'ne';
            if (nearBottom && nearLeft) return 'sw';
            if (nearBottom && nearRight) return 'se';
            if (nearTop && inXRange) return 'n';
            if (nearBottom && inXRange) return 's';
            if (nearLeft && inYRange) return 'w';
            if (nearRight && inYRange) return 'e';

            return null;
        }

        function handleSelectionStart(e) {
            if (!state.image) return;

            const imgCoords = screenToImage(e.clientX, e.clientY);

            // Check for tool mode clicks first
            if (handleToolClick(imgCoords.x, imgCoords.y)) {
                return;
            }

            const handle = getResizeHandle(imgCoords.x, imgCoords.y);

            if (handle && state.selection) {
                // Start resizing
                state.isResizing = true;
                state.resizeHandle = handle;
                state.dragStart = { ...state.selection };
            } else {
                // Start new selection
                state.isDragging = true;
                state.dragStart = imgCoords;
                state.selection = { x: imgCoords.x, y: imgCoords.y, w: 1, h: 1 };
                state.selectedSpriteIndex = -1;
                state.editingSpriteIndex = -1;
                // Clear name for new selection
                elements.spriteName.value = '';
                elements.spriteDesc.value = '';
            }

            updateSelectionInfo();
            updateJsonPreview();
            showCreatePanel();
        }

        function handleSelectionMove(e) {
            if (!state.image) return;

            const imgCoords = screenToImage(e.clientX, e.clientY);

            if (state.isDragging) {
                const startX = Math.min(state.dragStart.x, imgCoords.x);
                const startY = Math.min(state.dragStart.y, imgCoords.y);
                const endX = Math.max(state.dragStart.x, imgCoords.x) + 1;
                const endY = Math.max(state.dragStart.y, imgCoords.y) + 1;

                state.selection = {
                    x: Math.max(0, startX),
                    y: Math.max(0, startY),
                    w: Math.min(endX - startX, state.imageWidth - startX),
                    h: Math.min(endY - startY, state.imageHeight - startY)
                };

                updateSelectionInfo();
                updatePreviews();
                updateJsonPreview();
                renderSelection();
            } else if (state.isResizing) {
                const { x, y, w, h } = state.dragStart;
                let newX = x, newY = y, newW = w, newH = h;

                const handle = state.resizeHandle;

                if (handle.includes('w')) {
                    newX = Math.max(0, Math.min(imgCoords.x, x + w - 1));
                    newW = x + w - newX;
                }
                if (handle.includes('e')) {
                    newW = Math.max(1, Math.min(imgCoords.x - x + 1, state.imageWidth - x));
                }
                if (handle.includes('n')) {
                    newY = Math.max(0, Math.min(imgCoords.y, y + h - 1));
                    newH = y + h - newY;
                }
                if (handle.includes('s')) {
                    newH = Math.max(1, Math.min(imgCoords.y - y + 1, state.imageHeight - y));
                }

                state.selection = { x: newX, y: newY, w: newW, h: newH };

                updateSelectionInfo();
                updatePreviews();
                updateJsonPreview();
                renderSelection();
            } else {
                // Update cursor based on hover
                const handle = getResizeHandle(imgCoords.x, imgCoords.y);
                if (handle) {
                    const cursors = {
                        'nw': 'nwse-resize', 'se': 'nwse-resize',
                        'ne': 'nesw-resize', 'sw': 'nesw-resize',
                        'n': 'ns-resize', 's': 'ns-resize',
                        'e': 'ew-resize', 'w': 'ew-resize'
                    };
                    elements.selectionCanvas.style.cursor = cursors[handle];
                } else {
                    elements.selectionCanvas.style.cursor = 'crosshair';
                }
            }
        }

        function handleSelectionEnd() {
            if (state.isDragging || state.isResizing) {
                const wasNewSelection = state.isDragging && state.editingSpriteIndex < 0;
                state.isDragging = false;
                state.isResizing = false;
                state.resizeHandle = null;

                // Validate selection
                if (state.selection && (state.selection.w < 1 || state.selection.h < 1)) {
                    state.selection = null;
                    hideCreatePanel();
                    updateJsonPreview();
                } else {
                    updatePreviews();
                    updateJsonPreview();
                    // Auto-suggest name and focus for new selections
                    if (wasNewSelection) {
                        elements.spriteName.value = '';
                        setTimeout(() => elements.spriteName.focus(), 50);
                    }
                }
            }
        }

        // ==========================================
        // Create Sprite Panel
        // ==========================================
        function showCreatePanel() {
            elements.createPanel.classList.add('active');
            // Default to enabled save button for new sprites
            elements.saveSprite.textContent = 'Save Sprite';
            elements.saveSprite.disabled = false;
            // Update tool button states
            updateToolButtonStates();
        }

        function hideCreatePanel() {
            elements.createPanel.classList.remove('active');
            elements.spriteName.value = '';
            elements.spriteDesc.value = '';
            state.editingSpriteIndex = -1;
            state.selectedSpriteIndex = -1;
            // Reset save button
            elements.saveSprite.textContent = 'Save Sprite';
            elements.saveSprite.disabled = false;
            // Update tool button states
            updateToolButtonStates();
            // Clear master sheet highlight
            drawMasterSheetHighlight();
        }

        function updatePreviews() {
            if (!state.selection || !state.image) return;

            const { x, y, w, h } = state.selection;

            // 1x preview
            elements.preview1x.width = w;
            elements.preview1x.height = h;
            const ctx1 = elements.preview1x.getContext('2d');
            ctx1.imageSmoothingEnabled = false;
            ctx1.drawImage(state.image, x, y, w, h, 0, 0, w, h);

            // 4x preview
            elements.preview4x.width = w * 4;
            elements.preview4x.height = h * 4;
            const ctx4 = elements.preview4x.getContext('2d');
            ctx4.imageSmoothingEnabled = false;
            ctx4.drawImage(state.image, x, y, w, h, 0, 0, w * 4, h * 4);
        }

        async function saveSprite() {
            const name = elements.spriteName.value.trim();
            const desc = elements.spriteDesc.value.trim();

            if (!name) {
                showToast('Please enter a sprite name', 'error');
                return;
            }

            if (!validateSpriteName(name)) {
                showToast('Name must start with a letter and contain only letters, numbers, underscores', 'error');
                return;
            }

            if (!state.selection) {
                showToast('Please make a selection first', 'error');
                return;
            }

            if (!state.projectId) {
                showToast('Please select a project first', 'error');
                return;
            }

            if (!state.user) {
                showToast('Please login to save sprites to master sheet', 'error');
                return;
            }

            // Check if this sprite is already on the master sheet (editing existing)
            if (state.editingSpriteIndex >= 0) {
                showToast('Editing saved sprites not yet supported', 'error');
                return;
            }

            const { x, y, w, h } = state.selection;

            // Extract the sprite image data from the source spritesheet
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.imageSmoothingEnabled = false;
            tempCtx.drawImage(state.image, x, y, w, h, 0, 0, w, h);

            try {
                showToast('Publishing to master sheet...');

                // Publish to master sheet with source tracking
                await crucibleClient.publishToMasterSheet(
                    state.projectId,
                    name,
                    tempCanvas, // Pass the canvas as imageData
                    w,
                    h,
                    {
                        type: 'sprite-rite',
                        spritesheetId: state.spritesheetId,
                        originalX: x,
                        originalY: y,
                        originalW: w,
                        originalH: h
                    }
                );

                // Add to local state
                const sprite = {
                    name,
                    description: desc,
                    x: x,
                    y: y,
                    width: w,
                    height: h
                };
                state.sprites.push(sprite);
                state.masterSheetSprites.push(sprite);

                state.selection = null;
                hideCreatePanel();
                updateSpriteList();
                updateMasterSheetPreview();
                render();

                showToast(`Sprite "${name}" saved to master sheet!`);
            } catch (error) {
                console.error('Failed to save sprite:', error);
                showToast('Failed to save: ' + error.message, 'error');
            }
        }

        function cancelSprite() {
            state.selection = null;
            hideCreatePanel();
            updateSelectionInfo();
            updateJsonPreview();
            renderSelection();
        }

        // ==========================================
        // Sprite Directory
        // ==========================================
        function updateSpriteList() {
            elements.spriteCount.textContent = state.sprites.length;

            if (state.sprites.length === 0) {
                elements.spriteList.innerHTML = '<div class="empty-state">No sprites saved yet.<br>Select an area to save one.</div>';
                return;
            }

            elements.spriteList.innerHTML = state.sprites.map((sprite, index) => {
                const isSelected = index === state.selectedSpriteIndex;
                // All sprites in the list are saved to master sheet
                return `
                    <div class="sprite-item saved-to-master ${isSelected ? 'selected' : ''}" data-index="${index}">
                        <div class="sprite-thumb">
                            <canvas width="32" height="32" data-sprite-index="${index}"></canvas>
                        </div>
                        <div class="sprite-info">
                            <div class="sprite-name">${sprite.name}</div>
                            <div class="sprite-coords">(${sprite.x},${sprite.y}) ${sprite.width}×${sprite.height}</div>
                        </div>
                        <button class="sprite-delete" data-index="${index}" data-name="${sprite.name}" title="Remove from master sheet">×</button>
                    </div>
                `;
            }).join('');

            // Render thumbnails
            state.sprites.forEach((sprite, index) => {
                const canvas = elements.spriteList.querySelector(`canvas[data-sprite-index="${index}"]`);
                if (canvas && state.image) {
                    const thumbCtx = canvas.getContext('2d');
                    thumbCtx.imageSmoothingEnabled = false;

                    // Scale to fit in 32x32
                    const scale = Math.min(32 / sprite.width, 32 / sprite.height);
                    const destW = Math.floor(sprite.width * scale);
                    const destH = Math.floor(sprite.height * scale);
                    const offsetX = Math.floor((32 - destW) / 2);
                    const offsetY = Math.floor((32 - destH) / 2);

                    thumbCtx.clearRect(0, 0, 32, 32);
                    thumbCtx.drawImage(
                        state.image,
                        sprite.x, sprite.y, sprite.width, sprite.height,
                        offsetX, offsetY, destW, destH
                    );
                }
            });

            // Add click handlers
            elements.spriteList.querySelectorAll('.sprite-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('sprite-delete')) return;
                    const index = parseInt(item.dataset.index);
                    selectSprite(index);
                });
            });

            // Delete button handlers
            elements.spriteList.querySelectorAll('.sprite-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(btn.dataset.index);
                    const name = btn.dataset.name;
                    confirmDeleteSprite(index, name);
                });
            });
        }

        function selectSprite(index) {
            state.selectedSpriteIndex = index;
            const sprite = state.sprites[index];

            // Show selection (view-only for saved sprites)
            state.selection = {
                x: sprite.x,
                y: sprite.y,
                w: sprite.width,
                h: sprite.height
            };
            state.editingSpriteIndex = index;

            elements.spriteName.value = sprite.name;
            elements.spriteDesc.value = sprite.description || '';

            // Saved sprites - show panel but disable save button
            showCreatePanel();
            elements.saveSprite.textContent = 'Already Saved';
            elements.saveSprite.disabled = true;
            updateSelectionInfo();

            // Highlight in master sheet preview
            drawMasterSheetHighlight();
            updatePreviews();
            updateSpriteList();
            renderSelection();

            // Scroll to sprite in canvas
            const centerX = (sprite.x + sprite.width / 2) * state.zoom;
            const centerY = (sprite.y + sprite.height / 2) * state.zoom;
            elements.canvasWrapper.scrollTo({
                left: centerX - elements.canvasWrapper.clientWidth / 2,
                top: centerY - elements.canvasWrapper.clientHeight / 2,
                behavior: 'smooth'
            });
        }

        let pendingDeleteIndex = -1;
        let pendingDeleteName = '';
        let pendingDeleteType = null; // 'sprite' or 'sheet'
        let pendingDeleteSheetId = null;
        let pendingDeleteSheetName = '';

        function confirmDeleteSprite(index, name) {
            pendingDeleteIndex = index;
            pendingDeleteName = name;
            pendingDeleteType = 'sprite';
            const sprite = state.sprites[index];
            elements.dialogTitle.textContent = 'Remove from Master Sheet?';
            elements.dialogMessage.textContent = `Remove "${sprite.name}" from the master sheet? This cannot be undone.`;
            elements.confirmDialog.classList.add('show');
        }

        function confirmDeleteSheet() {
            if (!state.spritesheetId) return;

            pendingDeleteType = 'sheet';
            pendingDeleteSheetId = state.spritesheetId;
            pendingDeleteSheetName = elements.spriteSheetSelect.options[elements.spriteSheetSelect.selectedIndex]?.text || 'this spritesheet';

            elements.dialogTitle.textContent = 'Delete Spritesheet?';
            elements.dialogMessage.textContent = `Delete "${pendingDeleteSheetName}"? This will remove the image file. Sprites already saved to the master sheet will not be affected.`;
            elements.confirmDialog.classList.add('show');
        }

        async function handleDialogConfirm() {
            if (pendingDeleteType === 'sprite') {
                await deleteSprite();
            } else if (pendingDeleteType === 'sheet') {
                await deleteSheet();
            }
            pendingDeleteType = null;
        }

        async function deleteSprite() {
            if (pendingDeleteIndex >= 0 && pendingDeleteName) {
                try {
                    showToast('Removing from master sheet...');

                    // Remove from master sheet
                    await crucibleClient.removeFromMasterSheet(state.projectId, pendingDeleteName);

                    // Remove from local state
                    state.sprites.splice(pendingDeleteIndex, 1);
                    state.masterSheetSprites = state.masterSheetSprites.filter(s => s.name !== pendingDeleteName);

                    if (state.selectedSpriteIndex === pendingDeleteIndex) {
                        state.selectedSpriteIndex = -1;
                        state.selection = null;
                        hideCreatePanel();
                    } else if (state.selectedSpriteIndex > pendingDeleteIndex) {
                        state.selectedSpriteIndex--;
                    }

                    updateSpriteList();
                    updateMasterSheetPreview();
                    render();
                    showToast('Sprite removed from master sheet');
                } catch (error) {
                    console.error('Failed to delete sprite:', error);
                    showToast('Failed to remove: ' + error.message, 'error');
                }

                pendingDeleteIndex = -1;
                pendingDeleteName = '';
            }
            elements.confirmDialog.classList.remove('show');
        }

        async function deleteSheet() {
            if (!pendingDeleteSheetId) {
                elements.confirmDialog.classList.remove('show');
                return;
            }

            try {
                showToast('Deleting spritesheet...');

                await crucibleClient.deleteSpritesheet(pendingDeleteSheetId);

                // Remove from dropdown
                const option = elements.spriteSheetSelect.querySelector(`option[value="${pendingDeleteSheetId}"]`);
                if (option) {
                    option.remove();
                }

                // Clear state and canvas
                state.spritesheetId = null;
                state.image = null;
                state.imageWidth = 0;
                state.imageHeight = 0;
                state.imageName = '';
                state.imagePath = '';
                state.sprites = [];
                state.selection = null;
                state.selectedSpriteIndex = -1;

                // Reset UI
                elements.spriteSheetSelect.value = '';
                elements.deleteSheetBtn.disabled = true;
                elements.mainCanvas.width = 0;
                elements.mainCanvas.height = 0;
                elements.gridCanvas.width = 0;
                elements.gridCanvas.height = 0;
                elements.selectionCanvas.width = 0;
                elements.selectionCanvas.height = 0;
                elements.dropZone.style.display = 'flex';
                elements.imageInfo.textContent = '';

                hideCreatePanel();
                updateSpriteList();
                updateToolButtonStates();

                showToast('Spritesheet deleted');
            } catch (error) {
                console.error('Failed to delete spritesheet:', error);
                showToast('Failed to delete: ' + error.message, 'error');
            }

            pendingDeleteSheetId = null;
            pendingDeleteSheetName = '';
            elements.confirmDialog.classList.remove('show');
        }

        // ==========================================
        // JSON Export/Import
        // ==========================================
        function generateJson(includeCurrentSelection = false) {
            const result = {
                spriteSheet: state.imagePath || state.imageName,
                exportedAt: new Date().toISOString(),
                sprites: state.sprites.map(s => ({
                    name: s.name,
                    description: s.description || '',
                    x: s.x,
                    y: s.y,
                    width: s.width,
                    height: s.height
                }))
            };

            // Add current selection as unsaved preview
            if (includeCurrentSelection && state.selection && state.editingSpriteIndex < 0) {
                result.currentSelection = {
                    name: elements.spriteName.value || '(unsaved)',
                    x: state.selection.x,
                    y: state.selection.y,
                    width: state.selection.w,
                    height: state.selection.h
                };
            }

            return result;
        }

        function updateJsonPreview() {
            // Legacy function - now updates master sheet preview
            updateMasterSheetPreview();
        }

        async function updateMasterSheetPreview() {
            if (!state.projectId) {
                elements.masterSheetCount.textContent = '0';
                elements.masterSheetPreviewCanvas.style.display = 'none';
                elements.masterSheetEmpty.style.display = 'block';
                state.masterSheetImage = null;
                state.masterSheetScale = 1;
                return;
            }

            try {
                const masterSheet = await crucibleClient.getMasterSheet(state.projectId);
                if (masterSheet.atlas && masterSheet.atlas.sprites) {
                    const count = Object.keys(masterSheet.atlas.sprites).length;
                    elements.masterSheetCount.textContent = count;
                    state.masterSheetData = masterSheet;

                    // Draw preview if we have image data
                    if (masterSheet.png && count > 0) {
                        elements.masterSheetEmpty.style.display = 'none';
                        const img = new Image();
                        img.onload = () => {
                            // Store image for redrawing with highlights
                            state.masterSheetImage = img;

                            const canvas = elements.masterSheetPreviewCanvas;
                            const ctx = canvas.getContext('2d');
                            ctx.imageSmoothingEnabled = false;

                            // Scale to fit in preview area
                            const maxSize = 260;
                            const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
                            state.masterSheetScale = scale;
                            canvas.width = img.width * scale;
                            canvas.height = img.height * scale;
                            canvas.style.display = 'block';

                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                            // Draw highlight if there's a selected sprite
                            drawMasterSheetHighlight();
                        };
                        img.src = masterSheet.png;
                    } else {
                        elements.masterSheetPreviewCanvas.style.display = 'none';
                        elements.masterSheetEmpty.style.display = 'block';
                        state.masterSheetImage = null;
                    }
                } else {
                    elements.masterSheetCount.textContent = '0';
                    elements.masterSheetPreviewCanvas.style.display = 'none';
                    elements.masterSheetEmpty.style.display = 'block';
                    state.masterSheetImage = null;
                }
            } catch (e) {
                console.warn('Could not load master sheet preview:', e);
                elements.masterSheetCount.textContent = '0';
                elements.masterSheetPreviewCanvas.style.display = 'none';
                elements.masterSheetEmpty.style.display = 'block';
                state.masterSheetImage = null;
            }
        }

        function drawMasterSheetHighlight() {
            if (!state.masterSheetImage || !state.masterSheetData?.atlas?.sprites) return;

            const canvas = elements.masterSheetPreviewCanvas;
            const ctx = canvas.getContext('2d');
            const scale = state.masterSheetScale || 1;

            // Redraw the base image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(state.masterSheetImage, 0, 0, canvas.width, canvas.height);

            // If a sprite is selected, find it in the master sheet and highlight
            if (state.selectedSpriteIndex >= 0 && state.sprites[state.selectedSpriteIndex]) {
                const selectedSprite = state.sprites[state.selectedSpriteIndex];
                const masterSprite = state.masterSheetData.atlas.sprites[selectedSprite.name];

                if (masterSprite) {
                    const x = masterSprite.x * scale;
                    const y = masterSprite.y * scale;
                    const w = masterSprite.w * scale;
                    const h = masterSprite.h * scale;

                    // Draw highlight border
                    ctx.strokeStyle = '#e07020';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

                    // Draw subtle fill
                    ctx.fillStyle = 'rgba(224, 112, 32, 0.2)';
                    ctx.fillRect(x, y, w, h);
                }
            }
        }

        function copyMasterSheetJson() {
            if (!state.masterSheetData || !state.masterSheetData.atlas) {
                showToast('No master sheet data', 'error');
                return;
            }
            navigator.clipboard.writeText(JSON.stringify(state.masterSheetData.atlas, null, 2))
                .then(() => showToast('Master sheet JSON copied!'))
                .catch(() => showToast('Failed to copy', 'error'));
        }

        function exportJson() {
            const json = generateJson(false); // Don't include unsaved selection
            const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = state.imageName.replace(/\.[^.]+$/, '') + '-sprites.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('JSON exported!');
        }

        function copyJson() {
            const json = generateJson(false); // Don't include unsaved selection
            navigator.clipboard.writeText(JSON.stringify(json, null, 2))
                .then(() => showToast('JSON copied to clipboard!'))
                .catch(() => showToast('Failed to copy', 'error'));
        }

        function generateIndexEntry() {
            // Generate sprite-index.json format for this sprite sheet
            return {
                [state.imageName]: {
                    path: state.imagePath,
                    sprites: state.sprites.map(s => ({
                        name: s.name,
                        description: s.description || '',
                        x: s.x,
                        y: s.y,
                        width: s.width,
                        height: s.height
                    }))
                }
            };
        }

        function copyIndexEntry() {
            const entry = generateIndexEntry();
            navigator.clipboard.writeText(JSON.stringify(entry, null, 2))
                .then(() => showToast('Index entry copied! Paste into sprite-index.json'))
                .catch(() => showToast('Failed to copy', 'error'));
        }

        function importJson(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.sprites || !Array.isArray(data.sprites)) {
                        throw new Error('Invalid JSON format');
                    }

                    state.sprites = data.sprites.map(s => ({
                        name: s.name,
                        description: s.description || '',
                        x: s.x,
                        y: s.y,
                        width: s.width,
                        height: s.height
                    }));

                    updateSpriteList();
                    updateJsonPreview();
                    scheduleAutoSave();
                    render();

                    showToast(`Imported ${state.sprites.length} sprites!`);
                } catch (err) {
                    showToast('Failed to parse JSON: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==========================================
        // Local Storage
        // ==========================================
        function getStorageKey() {
            return 'spriteRite_session_' + (state.imageName || 'default');
        }

        function saveToLocalStorage() {
            if (!state.imageName) return;
            const data = {
                sprites: state.sprites,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem(getStorageKey(), JSON.stringify(data));
        }

        function loadFromLocalStorage() {
            const data = localStorage.getItem(getStorageKey());
            if (data) {
                try {
                    const parsed = JSON.parse(data);
                    state.sprites = parsed.sprites || [];
                    updateSpriteList();
                    updateJsonPreview();
                    render();
                } catch (e) {
                    console.warn('Failed to load session:', e);
                }
            }
        }

        // ==========================================
        // Event Listeners
        // ==========================================

        // Project selection
        elements.projectSelect.addEventListener('change', (e) => {
            selectProject(e.target.value);
        });

        // Sprite sheet selection
        elements.spriteSheetSelect.addEventListener('change', (e) => {
            selectSpritesheet(e.target.value);
        });

        // Upload
        elements.uploadBtn.addEventListener('click', () => elements.uploadInput.click());
        elements.uploadInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                uploadSpriteSheet(e.target.files[0]);
                e.target.value = ''; // Reset for re-upload
            }
        });

        // JSON import
        elements.importJsonBtn.addEventListener('click', () => elements.importInput.click());
        elements.importInput.addEventListener('change', (e) => {
            if (e.target.files[0]) importJson(e.target.files[0]);
        });

        // Zoom controls
        elements.zoomButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                state.zoom = parseInt(btn.dataset.zoom);
                elements.zoomButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                updateCanvasSize();
                render();
            });
        });

        // Grid toggle
        elements.gridToggle.addEventListener('click', () => {
            state.showGrid = !state.showGrid;
            elements.gridToggle.classList.toggle('active', state.showGrid);
            renderGrid();
        });

        // Tool buttons
        elements.removeBgBtn.addEventListener('click', () => {
            if (!state.image) return;
            removeBackground();
        });

        elements.flipHorizontalBtn.addEventListener('click', () => {
            if (!state.image) return;
            flipHorizontal();
        });

        elements.autoDetectBtn.addEventListener('click', () => {
            if (!state.image) return;
            setToolMode('autoDetect');
        });

        // Selection canvas events
        elements.selectionCanvas.addEventListener('mousedown', handleSelectionStart);
        window.addEventListener('mousemove', handleSelectionMove);
        window.addEventListener('mouseup', handleSelectionEnd);

        // Create panel
        elements.saveSprite.addEventListener('click', saveSprite);
        elements.cancelSprite.addEventListener('click', cancelSprite);

        // Master sheet
        elements.copyMasterJson.addEventListener('click', copyMasterSheetJson);

        // Confirm dialog
        elements.dialogConfirm.addEventListener('click', handleDialogConfirm);
        elements.dialogCancel.addEventListener('click', () => {
            pendingDeleteIndex = -1;
            pendingDeleteType = null;
            pendingDeleteSheetId = null;
            elements.confirmDialog.classList.remove('show');
        });

        // Delete sheet button
        elements.deleteSheetBtn.addEventListener('click', confirmDeleteSheet);

        // Sprite direction notice
        elements.dismissNotice.addEventListener('click', dismissSpriteDirectionNotice);

        // ==========================================
        // AI Generation Functions
        // ==========================================
        function initAIGeneration() {
            // Initialize skeleton editor
            if (typeof SkeletonEditor !== 'undefined') {
                state.skeletonEditor = new SkeletonEditor(elements.skeletonEditorContainer, {
                    width: 280,
                    height: 280,
                    showControls: false // We have our own preset buttons
                });
            }

            // Initialize generation queue
            if (typeof GenerationQueue !== 'undefined') {
                state.generationQueue = new GenerationQueue(elements.generationQueuePanel, {
                    onImport: handleGeneratedAsset,
                    onError: (error) => showToast(error, 'error')
                });
            }

            // Setup event listeners
            setupAIEventListeners();
        }

        function setupAIEventListeners() {
            // Dropdown toggle
            elements.generateDropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                elements.generateDropdownMenu.classList.toggle('open');
            });

            // Close dropdown on outside click
            document.addEventListener('click', () => {
                elements.generateDropdownMenu.classList.remove('open');
            });

            // Dropdown menu items
            elements.generateCharacterBtn.addEventListener('click', () => {
                elements.generateDropdownMenu.classList.remove('open');
                openCharacterModal();
            });

            elements.generateMapObjectBtn.addEventListener('click', () => {
                elements.generateDropdownMenu.classList.remove('open');
                openMapObjectModal();
            });

            elements.viewQueueBtn.addEventListener('click', () => {
                elements.generateDropdownMenu.classList.remove('open');
                if (state.generationQueue) {
                    state.generationQueue.toggle();
                }
            });

            // Character modal
            elements.closeCharacterModal.addEventListener('click', closeCharacterModal);
            elements.cancelCharacterGen.addEventListener('click', closeCharacterModal);
            elements.characterModal.addEventListener('click', (e) => {
                if (e.target === elements.characterModal) closeCharacterModal();
            });
            elements.submitCharacterGen.addEventListener('click', submitCharacterGeneration);

            // Skeleton presets
            document.querySelectorAll('.ai-skeleton-preset').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.ai-skeleton-preset').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const pose = btn.dataset.pose;
                    if (state.skeletonEditor && typeof PixelLabClient !== 'undefined') {
                        state.skeletonEditor.loadPreset(pose);
                    }
                });
            });

            // Skeleton guidance slider
            elements.aiSkeletonGuidance.addEventListener('input', () => {
                elements.guidanceValue.textContent = parseFloat(elements.aiSkeletonGuidance.value).toFixed(1);
            });

            // Map object modal
            elements.closeMapObjectModal.addEventListener('click', closeMapObjectModal);
            elements.cancelMapObjectGen.addEventListener('click', closeMapObjectModal);
            elements.mapObjectModal.addEventListener('click', (e) => {
                if (e.target === elements.mapObjectModal) closeMapObjectModal();
            });
            elements.submitMapObjectGen.addEventListener('click', submitMapObjectGeneration);
        }

        async function openCharacterModal() {
            elements.characterModal.classList.add('open');
            // Reset form
            elements.aiCharacterDesc.value = '';
            elements.aiNegativePrompt.value = '';
            elements.aiSkeletonGuidance.value = '2';
            elements.guidanceValue.textContent = '2.0';

            // Load project settings for defaults
            let outline = 'single_color_black_outline';
            let shading = 'basic_shading';
            let size = 48;
            let directions = 8;

            if (state.projectId && typeof crucibleClient !== 'undefined') {
                try {
                    const settings = await crucibleClient.getProjectSettings(state.projectId);
                    const style = settings.pixellab?.characterStyle || {};
                    const charDefaults = settings.pixellab?.characterDefaults || {};

                    // Map outline values (project uses short form, modal uses long form)
                    if (style.outline) {
                        const outlineMap = {
                            'no_outline': 'no_outline',
                            'single_color_black': 'single_color_black_outline',
                            'single_color_colored': 'single_color_colored_outline'
                        };
                        outline = outlineMap[style.outline] || style.outline;
                    }
                    // Map shading values
                    if (style.shading) {
                        const shadingMap = {
                            'flat': 'flat_shading',
                            'basic': 'basic_shading',
                            'detailed': 'detailed_shading'
                        };
                        shading = shadingMap[style.shading] || style.shading;
                    }
                    if (charDefaults.size) size = charDefaults.size;
                    if (charDefaults.directions) directions = charDefaults.directions;
                } catch (err) {
                    console.warn('Could not load project settings:', err);
                }
            }

            elements.aiDirections.value = String(directions);
            elements.aiSize.value = String(size);
            elements.aiOutline.value = outline;
            elements.aiShading.value = shading;

            // Reset skeleton to idle
            document.querySelectorAll('.ai-skeleton-preset').forEach(b => b.classList.remove('active'));
            document.querySelector('.ai-skeleton-preset[data-pose="idle"]')?.classList.add('active');
            if (state.skeletonEditor) {
                state.skeletonEditor.loadPreset('idle');
            }
        }

        function closeCharacterModal() {
            elements.characterModal.classList.remove('open');
        }

        async function openMapObjectModal() {
            elements.mapObjectModal.classList.add('open');
            // Reset form
            elements.aiMapObjectDesc.value = '';
            elements.aiMapObjectNegative.value = '';

            // Load project settings for defaults
            let width = 32;
            let height = 32;
            let outline = 'single_color_black_outline';
            let view = 'low_top_down';

            if (state.projectId && typeof crucibleClient !== 'undefined') {
                try {
                    const settings = await crucibleClient.getProjectSettings(state.projectId);
                    const style = settings.pixellab?.characterStyle || {};

                    // Map outline values
                    if (style.outline) {
                        const outlineMap = {
                            'no_outline': 'no_outline',
                            'single_color_black': 'single_color_black_outline',
                            'single_color_colored': 'single_color_colored_outline'
                        };
                        outline = outlineMap[style.outline] || style.outline;
                    }
                    // Use project view setting
                    if (style.view) view = style.view;
                } catch (err) {
                    console.warn('Could not load project settings:', err);
                }
            }

            elements.aiMapObjectWidth.value = String(width);
            elements.aiMapObjectHeight.value = String(height);
            elements.aiMapObjectOutline.value = outline;
            elements.aiMapObjectView.value = view;
        }

        function closeMapObjectModal() {
            elements.mapObjectModal.classList.remove('open');
        }

        async function submitCharacterGeneration() {
            const description = elements.aiCharacterDesc.value.trim();
            if (!description) {
                showToast('Please enter a character description', 'error');
                return;
            }

            if (!state.projectId) {
                showToast('Please select a project first', 'error');
                return;
            }

            if (typeof PixelLabClient === 'undefined') {
                showToast('PixelLab client not available', 'error');
                return;
            }

            const options = {
                directions: parseInt(elements.aiDirections.value),
                size: parseInt(elements.aiSize.value),
                outline: elements.aiOutline.value,
                shading: elements.aiShading.value,
                negative_prompt: elements.aiNegativePrompt.value.trim() || undefined
            };

            // Add skeleton if guidance > 0
            const guidance = parseFloat(elements.aiSkeletonGuidance.value);
            if (guidance > 0 && state.skeletonEditor) {
                options.skeleton = state.skeletonEditor.getKeypoints();
                options.skeleton_guidance = guidance;
            }

            closeCharacterModal();
            showToast('Queuing character generation...', 'info');

            try {
                const client = new PixelLabClient();
                const result = await client.createCharacter(description, options);

                if (result.job_id) {
                    // Save to database and add to queue
                    if (state.generationQueue) {
                        await state.generationQueue.addJob({
                            pixellab_job_id: result.job_id,
                            job_type: 'character',
                            prompt: description,
                            parameters: options,
                            skeleton_keypoints: options.skeleton,
                            project_id: state.projectId,
                            user_id: state.user?.id
                        });
                        state.generationQueue.show();
                    }
                    showToast('Character generation queued!', 'success');
                } else if (result.character_id) {
                    // Immediate result (rare)
                    showToast('Character generated!', 'success');
                }
            } catch (error) {
                console.error('Character generation error:', error);
                showToast('Generation failed: ' + error.message, 'error');
            }
        }

        async function submitMapObjectGeneration() {
            const description = elements.aiMapObjectDesc.value.trim();
            if (!description) {
                showToast('Please enter an object description', 'error');
                return;
            }

            if (!state.projectId) {
                showToast('Please select a project first', 'error');
                return;
            }

            if (typeof PixelLabClient === 'undefined') {
                showToast('PixelLab client not available', 'error');
                return;
            }

            const options = {
                width: parseInt(elements.aiMapObjectWidth.value),
                height: parseInt(elements.aiMapObjectHeight.value),
                outline: elements.aiMapObjectOutline.value,
                view: elements.aiMapObjectView.value,
                negative_prompt: elements.aiMapObjectNegative.value.trim() || undefined
            };

            closeMapObjectModal();
            showToast('Queuing map object generation...', 'info');

            try {
                const client = new PixelLabClient();
                const result = await client.createMapObject(description, options);

                if (result.job_id) {
                    if (state.generationQueue) {
                        await state.generationQueue.addJob({
                            pixellab_job_id: result.job_id,
                            job_type: 'map_object',
                            prompt: description,
                            parameters: options,
                            project_id: state.projectId,
                            user_id: state.user?.id
                        });
                        state.generationQueue.show();
                    }
                    showToast('Map object generation queued!', 'success');
                }
            } catch (error) {
                console.error('Map object generation error:', error);
                showToast('Generation failed: ' + error.message, 'error');
            }
        }

        async function handleGeneratedAsset(job) {
            // Called when a generation is complete and user clicks Import
            if (!job.result_url) {
                showToast('No result URL available', 'error');
                return;
            }

            try {
                showToast('Importing generated asset...', 'info');

                // Fetch the image
                const response = await fetch(job.result_url);
                const blob = await response.blob();

                // Create image from blob
                const img = new Image();
                const url = URL.createObjectURL(blob);

                img.onload = () => {
                    URL.revokeObjectURL(url);

                    // Load into editor
                    state.image = img;
                    state.imageWidth = img.width;
                    state.imageHeight = img.height;
                    state.imageName = `generated_${job.job_type}_${Date.now()}.png`;
                    state.sprites = [];
                    state.selectedSpriteIndex = -1;

                    // Update UI
                    elements.canvasContainer.style.display = 'block';
                    elements.dropZone.style.display = 'none';
                    setupCanvases();
                    drawImage();
                    drawGrid();
                    clearSelection();
                    updateSpriteList();
                    updateSpriteCount();
                    elements.imageInfo.textContent = `${img.width} x ${img.height}`;

                    showToast('Asset imported! Auto-detect sprites or select manually.', 'success');
                };

                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    showToast('Failed to load generated image', 'error');
                };

                img.src = url;
            } catch (error) {
                console.error('Import error:', error);
                showToast('Failed to import asset: ' + error.message, 'error');
            }
        }

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            // Escape to cancel selection
            if (e.key === 'Escape') {
                if (state.selection) {
                    cancelSprite();
                }
            }
            // Enter to save sprite
            if (e.key === 'Enter' && state.selection && elements.createPanel.classList.contains('active')) {
                if (document.activeElement === elements.spriteName || document.activeElement === elements.spriteDesc) {
                    saveSprite();
                }
            }
            // Delete selected sprite
            if (e.key === 'Delete' && state.selectedSpriteIndex >= 0) {
                confirmDeleteSprite(state.selectedSpriteIndex);
            }
            // A for Auto-Detect mode
            if (e.key === 'a' || e.key === 'A') {
                if (!e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    if (state.image) {
                        setToolMode(state.toolMode === 'autoDetect' ? null : 'autoDetect');
                    }
                }
            }
        });

        // Initialize
        init();
        updateJsonPreview();
    </script>

    <!-- Help Drawer -->
    <script src="../shared/help-drawer.js"></script>
    <script src="../shared/docs/sprite-rite-docs.js"></script>
    <script>
        // Initialize help drawer with Sprite-Rite docs
        HelpDrawer.init({
            toolId: 'sprite-rite',
            toolName: 'Sprite-Rite',
            toolIcon: '&#128123;',
            accentColor: '#e07020',
            docs: SPRITE_RITE_DOCS
        });
    </script>
</body>
</html>
