<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animancer | Game Wizard</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* ============================================
           ANIMANCER - CSS
           ============================================ */

        :root {
            /* Backgrounds */
            --bg-deep: #0d0d14;
            --bg-mid: #1a1a2e;
            --bg-surface: #252542;

            /* Accents - ember warmth */
            --accent-ember: #e07020;
            --accent-ember-glow: #ff9040;
            --accent-magma: #c04020;

            /* Stone/neutral tones */
            --stone-dark: #3a3a5c;
            --stone-mid: #6a6a8e;
            --stone-light: #9a9abe;
            --stone-bright: #d0d0e8;

            /* Purple undertones */
            --mystic-deep: #2a1a3e;
            --mystic-glow: #8060c0;

            /* Timeline colors */
            --timeline-bg: #151520;
            --timeline-track: #202030;
            --frame-border: #4a4a6e;
            --frame-selected: #8060c0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-deep);
            color: var(--stone-light);
            min-height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: var(--bg-mid);
            border-bottom: 1px solid var(--stone-dark);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .home-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            font-size: 18px;
            text-decoration: none;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .home-btn:hover {
            background: var(--stone-dark);
            border-color: var(--accent-ember);
        }

        .brand-icon {
            font-size: 20px;
            animation: flicker 2s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            70% { opacity: 1; }
            75% { opacity: 0.7; }
            80% { opacity: 1; }
        }

        .brand-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .brand-text span {
            color: var(--accent-ember);
            text-shadow: 0 0 10px rgba(224, 112, 32, 0.5);
        }

        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-select {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-light);
            cursor: pointer;
            min-width: 160px;
        }

        .header-select:focus {
            outline: none;
            border-color: var(--mystic-glow);
        }

        .auth-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            font-size: 11px;
            color: var(--stone-mid);
        }

        .auth-indicator.logged-in {
            border-color: var(--mystic-glow);
            color: var(--stone-light);
        }

        .auth-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--stone-dark);
        }

        .auth-indicator.logged-in .auth-dot {
            background: #4ade80;
        }

        .save-indicator {
            font-size: 10px;
            color: var(--stone-mid);
            min-width: 60px;
            text-align: right;
        }

        .save-indicator.saving {
            color: var(--accent-ember);
        }

        .save-indicator.saved {
            color: #4ade80;
        }

        /* Buttons */
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            background: var(--bg-surface);
            color: var(--stone-light);
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: var(--stone-dark);
            border-color: var(--stone-mid);
        }

        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--mystic-glow);
        }

        .btn-primary {
            background: var(--accent-ember);
            border-color: var(--accent-ember);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--accent-ember-glow);
            border-color: var(--accent-ember-glow);
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 10px;
        }

        .btn-icon {
            padding: 6px 10px;
            font-size: 14px;
        }

        /* Main Layout */
        .main {
            display: grid;
            grid-template-columns: 1fr 320px;
            grid-template-rows: 1fr;
            height: calc(100vh - 53px);
        }

        /* Left Panel - Sprites & Timeline */
        .left-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
            max-height: calc(100vh - 53px); /* Header height */
        }

        /* Sprite Palette */
        .sprite-palette {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            border-bottom: 1px solid var(--stone-dark);
            min-height: 120px;
            max-height: calc(100vh - 400px); /* Leave room for timeline + library */
        }

        .sprite-palette::-webkit-scrollbar {
            width: 8px;
        }

        .sprite-palette::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 4px;
        }

        .section-header {
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            color: var(--stone-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .sprite-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 8px;
        }

        .sprite-tile {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .sprite-tile:hover {
            border-color: var(--mystic-glow);
            background: var(--mystic-deep);
        }

        .sprite-tile-canvas {
            width: 48px;
            height: 48px;
            background: repeating-conic-gradient(
                var(--bg-mid) 0% 25%,
                var(--bg-deep) 0% 50%
            ) 50% / 8px 8px;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 4px;
        }

        .sprite-tile-canvas canvas {
            image-rendering: pixelated;
        }

        .sprite-tile-name {
            font-size: 8px;
            color: var(--stone-mid);
            text-align: center;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Timeline */
        .timeline-section {
            background: var(--timeline-bg);
            border-top: 1px solid var(--stone-dark);
            padding: 16px;
            flex-shrink: 0;
            min-height: 160px;
            max-height: 180px;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .timeline-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .timeline-info {
            font-size: 10px;
            color: var(--stone-mid);
        }

        .timeline-track {
            display: flex;
            gap: 4px;
            padding: 12px;
            background: var(--timeline-track);
            border-radius: 4px;
            min-height: 100px;
            overflow-x: auto;
            align-items: flex-start;
        }

        .timeline-track::-webkit-scrollbar {
            height: 6px;
        }

        .timeline-track::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 3px;
        }

        .timeline-frame {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: var(--bg-surface);
            border: 2px solid var(--frame-border);
            border-radius: 4px;
            cursor: grab;
            transition: all 0.15s;
            min-width: 72px;
            position: relative;
        }

        .timeline-frame:hover {
            border-color: var(--stone-mid);
        }

        .timeline-frame.selected {
            border-color: var(--frame-selected);
            background: var(--mystic-deep);
        }

        .timeline-frame.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .timeline-frame-canvas {
            width: 48px;
            height: 48px;
            background: repeating-conic-gradient(
                var(--bg-mid) 0% 25%,
                var(--bg-deep) 0% 50%
            ) 50% / 8px 8px;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 4px;
        }

        .timeline-frame-canvas canvas {
            image-rendering: pixelated;
        }

        .timeline-frame-duration {
            font-size: 9px;
            color: var(--accent-ember);
            margin-bottom: 2px;
        }

        .timeline-frame-tween {
            font-size: 7px;
            color: var(--mystic-glow);
            margin-top: 2px;
        }

        /* Tween connector between frames */
        .timeline-tween-connector {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            flex-shrink: 0;
            position: relative;
        }

        .timeline-tween-connector::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, var(--mystic-glow), var(--accent-ember));
            top: 50%;
            transform: translateY(-50%);
        }

        .timeline-tween-connector-icon {
            background: var(--timeline-track);
            padding: 2px 4px;
            font-size: 10px;
            z-index: 1;
            color: var(--mystic-glow);
        }

        .timeline-frame-name {
            font-size: 7px;
            color: var(--stone-mid);
            max-width: 64px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .timeline-frame-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 8px;
            color: var(--stone-dark);
        }

        .timeline-frame-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 14px;
            height: 14px;
            background: var(--accent-magma);
            border: none;
            border-radius: 2px;
            color: white;
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timeline-frame:hover .timeline-frame-remove {
            opacity: 1;
        }

        .timeline-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 20px;
            color: var(--stone-mid);
            font-size: 11px;
        }

        .timeline-empty-icon {
            font-size: 24px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        /* Right Panel - Preview & Settings */
        .right-panel {
            display: flex;
            flex-direction: column;
            background: var(--bg-mid);
            border-left: 1px solid var(--stone-dark);
            overflow: hidden;
            min-height: 0;
        }

        /* Preview Section */
        .preview-section {
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .preview-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .preview-canvas-wrapper {
            width: 200px;
            height: 200px;
            background: repeating-conic-gradient(
                var(--bg-surface) 0% 25%,
                var(--bg-mid) 0% 50%
            ) 50% / 16px 16px;
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
        }

        #previewCanvas {
            image-rendering: pixelated;
        }

        .preview-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }

        .preview-info {
            font-size: 10px;
            color: var(--stone-mid);
            text-align: center;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--stone-mid);
        }

        .speed-control input {
            width: 60px;
            padding: 4px 6px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 3px;
            color: var(--stone-bright);
            font-family: inherit;
            font-size: 10px;
            text-align: center;
        }

        /* Settings Section */
        .settings-section {
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
            flex-shrink: 0;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            background: var(--bg-deep);
            border: 1px solid var(--stone-dark);
            border-radius: 4px;
            color: var(--stone-bright);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--mystic-glow);
        }

        .form-row {
            display: flex;
            gap: 12px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-ember);
        }

        .checkbox-group label {
            font-size: 11px;
            color: var(--stone-light);
        }

        /* Frame Editor */
        .frame-editor {
            padding: 16px;
            border-bottom: 1px solid var(--stone-dark);
            display: none;
            flex-shrink: 0;
        }

        .frame-editor.active {
            display: block;
        }

        .frame-editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        /* Animation Library - Below timeline */
        .animation-library-section {
            padding: 12px 16px;
            border-top: 1px solid var(--stone-dark);
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-mid);
            flex-shrink: 0;
        }

        .animation-library-section::-webkit-scrollbar {
            width: 8px;
        }

        .animation-library-section::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 4px;
        }

        .animation-list-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        /* Animation Cards Grid */
        .animation-card-grid {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .animation-card {
            display: flex;
            flex-direction: column;
            width: 140px;
            padding: 10px;
            background: var(--bg-surface);
            border: 2px solid var(--stone-dark);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
            position: relative;
        }

        .animation-card:hover {
            border-color: var(--mystic-glow);
            background: var(--mystic-deep);
        }

        .animation-card.active {
            border-color: var(--accent-ember);
            box-shadow: 0 0 8px rgba(224, 112, 32, 0.3);
        }

        .animation-card-preview {
            width: 120px;
            height: 80px;
            background: repeating-conic-gradient(
                var(--bg-mid) 0% 25%,
                var(--bg-deep) 0% 50%
            ) 50% / 8px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .animation-card-preview canvas {
            image-rendering: pixelated;
        }

        .animation-card-name {
            font-size: 11px;
            font-weight: 500;
            color: var(--stone-bright);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .animation-card-meta {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: var(--stone-mid);
        }

        .animation-card-delete {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: var(--accent-magma);
            border: none;
            border-radius: 3px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .animation-card:hover .animation-card-delete {
            opacity: 1;
        }

        .animation-card-delete:hover {
            background: #ff4444;
        }

        /* Broken animation state */
        .animation-card.broken {
            border-color: var(--accent-magma);
            background: rgba(255, 68, 68, 0.1);
        }

        .animation-card.broken:hover {
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.15);
        }

        .animation-card-warning {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: var(--accent-magma);
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 68, 68, 0.3);
        }

        .animation-card-warning-icon {
            font-size: 12px;
        }

        .animation-card-actions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }

        .animation-card-actions .btn {
            font-size: 9px;
            padding: 3px 6px;
        }

        /* Legacy list style hidden */
        .animation-list-section {
            display: none;
        }

        /* New Animation Indicator */
        .new-animation-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: linear-gradient(135deg, var(--accent-ember), var(--accent-magma));
            color: white;
            font-size: 10px;
            font-weight: 600;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .animation-editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--stone-dark);
        }

        .animation-editor-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .editing-animation-name {
            font-size: 12px;
            color: var(--stone-bright);
            font-weight: 500;
        }

        .editing-animation-name.unsaved {
            color: var(--accent-ember);
            font-style: italic;
        }

        /* Export Section */
        .export-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            min-height: 0;
            overflow: hidden;
        }

        .export-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .export-actions .btn {
            flex: 1;
        }

        .json-preview {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .json-preview-header {
            padding: 8px 12px;
            background: var(--bg-surface);
            font-size: 10px;
            color: var(--stone-mid);
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .json-preview-content {
            flex: 1;
            overflow: auto;
            padding: 8px 12px;
            background: var(--bg-deep);
            font-size: 10px;
            line-height: 1.5;
            white-space: pre;
            min-height: 0;
        }

        .json-preview-content::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        .json-preview-content::-webkit-scrollbar-thumb {
            background: var(--stone-dark);
            border-radius: 3px;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 20px;
            background: var(--bg-surface);
            border: 1px solid var(--accent-ember);
            border-radius: 4px;
            font-size: 12px;
            color: var(--stone-bright);
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--stone-mid);
            text-align: center;
            padding: 20px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 12px;
            margin-bottom: 8px;
        }

        .empty-state-hint {
            font-size: 10px;
            color: var(--stone-dark);
        }

        /* AI Generation */
        .btn-ai {
            background: linear-gradient(135deg, #3a2a4a, #4a3a5a);
            border-color: var(--mystic-glow);
            color: var(--mystic-glow);
        }

        .btn-ai:hover {
            background: var(--mystic-glow);
            color: white;
        }

        .generation-queue-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            max-height: 400px;
            background: var(--bg-mid);
            border: 1px solid var(--stone-dark);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            z-index: 1500;
            display: none;
        }

        .generation-queue-panel.visible {
            display: block;
        }

        .view-queue-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 16px;
            background: var(--bg-surface);
            border: 1px solid var(--stone-dark);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--stone-light);
            cursor: pointer;
            z-index: 1400;
            display: none;
        }

        .view-queue-btn:hover {
            border-color: var(--accent-ember);
            color: var(--accent-ember);
        }

        .view-queue-btn.has-jobs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .queue-count {
            background: var(--accent-ember);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="brand">
            <a href="/game-wizard/" class="home-btn" title="Back to Game Wizard">&#128302;</a>
            <span class="brand-icon">&#128293;</span>
            <span class="brand-text">GAME WIZARD / <span>ANIMANCER</span></span>
        </div>
        <div class="header-actions">
            <select class="header-select" id="projectSelect">
                <option value="">-- Select Project --</option>
            </select>
            <span class="save-indicator" id="saveIndicator"></span>
            <div class="auth-indicator" id="authIndicator">
                <span class="auth-dot"></span>
                <span class="auth-text">Guest</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main">
        <!-- Left Panel -->
        <div class="left-panel">
            <!-- Sprite Palette -->
            <div class="sprite-palette" id="spritePalette">
                <div class="empty-state" id="paletteEmpty">
                    <div class="empty-state-icon">&#127912;</div>
                    <div class="empty-state-text">Select a project</div>
                    <div class="empty-state-hint">Sprites from the master sheet will appear here</div>
                </div>
                <div id="paletteContent" style="display: none;">
                    <div class="section-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>Master Sheet</span>
                        <select class="source-filter" id="sourceFilter" style="font-size: 10px; padding: 4px 8px; background: var(--bg-surface); border: 1px solid var(--stone-dark); border-radius: 4px; color: var(--stone-light);">
                            <option value="">All Sources</option>
                        </select>
                    </div>
                    <div class="sprite-grid" id="spriteGrid"></div>
                </div>
            </div>

            <!-- Timeline -->
            <div class="timeline-section">
                <div class="timeline-header">
                    <div class="section-header" style="margin-bottom: 0;">Timeline</div>
                    <div class="timeline-controls">
                        <span class="timeline-info" id="timelineInfo">0 frames | 0.00s</span>
                        <button class="btn btn-small" id="clearTimeline">Clear</button>
                    </div>
                </div>
                <div class="timeline-track" id="timelineTrack">
                    <div class="timeline-empty" id="timelineEmpty">
                        <div class="timeline-empty-icon">&#128247;</div>
                        <div>Click sprites above to add frames</div>
                    </div>
                </div>
            </div>

            <!-- Animation Library (below timeline) -->
            <div class="animation-library-section" id="animationLibrarySection" style="display: none;">
                <div class="animation-list-header">
                    <span class="section-header" style="margin-bottom: 0;">Saved Animations</span>
                    <button class="btn btn-small btn-primary" id="newAnimationBtn">+ New</button>
                </div>
                <div class="animation-card-grid" id="animationLibrary"></div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Preview -->
            <div class="preview-section">
                <div class="section-header">Preview</div>
                <div class="preview-container">
                    <div class="preview-canvas-wrapper">
                        <canvas id="previewCanvas" width="128" height="128"></canvas>
                    </div>
                    <div class="preview-controls">
                        <button class="btn btn-icon" id="playBtn" title="Play/Pause">&#9658;</button>
                        <button class="btn btn-icon" id="stopBtn" title="Stop">&#9632;</button>
                        <button class="btn btn-icon" id="stepBtn" title="Step">&#9654;|</button>
                    </div>
                    <div class="speed-control">
                        <span>Speed:</span>
                        <input type="number" id="speedMultiplier" value="1" min="0.1" max="5" step="0.1">
                        <span>x</span>
                    </div>
                    <div class="preview-info" id="previewInfo">Frame 0/0</div>
                </div>
            </div>

            <!-- Current Animation Status -->
            <div class="animation-editor-header" id="animationEditorHeader">
                <div class="animation-editor-title">
                    <span id="animationStatusBadge" class="new-animation-badge">New Animation</span>
                    <span id="editingAnimationName" class="editing-animation-name unsaved"></span>
                </div>
                <button class="btn btn-small btn-ai" id="generateAnimBtn" title="Generate animation with AI (requires PixelLab character)">&#10024; AI</button>
            </div>

            <!-- Animation Settings -->
            <div class="settings-section">
                <div class="section-header">Animation Settings</div>
                <div class="form-group">
                    <label class="form-label">Animation Name *</label>
                    <input type="text" class="form-input" id="animationName" placeholder="idle_look_around">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Default Duration (s)</label>
                        <input type="number" class="form-input" id="defaultDuration" value="0.5" min="0.01" max="10" step="0.01">
                    </div>
                    <div class="form-group">
                        <div class="checkbox-group" style="margin-top: 20px;">
                            <input type="checkbox" id="uniformDuration" checked>
                            <label for="uniformDuration">Uniform</label>
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Tween Duration (s)</label>
                        <input type="number" class="form-input" id="tweenDuration" value="0" min="0" max="5" step="0.05">
                    </div>
                    <div class="form-group">
                        <div class="checkbox-group" style="margin-top: 20px;">
                            <input type="checkbox" id="enableTween">
                            <label for="enableTween">Tween</label>
                        </div>
                    </div>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="loopAnimation" checked>
                    <label for="loopAnimation">Loop animation</label>
                </div>
            </div>

            <!-- Selected Frame Editor -->
            <div class="frame-editor" id="frameEditor">
                <div class="frame-editor-header">
                    <span class="section-header" style="margin-bottom: 0;">Selected Frame</span>
                    <button class="btn btn-small" id="removeFrameBtn">Remove</button>
                </div>
                <div class="form-group">
                    <label class="form-label">Sprite</label>
                    <input type="text" class="form-input" id="frameSpriteName" readonly>
                </div>
                <div class="form-group">
                    <label class="form-label">Duration (seconds)</label>
                    <input type="number" class="form-input" id="frameDuration" value="0.5" min="0.01" max="10" step="0.01">
                </div>
            </div>

            <!-- Export -->
            <div class="export-section">
                <div class="export-actions">
                    <button class="btn btn-primary" id="saveAnimationBtn">Save Animation</button>
                    <button class="btn" id="copyJsonBtn">Copy JSON</button>
                </div>
                <div class="json-preview">
                    <div class="json-preview-header">JSON Output</div>
                    <div class="json-preview-content" id="jsonOutput">{}</div>
                </div>
            </div>
        </div>
    </main>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Generation Queue Panel -->
    <div class="generation-queue-panel" id="generationQueuePanel"></div>

    <!-- View Queue Button -->
    <button class="view-queue-btn" id="viewQueueBtn">
        <span>&#128203;</span> Queue <span class="queue-count" id="queueCount">0</span>
    </button>

    <script src="../shared/supabase-client.js"></script>
    <script src="../shared/project-gate.js"></script>
    <script src="../shared/master-sheet.js"></script>
    <script src="../shared/pixellab-client.js"></script>
    <script src="../shared/generation-queue.js"></script>
    <script>
        /* ============================================
           ANIMANCER - JavaScript
           ============================================ */

        // ==========================================
        // State
        // ==========================================
        const state = {
            user: null,
            projectId: null,
            sprites: [],
            animations: {}, // Now an object keyed by animation name
            currentAnimationKey: null, // The key of the animation being edited
            frames: [],
            selectedFrameIndex: -1,
            isPlaying: false,
            playbackFrame: 0,
            playbackTimer: 0,
            speedMultiplier: 1,
            tweenEnabled: false,
            tweenDuration: 0,
            tweenProgress: 0,
            saveTimeout: null,
            isDirty: false,
            masterSheetAtlas: null,
            masterSheetImage: null,
            generationQueue: null,
            sourceFilter: '' // Filter sprites by source sheet
        };

        let animationLoop = null;
        let lastTime = 0;

        // ==========================================
        // DOM Elements
        // ==========================================
        const elements = {
            projectSelect: document.getElementById('projectSelect'),
            sourceFilter: document.getElementById('sourceFilter'),
            saveIndicator: document.getElementById('saveIndicator'),
            authIndicator: document.getElementById('authIndicator'),
            paletteEmpty: document.getElementById('paletteEmpty'),
            paletteContent: document.getElementById('paletteContent'),
            spriteGrid: document.getElementById('spriteGrid'),
            timelineTrack: document.getElementById('timelineTrack'),
            timelineEmpty: document.getElementById('timelineEmpty'),
            timelineInfo: document.getElementById('timelineInfo'),
            clearTimeline: document.getElementById('clearTimeline'),
            previewCanvas: document.getElementById('previewCanvas'),
            playBtn: document.getElementById('playBtn'),
            stopBtn: document.getElementById('stopBtn'),
            stepBtn: document.getElementById('stepBtn'),
            speedMultiplier: document.getElementById('speedMultiplier'),
            previewInfo: document.getElementById('previewInfo'),
            // Animation library (below timeline)
            animationLibrarySection: document.getElementById('animationLibrarySection'),
            animationLibrary: document.getElementById('animationLibrary'),
            newAnimationBtn: document.getElementById('newAnimationBtn'),
            // Animation status (right panel)
            animationStatusBadge: document.getElementById('animationStatusBadge'),
            editingAnimationName: document.getElementById('editingAnimationName'),
            animationName: document.getElementById('animationName'),
            defaultDuration: document.getElementById('defaultDuration'),
            uniformDuration: document.getElementById('uniformDuration'),
            tweenDuration: document.getElementById('tweenDuration'),
            enableTween: document.getElementById('enableTween'),
            loopAnimation: document.getElementById('loopAnimation'),
            frameEditor: document.getElementById('frameEditor'),
            frameSpriteName: document.getElementById('frameSpriteName'),
            frameDuration: document.getElementById('frameDuration'),
            removeFrameBtn: document.getElementById('removeFrameBtn'),
            saveAnimationBtn: document.getElementById('saveAnimationBtn'),
            copyJsonBtn: document.getElementById('copyJsonBtn'),
            jsonOutput: document.getElementById('jsonOutput'),
            toast: document.getElementById('toast'),
            generateAnimBtn: document.getElementById('generateAnimBtn'),
            generationQueuePanel: document.getElementById('generationQueuePanel'),
            viewQueueBtn: document.getElementById('viewQueueBtn'),
            queueCount: document.getElementById('queueCount')
        };

        const previewCtx = elements.previewCanvas.getContext('2d');
        previewCtx.imageSmoothingEnabled = false;

        // ==========================================
        // Initialization
        // ==========================================
        async function init() {
            // Check if user has projects (displays gate if not)
            const hasProject = await checkProjectGate();
            if (!hasProject) return;

            await crucibleClient.init();
            state.user = await crucibleClient.getUser();
            updateAuthIndicator();

            if (state.user) {
                await loadProjects();
            } else {
                loadFromLocalStorage();
            }

            setupEventListeners();
            updateJsonOutput();
            updatePreviewInfo();
            updateTimelineInfo();
            updateAnimationStatus();

            // Initialize generation queue
            initGenerationQueue();
        }

        // ==========================================
        // AI Generation Queue
        // ==========================================
        function initGenerationQueue() {
            if (typeof GenerationQueue !== 'undefined' && elements.generationQueuePanel) {
                state.generationQueue = new GenerationQueue(elements.generationQueuePanel, {
                    onImport: handleGeneratedAnimation,
                    onError: (error) => showToast(error, 'error'),
                    onJobsChange: updateQueueCount
                });
            }

            // Generate animation button
            if (elements.generateAnimBtn) {
                elements.generateAnimBtn.addEventListener('click', showAnimationGenerationInfo);
            }

            // View queue button
            if (elements.viewQueueBtn) {
                elements.viewQueueBtn.addEventListener('click', () => {
                    if (state.generationQueue) {
                        state.generationQueue.toggle();
                    }
                });
            }
        }

        function updateQueueCount(jobs) {
            const pending = jobs.filter(j => j.status === 'pending' || j.status === 'processing').length;
            if (elements.queueCount) {
                elements.queueCount.textContent = pending;
            }
            if (elements.viewQueueBtn) {
                elements.viewQueueBtn.classList.toggle('has-jobs', pending > 0);
            }
        }

        function showAnimationGenerationInfo() {
            showToast('Generate characters in Incarnum first, then animations will be available for those characters.', 'info');
        }

        async function handleGeneratedAnimation(job) {
            if (!job.result_url) {
                showToast('No result URL available', 'error');
                return;
            }
            // Animation results would be handled here
            // For now, show a message
            showToast('Animation ready! Import frames from the result.', 'success');
        }

        function updateAuthIndicator() {
            const indicator = elements.authIndicator;
            const textEl = indicator.querySelector('.auth-text');

            if (state.user) {
                indicator.classList.add('logged-in');
                const name = state.user.user_metadata?.display_name || state.user.email?.split('@')[0] || 'User';
                textEl.textContent = name;
            } else {
                indicator.classList.remove('logged-in');
                textEl.textContent = 'Guest';
            }
        }

        // ==========================================
        // Project & Spritesheet Loading
        // ==========================================
        async function loadProjects() {
            try {
                const projects = await crucibleClient.getProjects();

                elements.projectSelect.innerHTML = '<option value="">-- Select Project --</option>';
                projects.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = p.name;
                    elements.projectSelect.appendChild(opt);
                });

                // Restore last selected project
                const lastProject = localStorage.getItem('animstation_project');
                if (lastProject && projects.find(p => p.id === lastProject)) {
                    elements.projectSelect.value = lastProject;
                    await selectProject(lastProject);
                }
            } catch (err) {
                console.error('Failed to load projects:', err);
                showToast('Failed to load projects');
            }
        }

        async function selectProject(projectId) {
            state.projectId = projectId;
            state.sprites = [];
            state.animations = {};
            state.currentAnimationKey = null;
            state.masterSheetAtlas = null;
            state.masterSheetImage = null;
            state.sourceFilter = '';

            localStorage.setItem('animstation_project', projectId);

            // Reset source filter
            elements.sourceFilter.innerHTML = '<option value="">All Sources</option>';
            elements.sourceFilter.value = '';

            if (!projectId) {
                renderSpritePalette();
                renderAnimationLibrary();
                updateAnimationStatus();
                return;
            }

            try {
                // Load master sprite sheet for this project (or fallback to legacy master sheet)
                let masterSheet = null;

                // Try new master sprite sheet first
                if (crucibleClient.getMasterSpriteSheet) {
                    try {
                        masterSheet = await crucibleClient.getMasterSpriteSheet(projectId);
                    } catch (e) {
                        console.warn('Could not load master sprite sheet:', e.message);
                    }
                }

                if (masterSheet && masterSheet.atlas) {
                    // Load animations from master sprite sheet atlas (even if no sprites yet)
                    state.animations = masterSheet.atlas.animations || {};

                    // Migrate old animations from database table (merge, don't skip)
                    try {
                        const oldAnimations = await crucibleClient.getProjectAnimations(projectId);
                        if (oldAnimations && oldAnimations.length > 0) {
                            let migratedCount = 0;
                            for (const oldAnim of oldAnimations) {
                                const animKey = oldAnim.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                                // Skip if already exists in atlas
                                if (state.animations[animKey]) {
                                    continue;
                                }
                                const animData = {
                                    name: oldAnim.name,
                                    description: oldAnim.description || '',
                                    frames: (oldAnim.frames || []).map(f => ({
                                        spriteName: f.spriteName || f.sprite_name,
                                        duration: f.duration || 100
                                    })),
                                    fps: oldAnim.fps || 12,
                                    loop: oldAnim.loop !== false
                                };
                                await crucibleClient.saveMasterSpriteSheetAnimation(projectId, animKey, animData);
                                state.animations[animKey] = animData;
                                migratedCount++;
                            }
                            if (migratedCount > 0) {
                                console.log(`Migrated ${migratedCount} animations from database to atlas`);
                                showToast(`Migrated ${migratedCount} animation(s) to new storage`);
                            }
                        }
                    } catch (e) {
                        console.warn('Could not migrate old animations:', e);
                    }

                    // Load sprites if available
                    if (masterSheet.png && Object.keys(masterSheet.atlas.sprites || {}).length > 0) {
                        const img = new Image();
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = masterSheet.png;
                        });
                        state.masterSheetAtlas = masterSheet.atlas;
                        state.masterSheetImage = img;

                        // Convert master sheet atlas to sprites array format
                        state.sprites = Object.entries(masterSheet.atlas.sprites).map(([name, def]) => ({
                            name,
                            x: def.x,
                            y: def.y,
                            width: def.w,
                            height: def.h,
                            source: def.source
                        }));

                        // Populate source filter with unique sources
                        populateSourceFilter();
                    }
                }

                renderSpritePalette();
                renderAnimationLibrary();
                updateAnimationStatus();
            } catch (err) {
                console.error('Failed to load master sprite sheet:', err);
                showToast('Failed to load master sprite sheet');
            }
        }

        function populateSourceFilter() {
            // Get unique sources from sprites
            const sources = new Map();
            state.sprites.forEach(sprite => {
                if (sprite.source && sprite.source.spritesheetId) {
                    if (!sources.has(sprite.source.spritesheetId)) {
                        sources.set(sprite.source.spritesheetId, {
                            id: sprite.source.spritesheetId,
                            type: sprite.source.type,
                            count: 1
                        });
                    } else {
                        sources.get(sprite.source.spritesheetId).count++;
                    }
                }
            });

            // Add options to filter
            elements.sourceFilter.innerHTML = '<option value="">All Sources</option>';

            // Fetch spritesheet names for better labels
            if (sources.size > 0 && state.projectId) {
                crucibleClient.getSpritesheets(state.projectId).then(spritesheets => {
                    const sheetMap = new Map(spritesheets.map(s => [s.id, s.name]));

                    sources.forEach((info, id) => {
                        const opt = document.createElement('option');
                        opt.value = id;
                        const name = sheetMap.get(id) || `${info.type} (${id.slice(0, 8)}...)`;
                        opt.textContent = `${name} (${info.count})`;
                        elements.sourceFilter.appendChild(opt);
                    });
                }).catch(() => {
                    // Fallback: just use IDs
                    sources.forEach((info, id) => {
                        const opt = document.createElement('option');
                        opt.value = id;
                        opt.textContent = `${info.type} (${info.count} sprites)`;
                        elements.sourceFilter.appendChild(opt);
                    });
                });
            }
        }

        // ==========================================
        // LocalStorage Fallback
        // ==========================================
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('animstation_local_data');
                if (saved) {
                    const data = JSON.parse(saved);
                    state.frames = data.frames || [];
                    elements.animationName.value = data.name || '';
                    elements.defaultDuration.value = data.defaultDuration || 0.5;
                    state.tweenEnabled = data.tweenEnabled || false;
                    state.tweenDuration = data.tweenDuration || 0;
                    elements.enableTween.checked = state.tweenEnabled;
                    elements.tweenDuration.value = state.tweenDuration;
                }
            } catch (e) {
                console.warn('Could not load local data:', e);
            }
        }

        function saveToLocalStorage() {
            if (state.user) return;

            const data = {
                name: elements.animationName.value,
                frames: state.frames,
                defaultDuration: parseFloat(elements.defaultDuration.value),
                tweenEnabled: state.tweenEnabled,
                tweenDuration: state.tweenDuration
            };

            localStorage.setItem('animstation_local_data', JSON.stringify(data));
        }

        // ==========================================
        // Sprite Palette
        // ==========================================
        function renderSpritePalette() {
            if (state.sprites.length === 0) {
                elements.paletteEmpty.style.display = 'flex';
                elements.paletteContent.style.display = 'none';
                return;
            }

            elements.paletteEmpty.style.display = 'none';
            elements.paletteContent.style.display = 'block';

            elements.spriteGrid.innerHTML = '';

            // Filter sprites by source if filter is active
            const filteredSprites = state.sourceFilter
                ? state.sprites.filter(s => s.source && s.source.spritesheetId === state.sourceFilter)
                : state.sprites;

            if (filteredSprites.length === 0 && state.sourceFilter) {
                elements.spriteGrid.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--stone-mid); font-size: 11px;">No sprites from this source</div>';
                return;
            }

            filteredSprites.forEach((sprite, index) => {
                const tile = document.createElement('div');
                tile.className = 'sprite-tile';
                tile.dataset.index = state.sprites.indexOf(sprite); // Use original index

                const canvasWrapper = document.createElement('div');
                canvasWrapper.className = 'sprite-tile-canvas';

                const canvas = document.createElement('canvas');
                const scale = Math.min(44 / sprite.width, 44 / sprite.height);
                canvas.width = Math.floor(sprite.width * scale);
                canvas.height = Math.floor(sprite.height * scale);

                if (state.masterSheetImage) {
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        state.masterSheetImage,
                        sprite.x, sprite.y, sprite.width, sprite.height,
                        0, 0, canvas.width, canvas.height
                    );
                }

                canvasWrapper.appendChild(canvas);

                const nameLabel = document.createElement('div');
                nameLabel.className = 'sprite-tile-name';
                nameLabel.textContent = sprite.name;
                nameLabel.title = sprite.name;

                tile.appendChild(canvasWrapper);
                tile.appendChild(nameLabel);

                tile.addEventListener('click', () => addFrameToTimeline(sprite, state.sprites.indexOf(sprite)));

                elements.spriteGrid.appendChild(tile);
            });
        }

        // ==========================================
        // Animation Library (below timeline)
        // ==========================================

        // Track hover animation intervals
        const hoverAnimations = new Map();

        function validateAnimationSprites(anim) {
            // Check if all sprites referenced in animation exist
            const missingSprites = [];
            const spriteNames = new Set(state.sprites.map(s => s.name));

            for (const frame of (anim.frames || [])) {
                const spriteName = frame.spriteName;
                if (spriteName && !spriteNames.has(spriteName)) {
                    if (!missingSprites.includes(spriteName)) {
                        missingSprites.push(spriteName);
                    }
                }
            }
            return missingSprites;
        }

        function renderAnimationLibrary() {
            const animKeys = Object.keys(state.animations);

            // Clear any existing hover animations
            hoverAnimations.forEach(interval => clearInterval(interval));
            hoverAnimations.clear();

            // Show/hide library section based on whether there are animations
            if (animKeys.length === 0) {
                elements.animationLibrarySection.style.display = 'none';
                return;
            }

            elements.animationLibrarySection.style.display = 'block';
            elements.animationLibrary.innerHTML = '';

            animKeys.forEach(key => {
                const anim = state.animations[key];
                const frameCount = anim.frames?.length || 0;
                const fps = anim.fps || 12;
                const totalDuration = frameCount > 0 ? (anim.frames.reduce((sum, f) => sum + (f.duration || 1000/fps), 0) / 1000).toFixed(1) : '0.0';

                // Validate sprites
                const missingSprites = validateAnimationSprites(anim);
                const isBroken = missingSprites.length > 0;

                const card = document.createElement('div');
                card.className = 'animation-card';
                if (state.currentAnimationKey === key) {
                    card.classList.add('active');
                }
                if (isBroken) {
                    card.classList.add('broken');
                }

                // Create preview container
                const preview = document.createElement('div');
                preview.className = 'animation-card-preview';

                // Create canvas for thumbnail
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                if (isBroken) {
                    // Draw warning icon for broken animations
                    ctx.fillStyle = '#ff4444';
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('', 32, 32);
                } else {
                    // Draw first frame as static preview
                    drawAnimationFrame(ctx, anim, 0);
                }

                preview.appendChild(canvas);

                // Name
                const nameEl = document.createElement('div');
                nameEl.className = 'animation-card-name';
                nameEl.textContent = anim.name || key;
                nameEl.title = anim.name || key;

                // Meta info
                const metaEl = document.createElement('div');
                metaEl.className = 'animation-card-meta';
                metaEl.innerHTML = `<span>${frameCount} frames</span><span>${totalDuration}s</span>`;

                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'animation-card-delete';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = 'Delete';
                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await deleteAnimation(key);
                });

                card.appendChild(preview);
                card.appendChild(nameEl);
                card.appendChild(metaEl);
                card.appendChild(deleteBtn);

                // Warning and actions for broken animations
                if (isBroken) {
                    const warningEl = document.createElement('div');
                    warningEl.className = 'animation-card-warning';
                    warningEl.innerHTML = `<span class="animation-card-warning-icon"></span> ${missingSprites.length} missing sprite${missingSprites.length > 1 ? 's' : ''}`;
                    card.appendChild(warningEl);

                    const actionsEl = document.createElement('div');
                    actionsEl.className = 'animation-card-actions';

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'btn btn-small';
                    copyBtn.textContent = 'Copy Names';
                    copyBtn.title = 'Copy missing sprite names to clipboard';
                    copyBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(missingSprites.join('\n'));
                        showToast(`Copied ${missingSprites.length} sprite name(s) to clipboard`);
                    });

                    const deleteAnimBtn = document.createElement('button');
                    deleteAnimBtn.className = 'btn btn-small btn-danger';
                    deleteAnimBtn.textContent = 'Delete';
                    deleteAnimBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await deleteAnimation(key);
                    });

                    actionsEl.appendChild(copyBtn);
                    actionsEl.appendChild(deleteAnimBtn);
                    card.appendChild(actionsEl);
                } else {
                    // Hover animation playback (only for valid animations)
                    let hoverFrame = 0;
                    card.addEventListener('mouseenter', () => {
                        if (frameCount <= 1) return;
                        hoverFrame = 0;
                        const interval = setInterval(() => {
                            hoverFrame = (hoverFrame + 1) % frameCount;
                            drawAnimationFrame(ctx, anim, hoverFrame);
                        }, 1000 / fps);
                        hoverAnimations.set(key, interval);
                    });

                    card.addEventListener('mouseleave', () => {
                        const interval = hoverAnimations.get(key);
                        if (interval) {
                            clearInterval(interval);
                            hoverAnimations.delete(key);
                        }
                        // Reset to first frame
                        drawAnimationFrame(ctx, anim, 0);
                    });
                }

                // Click to load (only for valid animations)
                if (!isBroken) {
                    card.addEventListener('click', () => loadAnimation(key));
                }

                elements.animationLibrary.appendChild(card);
            });
        }

        function drawAnimationFrame(ctx, anim, frameIndex) {
            ctx.clearRect(0, 0, 64, 64);

            if (!anim.frames || anim.frames.length === 0 || !state.masterSheetImage) return;

            const frame = anim.frames[frameIndex];
            if (!frame) return;

            // Find sprite by name
            const sprite = state.sprites.find(s => s.name === frame.spriteName);
            if (!sprite) return;

            // Scale to fit canvas while maintaining aspect ratio
            const scale = Math.min(60 / sprite.width, 60 / sprite.height);
            const destW = Math.floor(sprite.width * scale);
            const destH = Math.floor(sprite.height * scale);
            const destX = Math.floor((64 - destW) / 2);
            const destY = Math.floor((64 - destH) / 2);

            ctx.drawImage(
                state.masterSheetImage,
                sprite.x, sprite.y, sprite.width, sprite.height,
                destX, destY, destW, destH
            );
        }

        function updateAnimationStatus() {
            const isNew = !state.currentAnimationKey;
            const name = elements.animationName.value.trim();

            if (isNew) {
                elements.animationStatusBadge.textContent = 'New Animation';
                elements.animationStatusBadge.style.display = 'inline-flex';
                elements.editingAnimationName.textContent = name ? `"${name}"` : '(unsaved)';
                elements.editingAnimationName.classList.toggle('unsaved', !name);
            } else {
                elements.animationStatusBadge.textContent = 'Editing';
                elements.animationStatusBadge.style.background = 'var(--mystic-glow)';
                elements.editingAnimationName.textContent = state.animations[state.currentAnimationKey]?.name || state.currentAnimationKey;
                elements.editingAnimationName.classList.remove('unsaved');
            }
        }

        async function loadAnimation(key) {
            const anim = state.animations[key];
            if (!anim) return;

            state.currentAnimationKey = key;

            // Convert stored frames back to editor format
            state.frames = (anim.frames || []).map(f => {
                // Find sprite by name
                const sprite = state.sprites.find(s => s.name === f.spriteName) || state.sprites[f.spriteIndex];
                return {
                    sprite: sprite?.name || f.spriteName || 'unknown',
                    duration: (f.duration || 500) / 1000,
                    spriteData: sprite || { x: 0, y: 0, width: 32, height: 32, name: f.spriteName || 'unknown' },
                    spriteIndex: state.sprites.indexOf(sprite)
                };
            });

            elements.animationName.value = anim.name || key;
            elements.loopAnimation.checked = anim.loop !== false;

            // Calculate default duration from first frame or fps
            if (state.frames.length > 0) {
                elements.defaultDuration.value = state.frames[0].duration;
            } else {
                elements.defaultDuration.value = (1 / (anim.fps || 12)).toFixed(2);
            }

            state.selectedFrameIndex = -1;
            stopPlayback();

            renderTimeline();
            renderAnimationLibrary();
            updateAnimationStatus();
            updateJsonOutput();
            updateTimelineInfo();
            updateFrameEditor();
        }

        function newAnimation() {
            state.currentAnimationKey = null;
            state.frames = [];
            state.selectedFrameIndex = -1;
            elements.animationName.value = '';
            stopPlayback();

            // Reset status badge color
            elements.animationStatusBadge.style.background = '';

            renderTimeline();
            renderAnimationLibrary();
            updateAnimationStatus();
            updateJsonOutput();
            updateTimelineInfo();
            updateFrameEditor();
        }

        async function deleteAnimation(key) {
            if (!confirm('Delete this animation?')) return;

            try {
                await crucibleClient.deleteMasterSpriteSheetAnimation(state.projectId, key);
                delete state.animations[key];

                if (state.currentAnimationKey === key) {
                    newAnimation();
                }

                renderAnimationLibrary();
                showToast('Animation deleted');
            } catch (err) {
                console.error('Failed to delete animation:', err);
                showToast('Failed to delete');
            }
        }

        // ==========================================
        // Timeline
        // ==========================================
        function addFrameToTimeline(sprite, spriteIndex) {
            const duration = parseFloat(elements.defaultDuration.value) || 0.5;

            state.frames.push({
                sprite: sprite.name,
                duration: duration,
                spriteData: sprite,
                spriteIndex: spriteIndex
            });

            renderTimeline();
            updateJsonOutput();
            updateTimelineInfo();
            scheduleAutoSave();

            selectFrame(state.frames.length - 1);
        }

        function removeFrame(index) {
            state.frames.splice(index, 1);

            if (state.selectedFrameIndex >= state.frames.length) {
                state.selectedFrameIndex = state.frames.length - 1;
            }

            renderTimeline();
            updateJsonOutput();
            updateTimelineInfo();
            updateFrameEditor();
            scheduleAutoSave();
        }

        function selectFrame(index) {
            state.selectedFrameIndex = index;
            renderTimeline();
            updateFrameEditor();
        }

        function renderTimeline() {
            elements.timelineTrack.innerHTML = '';

            if (state.frames.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'timeline-empty';
                empty.innerHTML = `
                    <div class="timeline-empty-icon">&#128247;</div>
                    <div>Click sprites above to add frames</div>
                `;
                elements.timelineTrack.appendChild(empty);
                return;
            }

            state.frames.forEach((frame, index) => {
                const frameEl = document.createElement('div');
                frameEl.className = 'timeline-frame';
                if (index === state.selectedFrameIndex) {
                    frameEl.classList.add('selected');
                }
                if (index === state.playbackFrame && state.isPlaying) {
                    frameEl.style.boxShadow = '0 0 8px var(--accent-ember)';
                }
                frameEl.dataset.index = index;
                frameEl.draggable = true;

                const sprite = frame.spriteData;

                // Frame number
                const numberEl = document.createElement('div');
                numberEl.className = 'timeline-frame-number';
                numberEl.textContent = index + 1;

                // Canvas
                const canvasWrapper = document.createElement('div');
                canvasWrapper.className = 'timeline-frame-canvas';

                const canvas = document.createElement('canvas');
                const scale = Math.min(44 / sprite.width, 44 / sprite.height);
                canvas.width = Math.floor(sprite.width * scale);
                canvas.height = Math.floor(sprite.height * scale);

                if (state.masterSheetImage) {
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        state.masterSheetImage,
                        sprite.x, sprite.y, sprite.width, sprite.height,
                        0, 0, canvas.width, canvas.height
                    );
                }

                canvasWrapper.appendChild(canvas);

                // Duration
                const durationEl = document.createElement('div');
                durationEl.className = 'timeline-frame-duration';
                durationEl.textContent = frame.duration.toFixed(2) + 's';

                // Name
                const nameEl = document.createElement('div');
                nameEl.className = 'timeline-frame-name';
                nameEl.textContent = frame.sprite;
                nameEl.title = frame.sprite;

                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'timeline-frame-remove';
                removeBtn.textContent = '';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeFrame(index);
                });

                frameEl.appendChild(numberEl);
                frameEl.appendChild(canvasWrapper);
                frameEl.appendChild(durationEl);
                frameEl.appendChild(nameEl);
                frameEl.appendChild(removeBtn);

                frameEl.addEventListener('click', () => selectFrame(index));

                // Drag and drop
                frameEl.addEventListener('dragstart', handleDragStart);
                frameEl.addEventListener('dragend', handleDragEnd);
                frameEl.addEventListener('dragover', handleDragOver);
                frameEl.addEventListener('drop', handleDrop);

                elements.timelineTrack.appendChild(frameEl);

                // Add tween connector
                if (state.tweenEnabled && state.tweenDuration > 0 && index < state.frames.length - 1) {
                    const connector = document.createElement('div');
                    connector.className = 'timeline-tween-connector';
                    connector.innerHTML = `<span class="timeline-tween-connector-icon">~</span>`;
                    connector.title = `Tween: ${state.tweenDuration.toFixed(2)}s`;
                    elements.timelineTrack.appendChild(connector);
                }
            });
        }

        // Drag and drop handlers
        let draggedIndex = -1;

        function handleDragStart(e) {
            draggedIndex = parseInt(e.target.dataset.index);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedIndex = -1;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetIndex = parseInt(e.target.closest('.timeline-frame').dataset.index);

            if (draggedIndex !== -1 && draggedIndex !== targetIndex) {
                const frame = state.frames.splice(draggedIndex, 1)[0];
                state.frames.splice(targetIndex, 0, frame);

                if (state.selectedFrameIndex === draggedIndex) {
                    state.selectedFrameIndex = targetIndex;
                } else if (state.selectedFrameIndex > draggedIndex && state.selectedFrameIndex <= targetIndex) {
                    state.selectedFrameIndex--;
                } else if (state.selectedFrameIndex < draggedIndex && state.selectedFrameIndex >= targetIndex) {
                    state.selectedFrameIndex++;
                }

                renderTimeline();
                updateJsonOutput();
                scheduleAutoSave();
            }
        }

        function updateTimelineInfo() {
            const holdDuration = state.frames.reduce((sum, f) => sum + f.duration, 0);
            const tweenTime = state.tweenEnabled && state.frames.length > 1
                ? state.tweenDuration * state.frames.length
                : 0;
            const totalDuration = holdDuration + tweenTime;

            let info = `${state.frames.length} frames | ${totalDuration.toFixed(2)}s`;
            if (tweenTime > 0) {
                info += ` (${tweenTime.toFixed(2)}s tween)`;
            }
            elements.timelineInfo.textContent = info;
        }

        function clearTimeline() {
            state.frames = [];
            state.selectedFrameIndex = -1;
            stopPlayback();
            renderTimeline();
            updateJsonOutput();
            updateTimelineInfo();
            updateFrameEditor();
            scheduleAutoSave();
        }

        // ==========================================
        // Frame Editor
        // ==========================================
        function updateFrameEditor() {
            if (state.selectedFrameIndex < 0 || state.selectedFrameIndex >= state.frames.length) {
                elements.frameEditor.classList.remove('active');
                return;
            }

            elements.frameEditor.classList.add('active');

            const frame = state.frames[state.selectedFrameIndex];
            elements.frameSpriteName.value = frame.sprite;
            elements.frameDuration.value = frame.duration;
        }

        function updateSelectedFrameDuration(duration) {
            if (state.selectedFrameIndex < 0) return;

            state.frames[state.selectedFrameIndex].duration = duration;
            renderTimeline();
            updateJsonOutput();
            updateTimelineInfo();
            scheduleAutoSave();
        }

        // ==========================================
        // Preview Playback
        // ==========================================
        function startPlayback() {
            if (state.frames.length === 0) return;

            state.isPlaying = true;
            state.playbackFrame = 0;
            state.playbackTimer = 0;
            elements.playBtn.textContent = '\u23f8';

            lastTime = performance.now();
            animationLoop = requestAnimationFrame(updatePlayback);
        }

        function stopPlayback() {
            state.isPlaying = false;
            state.playbackFrame = 0;
            state.playbackTimer = 0;
            elements.playBtn.textContent = '\u25b6';

            if (animationLoop) {
                cancelAnimationFrame(animationLoop);
                animationLoop = null;
            }

            renderPreview();
            renderTimeline();
            updatePreviewInfo();
        }

        function togglePlayback() {
            if (state.isPlaying) {
                state.isPlaying = false;
                elements.playBtn.textContent = '\u25b6';
                if (animationLoop) {
                    cancelAnimationFrame(animationLoop);
                    animationLoop = null;
                }
            } else {
                startPlayback();
            }
        }

        function stepFrame() {
            if (state.frames.length === 0) return;

            state.playbackFrame = (state.playbackFrame + 1) % state.frames.length;
            renderPreview();
            renderTimeline();
            updatePreviewInfo();
        }

        function updatePlayback(currentTime) {
            if (!state.isPlaying) return;

            const dt = (currentTime - lastTime) / 1000 * state.speedMultiplier;
            lastTime = currentTime;

            state.playbackTimer += dt;

            const currentFrame = state.frames[state.playbackFrame];
            if (!currentFrame) {
                animationLoop = requestAnimationFrame(updatePlayback);
                return;
            }

            const holdDuration = currentFrame.duration;
            const tweenDur = state.tweenEnabled ? state.tweenDuration : 0;
            const totalFrameTime = holdDuration + tweenDur;

            if (state.playbackTimer < holdDuration) {
                state.tweenProgress = 0;
            } else if (tweenDur > 0) {
                state.tweenProgress = Math.min((state.playbackTimer - holdDuration) / tweenDur, 1);
            }

            if (state.playbackTimer >= totalFrameTime) {
                state.playbackTimer = 0;
                state.tweenProgress = 0;
                state.playbackFrame = (state.playbackFrame + 1) % state.frames.length;
                renderTimeline();
            }

            renderPreview();
            updatePreviewInfo();

            animationLoop = requestAnimationFrame(updatePlayback);
        }

        function renderPreview() {
            previewCtx.clearRect(0, 0, 128, 128);

            if (state.frames.length === 0 || !state.masterSheetImage) return;

            const currentFrame = state.frames[state.playbackFrame];
            if (!currentFrame) return;

            const nextFrameIndex = (state.playbackFrame + 1) % state.frames.length;
            const nextFrame = state.frames[nextFrameIndex];

            function drawSprite(frame, alpha) {
                const sprite = frame.spriteData;
                const scale = Math.min(120 / sprite.width, 120 / sprite.height);
                const destW = Math.floor(sprite.width * scale);
                const destH = Math.floor(sprite.height * scale);
                const destX = Math.floor((128 - destW) / 2);
                const destY = Math.floor((128 - destH) / 2);

                previewCtx.globalAlpha = alpha;
                previewCtx.drawImage(
                    state.masterSheetImage,
                    sprite.x, sprite.y, sprite.width, sprite.height,
                    destX, destY, destW, destH
                );
            }

            if (state.tweenEnabled && state.tweenProgress > 0 && state.tweenDuration > 0 && nextFrame) {
                const easedProgress = easeInOutCubic(state.tweenProgress);
                drawSprite(currentFrame, 1 - easedProgress);
                drawSprite(nextFrame, easedProgress);
                previewCtx.globalAlpha = 1;
            } else {
                drawSprite(currentFrame, 1);
            }
        }

        function easeInOutCubic(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function updatePreviewInfo() {
            if (state.frames.length === 0) {
                elements.previewInfo.textContent = 'No frames';
            } else {
                let info = `Frame ${state.playbackFrame + 1}/${state.frames.length}`;
                if (state.tweenEnabled && state.tweenProgress > 0 && state.tweenDuration > 0) {
                    info += ` (tween ${Math.round(state.tweenProgress * 100)}%)`;
                }
                elements.previewInfo.textContent = info;
            }
        }

        // ==========================================
        // Save / Auto-save
        // ==========================================
        function scheduleAutoSave() {
            state.isDirty = true;

            if (state.saveTimeout) {
                clearTimeout(state.saveTimeout);
            }

            if (!state.user || !state.projectId || !state.masterSheetImage) {
                saveToLocalStorage();
                return;
            }

            elements.saveIndicator.textContent = 'Modified';
            elements.saveIndicator.className = 'save-indicator';

            state.saveTimeout = setTimeout(async () => {
                await autoSaveAnimation();
            }, 2000);
        }

        async function autoSaveAnimation() {
            // Only auto-save if editing existing animation
            if (!state.user || !state.projectId || !state.masterSheetImage || state.frames.length === 0) return;
            if (!state.currentAnimationKey) return; // Don't auto-save new unsaved animations

            const name = elements.animationName.value.trim();
            if (!name) return;

            elements.saveIndicator.textContent = 'Saving...';
            elements.saveIndicator.className = 'save-indicator saving';

            try {
                await saveAnimationToCloud();
                elements.saveIndicator.textContent = 'Saved';
                elements.saveIndicator.className = 'save-indicator saved';
                state.isDirty = false;
            } catch (err) {
                console.error('Auto-save failed:', err);
                elements.saveIndicator.textContent = 'Save failed';
                elements.saveIndicator.className = 'save-indicator';
            }
        }

        async function saveAnimationToCloud() {
            const name = elements.animationName.value.trim();
            if (!name) {
                showToast('Please enter an animation name');
                return;
            }

            const fps = Math.round(1 / (parseFloat(elements.defaultDuration.value) || 0.5));
            const loop = elements.loopAnimation.checked;

            // Convert frames to storage format (store sprite names for portability)
            const frames = state.frames.map(f => ({
                spriteName: f.sprite,
                duration: Math.round(f.duration * 1000)
            }));

            // Generate a key from the name (lowercase, replace spaces with dashes)
            const animKey = state.currentAnimationKey || name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

            const animationData = {
                name,
                description: '', // Can be added later
                frames,
                fps,
                loop
            };

            try {
                await crucibleClient.saveMasterSpriteSheetAnimation(state.projectId, animKey, animationData);

                // Update local cache
                state.animations[animKey] = animationData;
                state.currentAnimationKey = animKey;

                renderAnimationLibrary();
                updateAnimationStatus();
                showToast('Animation saved');
            } catch (err) {
                console.error('Failed to save animation:', err);
                showToast('Failed to save animation');
            }
        }

        // ==========================================
        // JSON Output
        // ==========================================
        function updateJsonOutput() {
            const animName = elements.animationName.value || 'untitled';
            const useUniform = elements.uniformDuration.checked;

            let animData;

            if (useUniform) {
                const defaultDur = parseFloat(elements.defaultDuration.value) || 0.5;
                animData = {
                    frames: state.frames.map(f => f.sprite),
                    frameDuration: defaultDur
                };
            } else {
                animData = {
                    frames: state.frames.map(f => ({
                        sprite: f.sprite,
                        duration: f.duration
                    }))
                };
            }

            if (state.tweenEnabled && state.tweenDuration > 0) {
                animData.tween = {
                    enabled: true,
                    duration: state.tweenDuration,
                    easing: 'easeInOutCubic'
                };
            }

            animData.loop = elements.loopAnimation.checked;

            const output = { [animName]: animData };
            elements.jsonOutput.textContent = JSON.stringify(output, null, 2);
        }

        function copyJson() {
            navigator.clipboard.writeText(elements.jsonOutput.textContent)
                .then(() => showToast('JSON copied!'))
                .catch(() => showToast('Failed to copy'));
        }

        // ==========================================
        // Uniform Duration Sync
        // ==========================================
        function applyUniformDuration() {
            if (!elements.uniformDuration.checked) return;

            const duration = parseFloat(elements.defaultDuration.value) || 0.5;
            state.frames.forEach(f => f.duration = duration);
            renderTimeline();
            updateJsonOutput();
            updateTimelineInfo();
            updateFrameEditor();
            scheduleAutoSave();
        }

        // ==========================================
        // Utilities
        // ==========================================
        function showToast(message) {
            elements.toast.textContent = message;
            elements.toast.classList.add('show');
            setTimeout(() => elements.toast.classList.remove('show'), 2500);
        }

        // ==========================================
        // Event Listeners
        // ==========================================
        function setupEventListeners() {
            elements.projectSelect.addEventListener('change', (e) => {
                selectProject(e.target.value);
            });

            elements.sourceFilter.addEventListener('change', (e) => {
                state.sourceFilter = e.target.value;
                renderSpritePalette();
            });

            elements.newAnimationBtn.addEventListener('click', newAnimation);
            elements.clearTimeline.addEventListener('click', clearTimeline);

            elements.playBtn.addEventListener('click', togglePlayback);
            elements.stopBtn.addEventListener('click', stopPlayback);
            elements.stepBtn.addEventListener('click', stepFrame);

            elements.speedMultiplier.addEventListener('change', (e) => {
                state.speedMultiplier = parseFloat(e.target.value) || 1;
            });

            elements.animationName.addEventListener('input', () => {
                updateJsonOutput();
                updateAnimationStatus();
                scheduleAutoSave();
            });

            elements.defaultDuration.addEventListener('change', () => {
                applyUniformDuration();
                updateJsonOutput();
            });

            elements.uniformDuration.addEventListener('change', () => {
                applyUniformDuration();
                updateJsonOutput();
            });

            elements.loopAnimation.addEventListener('change', () => {
                updateJsonOutput();
                scheduleAutoSave();
            });

            elements.enableTween.addEventListener('change', (e) => {
                state.tweenEnabled = e.target.checked;
                if (state.tweenEnabled && state.tweenDuration === 0) {
                    state.tweenDuration = 0.15;
                    elements.tweenDuration.value = 0.15;
                }
                renderTimeline();
                updateTimelineInfo();
                updateJsonOutput();
                scheduleAutoSave();
            });

            elements.tweenDuration.addEventListener('change', (e) => {
                state.tweenDuration = parseFloat(e.target.value) || 0;
                if (state.tweenDuration > 0 && !state.tweenEnabled) {
                    state.tweenEnabled = true;
                    elements.enableTween.checked = true;
                }
                renderTimeline();
                updateTimelineInfo();
                updateJsonOutput();
                scheduleAutoSave();
            });

            elements.frameDuration.addEventListener('change', (e) => {
                const duration = parseFloat(e.target.value) || 0.5;
                updateSelectedFrameDuration(duration);
            });

            elements.removeFrameBtn.addEventListener('click', () => {
                if (state.selectedFrameIndex >= 0) {
                    removeFrame(state.selectedFrameIndex);
                }
            });

            elements.saveAnimationBtn.addEventListener('click', async () => {
                if (!state.user) {
                    showToast('Sign in to save animations');
                    return;
                }
                if (!state.projectId || !state.masterSheetImage) {
                    showToast('Select a project first');
                    return;
                }
                await saveAnimationToCloud();
            });

            elements.copyJsonBtn.addEventListener('click', copyJson);

            // Keyboard shortcuts
            window.addEventListener('keydown', (e) => {
                if (e.key === ' ' && document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    togglePlayback();
                }
                if (e.key === 'Delete' && state.selectedFrameIndex >= 0) {
                    removeFrame(state.selectedFrameIndex);
                }
            });
        }

        // ==========================================
        // Initialize
        // ==========================================
        init();
    </script>

    <!-- Help Drawer -->
    <script src="../shared/help-drawer.js"></script>
    <script src="../shared/docs/animancer-docs.js"></script>
    <script>
        // Initialize help drawer with Animancer docs
        HelpDrawer.init({
            toolId: 'animancer',
            toolName: 'Animancer',
            toolIcon: '&#127916;',
            accentColor: '#e07020',
            docs: ANIMANCER_DOCS
        });
    </script>
</body>
</html>
